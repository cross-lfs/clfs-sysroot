Submitted By: Jim Gifford (jim at cross-lfs dot org)
Date: 06-05-2009
Initial Package Version: 7.2
Origin: Upstream
Upstream Status: Applied
Description: Contains all upstream patches up to 7.2.196
             The following patches were skipped
             007 036 041 049 071 072 074 088 089 093 101 138 150 172 173 191 194

diff -Naur vim72.orig/Filelist vim72/Filelist
--- vim72.orig/Filelist	2008-07-06 11:02:23.000000000 -0700
+++ vim72/Filelist	2009-06-05 14:26:12.000000000 -0700
@@ -285,6 +285,7 @@
 		src/proto/os_win32.pro \
 		src/proto/os_mswin.pro \
 		src/testdir/Make_dos.mak \
+		src/testdir/Make_ming.mak \
 		src/testdir/dos.vim \
 		src/uninstal.c \
 		src/vim.def \
@@ -682,9 +683,7 @@
 		runtime/spell/??/main.aap \
 		runtime/spell/yi/README.txt \
 		runtime/spell/main.aap \
-		runtime/spell/cleanadd.vim \
 		runtime/spell/*.vim \
-		runtime/spell/fixdup \
 
 # generic language files, binary
 LANG_GEN_BIN = \
diff -Naur vim72.orig/runtime/doc/cmdline.txt vim72/runtime/doc/cmdline.txt
--- vim72.orig/runtime/doc/cmdline.txt	2008-08-09 07:22:59.000000000 -0700
+++ vim72/runtime/doc/cmdline.txt	2009-06-05 14:16:09.000000000 -0700
@@ -1,4 +1,4 @@
-*cmdline.txt*   For Vim version 7.2.  Last change: 2008 Jul 29
+*cmdline.txt*   For Vim version 7.2.  Last change: 2008 Sep 18
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -157,6 +157,11 @@
 				(doesn't work at the expression prompt; some
 				things such as changing the buffer or current
 				window are not allowed to avoid side effects)
+				When the result is a |List| the items are used
+				as lines.  They can have line breaks inside
+				too.
+				When the result is a Float it's automatically
+				converted to a String.
 		See |registers| about registers.  {not in Vi}
 		Implementation detail: When using the |expression| register
 		and invoking setcmdpos(), this sets the position before
@@ -730,19 +735,29 @@
 In Ex commands, at places where a file name can be used, the following
 characters have a special meaning.  These can also be used in the expression
 function expand() |expand()|.
-	%	is replaced with the current file name			*:_%*
-	#	is replaced with the alternate file name		*:_#*
+	%	Is replaced with the current file name.		  *:_%* *c_%*
+	#	Is replaced with the alternate file name.	  *:_#* *c_#*
 	#n	(where n is a number) is replaced with the file name of
-		buffer n.  "#0" is the same as "#"
-	##	is replaced with all names in the argument list		*:_##*
+		buffer n.  "#0" is the same as "#".
+	##	Is replaced with all names in the argument list	  *:_##* *c_##*
 		concatenated, separated by spaces.  Each space in a name
 		is preceded with a backslash.
-Note that these give the file name as it was typed.  If an absolute path is
-needed (when using the file name from a different directory), you need to add
-":p".  See |filename-modifiers|.
+	#<n	(where n is a number > 0) is replaced with old	  *:_#<* *c_#<*
+		file name n.  See |:oldfiles| or |v:oldfiles| to get the
+		number.							*E809*
+		{only when compiled with the +eval and +viminfo features}
+
+Note that these, except "#<n", give the file name as it was typed.  If an
+absolute path is needed (when using the file name from a different directory),
+you need to add ":p".  See |filename-modifiers|.
+
+The "#<n" item returns an absolute path, but it will start with "~/" for files
+below your home directory.
+
 Note that backslashes are inserted before spaces, so that the command will
 correctly interpret the file name.  But this doesn't happen for shell
-commands.  For those you probably have to use quotes: >
+commands.  For those you probably have to use quotes (this fails for files
+that contain a quote and wildcards): >
 	:!ls "%"
 	:r !spell "%"
 
diff -Naur vim72.orig/runtime/doc/eval.txt vim72/runtime/doc/eval.txt
--- vim72.orig/runtime/doc/eval.txt	2008-08-09 07:22:59.000000000 -0700
+++ vim72/runtime/doc/eval.txt	2009-06-05 14:23:32.000000000 -0700
@@ -1,4 +1,4 @@
-*eval.txt*	For Vim version 7.2.  Last change: 2008 Aug 09
+*eval.txt*	For Vim version 7.2.  Last change: 2008 Nov 27
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -1484,6 +1484,17 @@
 		This is the screen column number, like with |virtcol()|.  The
 		value is zero when there was no mouse button click.
 
+					*v:oldfiles* *oldfiles-variable*
+v:oldfiles	List of file names that is loaded from the |viminfo| file on
+		startup.  These are the files that Vim remembers marks for.
+		The length of the List is limited by the ' argument of the
+		'viminfo' option (default is 100).
+		Also see |:oldfiles| and |c_#<|.
+		The List can be modified, but this has no effect on what is
+		stored in the |viminfo| file later.  If you use values other
+		than String this will cause trouble.
+		{only when compiled with the +viminfo feature}
+
 					*v:operator* *operator-variable*
 v:operator	The last operator given in Normal mode.  This is a single
 		character except for commands starting with <g> or <z>,
@@ -1695,7 +1706,7 @@
 exists( {expr})			Number	TRUE if {expr} exists
 extend({expr1}, {expr2} [, {expr3}])
 				List/Dict insert items of {expr2} into {expr1}
-expand( {expr})			String	expand special keywords in {expr}
+expand( {expr} [, {flag}])	String	expand special keywords in {expr}
 feedkeys( {string} [, {mode}])	Number	add key sequence to typeahead buffer
 filereadable( {file})		Number	TRUE if {file} is a readable file
 filewritable( {file})		Number	TRUE if {file} is a writable file
@@ -1747,8 +1758,9 @@
 getwinposx()			Number	X coord in pixels of GUI Vim window
 getwinposy()			Number	Y coord in pixels of GUI Vim window
 getwinvar( {nr}, {varname})	any	variable {varname} in window {nr}
-glob( {expr})			String	expand file wildcards in {expr}
-globpath( {path}, {expr})	String	do glob({expr}) for all dirs in {path}
+glob( {expr} [, {flag}])	String	expand file wildcards in {expr}
+globpath( {path}, {expr} [, {flag}])
+				String	do glob({expr}) for all dirs in {path}
 has( {feature})			Number	TRUE if feature {feature} supported
 has_key( {dict}, {key})		Number	TRUE if {dict} has entry {key}
 haslocaldir()			Number	TRUE if current window executed |:lcd|
@@ -2402,6 +2414,7 @@
 		When 'virtualedit' is used {off} specifies the offset in
 		screen columns from the start of the character.  E.g., a
 		position within a <Tab> or after the last character.
+		Returns 0 when the position could be set, -1 otherwise.
 
 
 deepcopy({expr}[, {noref}])				*deepcopy()* *E698*
@@ -3275,14 +3288,16 @@
 			:let list_is_on = getwinvar(2, '&list')
 			:echo "myvar = " . getwinvar(1, 'myvar')
 <
-							*glob()*
-glob({expr})	Expand the file wildcards in {expr}.  See |wildcards| for the
+glob({expr} [, {flag}])					*glob()*
+		Expand the file wildcards in {expr}.  See |wildcards| for the
 		use of special characters.
 		The result is a String.
 		When there are several matches, they are separated by <NL>
 		characters.
-		The 'wildignore' option applies: Names matching one of the
-		patterns in 'wildignore' will be skipped.
+		Unless the optional {flag} argument is given and is non-zero,
+		the 'suffixes' and 'wildignore' options apply: Names matching
+		one of the patterns in 'wildignore' will be skipped and
+		'suffixes' affect the ordering of matches.
 		If the expansion fails, the result is an empty string.
 		A name for a non-existing file is not included.
 
@@ -3296,20 +3311,22 @@
 		See |expand()| for expanding special Vim variables.  See
 		|system()| for getting the raw output of an external command.
 
-globpath({path}, {expr})				*globpath()*
+globpath({path}, {expr} [, {flag}])			*globpath()*
 		Perform glob() on all directories in {path} and concatenate
 		the results.  Example: >
 			:echo globpath(&rtp, "syntax/c.vim")
 <		{path} is a comma-separated list of directory names.  Each
 		directory name is prepended to {expr} and expanded like with
-		glob().  A path separator is inserted when needed.
+		|glob()|.  A path separator is inserted when needed.
 		To add a comma inside a directory name escape it with a
 		backslash.  Note that on MS-Windows a directory may have a
 		trailing backslash, remove it if you put a comma after it.
 		If the expansion fails for one of the directories, there is no
 		error message.
-		The 'wildignore' option applies: Names matching one of the
-		patterns in 'wildignore' will be skipped.
+		Unless the optional {flag} argument is given and is non-zero,
+		the 'suffixes' and 'wildignore' options apply: Names matching
+		one of the patterns in 'wildignore' will be skipped and
+		'suffixes' affect the ordering of matches.
 
 		The "**" item can be used to search in a directory tree.
 		For example, to find all "README.txt" files in the directories
@@ -4500,6 +4517,7 @@
 		should also work to move files across file systems.  The
 		result is a Number, which is 0 if the file was renamed
 		successfully, and non-zero when the renaming failed.
+		NOTE: If {to} exists it is overwritten without warning.
 		This function is not available in the |sandbox|.
 
 repeat({expr}, {count})					*repeat()*
@@ -5332,10 +5350,12 @@
 		"fg"		foreground color (GUI: color name used to set
 				the color, cterm: color number as a string,
 				term: empty string)
-		"bg"		background color (like "fg")
+		"bg"		background color (as with "fg")
+		"sp"		special color (as with "fg") |highlight-guisp|
 		"fg#"		like "fg", but for the GUI and the GUI is
 				running the name in "#RRGGBB" form
 		"bg#"		like "fg#" for "bg"
+		"sp#"		like "fg#" for "sp"
 		"bold"		"1" if bold
 		"italic"	"1" if italic
 		"reverse"	"1" if reverse
@@ -5823,7 +5843,8 @@
 mouse_pterm		Compiled with support for qnx pterm mouse.
 mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
 mouse_xterm		Compiled with support for xterm mouse.
-multi_byte		Compiled with support for editing Korean et al.
+multi_byte		Compiled with support for 'encoding'
+multi_byte_encoding	'encoding' is set to a multi-byte encoding.
 multi_byte_ime		Compiled with support for IME input method.
 multi_lang		Compiled with support for multiple languages.
 mzscheme		Compiled with MzScheme interface |mzscheme|.
diff -Naur vim72.orig/runtime/doc/if_cscop.txt vim72/runtime/doc/if_cscop.txt
--- vim72.orig/runtime/doc/if_cscop.txt	2008-08-09 07:22:59.000000000 -0700
+++ vim72/runtime/doc/if_cscop.txt	2009-06-05 14:23:20.000000000 -0700
@@ -1,4 +1,4 @@
-*if_cscop.txt*  For Vim version 7.2.  Last change: 2005 Mar 29
+*if_cscop.txt*  For Vim version 7.2.  Last change: 2009 Mar 18
 
 
 		  VIM REFERENCE MANUAL    by Andy Kahn
@@ -131,11 +131,22 @@
 		7 or f: Find this file
 		8 or i: Find files #including this file
 
+	For all types, except 4 and 6, leading white space for {name} is
+	removed.  For 4 and 6 there is exactly one space between {querytype}
+	and {name}.  Further white space is included in {name}.
+
 	EXAMPLES >
 	    :cscope find c vim_free
-	    :cscope find 3 vim_free
+	    :cscope find 3  vim_free
+<
+	    These two examples perform the same query: functions calling
+	    "vim_free". >
+
+	    :cscope find t initOnce
+	    :cscope find t  initOnce
 <
-	    These two examples perform the same query. >
+	    The first one searches for the text "initOnce", the second one for
+	    " initOnce". >
 
 	    :cscope find 0 DEFAULT_TERM
 <
diff -Naur vim72.orig/runtime/doc/netbeans.txt vim72/runtime/doc/netbeans.txt
--- vim72.orig/runtime/doc/netbeans.txt	2008-08-09 07:22:59.000000000 -0700
+++ vim72/runtime/doc/netbeans.txt	2009-06-05 14:19:24.000000000 -0700
@@ -1,4 +1,4 @@
-*netbeans.txt*  For Vim version 7.2.  Last change: 2008 Jun 28
+*netbeans.txt*  For Vim version 7.2.  Last change: 2009 Jan 06
 
 
 		  VIM REFERENCE MANUAL    by Gordon Prieur et al.
@@ -722,8 +722,10 @@
 		of the cursor.
 		New in version 2.1.
 
-killed		A file was closed by the user.  Only for files that have been
-		assigned a number by the IDE.
+killed		A file was deleted or wiped out by the user and the buffer
+		annotations have been removed.  The bufID number for this
+		buffer has become invalid.  Only for files that have been
+		assigned a bufID number by the IDE.
 
 newDotAndMark off off
 		Reports the position of the cursor being at "off" bytes into
diff -Naur vim72.orig/runtime/doc/options.txt vim72/runtime/doc/options.txt
--- vim72.orig/runtime/doc/options.txt	2008-08-09 07:22:59.000000000 -0700
+++ vim72/runtime/doc/options.txt	2009-06-05 14:21:21.000000000 -0700
@@ -1,4 +1,4 @@
-*options.txt*	For Vim version 7.2.  Last change: 2008 Aug 06
+*options.txt*	For Vim version 7.2.  Last change: 2008 Nov 25
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -4175,9 +4175,6 @@
 	be able to execute Normal mode commands.
 	This is the opposite of the 'keymap' option, where characters are
 	mapped in Insert mode.
-	This only works for 8-bit characters.  The value of 'langmap' may be
-	specified with multi-byte characters (e.g., UTF-8), but only the lower
-	8 bits of each character will be used.
 
 	Example (for Greek, in UTF-8):				*greek*  >
 	    :set langmap=ΑA,ΒB,ΨC,ΔD,ΕE,ΦF,ΓG,ΗH,ΙI,ΞJ,ΚK,ΛL,ΜM,ΝN,ΟO,ΠP,QQ,ΡR,ΣS,ΤT,ΘU,ΩV,WW,ΧX,ΥY,ΖZ,αa,βb,ψc,δd,εe,φf,γg,ηh,ιi,ξj,κk,λl,μm,νn,οo,πp,qq,ρr,σs,τt,θu,ωv,ςw,χx,υy,ζz
@@ -7472,7 +7469,9 @@
 			{not available when compiled without the |+wildignore|
 			feature}
 	A list of file patterns.  A file that matches with one of these
-	patterns is ignored when completing file or directory names.
+	patterns is ignored when completing file or directory names, and
+	influences the result of |expand()|, |glob()| and |globpath()| unless
+	a flag is passed to disable this.
 	The pattern is used like with |:autocmd|, see |autocmd-patterns|.
 	Also see 'suffixes'.
 	Example: >
diff -Naur vim72.orig/runtime/doc/spell.txt vim72/runtime/doc/spell.txt
--- vim72.orig/runtime/doc/spell.txt	2008-08-09 07:23:00.000000000 -0700
+++ vim72/runtime/doc/spell.txt	2009-06-05 14:18:12.000000000 -0700
@@ -1,4 +1,4 @@
-*spell.txt*	For Vim version 7.2.  Last change: 2008 Jun 21
+*spell.txt*	For Vim version 7.2.  Last change: 2008 Nov 30
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -831,8 +831,11 @@
 
 	# comment line ~
 
-With some items it's also possible to put a comment after it, but this isn't
-supported in general.
+Items with a fixed number of arguments can be followed by a comment.  But only
+if none of the arguments can contain white space.  The comment must start with
+a "#" character.  Example:
+
+	KEEPCASE =  # fix case for words with this flag ~
 
 
 ENCODING							*spell-SET*
@@ -965,6 +968,9 @@
 
 Note: When using utf-8 only characters up to 65000 may be used for flags.
 
+Note: even when using "num" or "long" the number of flags available to
+compounding and prefixes is limited to about 250.
+
 
 AFFIXES
 					    *spell-PFX* *spell-SFX*
@@ -1178,6 +1184,9 @@
 The flag also applies to the word with affixes, thus this can be used to mark
 a whole bunch of related words as bad.
 
+							*spell-FORBIDDENWORD*
+FORBIDDENWORD can be used just like BAD.  For compatibility with Hunspell.
+
 							*spell-NEEDAFFIX*
 The NEEDAFFIX flag is used to require that a word is used with an affix.  The
 word itself is not a good word (unless there is an empty affix).  Example:
@@ -1268,6 +1277,10 @@
 
 	NEEDCOMPOUND & ~
 
+							*spell-ONLYINCOMPOUND*
+The ONLYINCOMPOUND does exactly the same as NEEDCOMPOUND.  Supported for
+compatiblity with Hunspell.
+
 							*spell-COMPOUNDMIN*
 The minimal character length of a word used for compounding is specified with
 COMPOUNDMIN.  Example:
@@ -1328,6 +1341,20 @@
 rules.  Can also be used for an affix to count the affix as a compounding
 word.
 
+						*spell-CHECKCOMPOUNDPATTERN*
+CHECKCOMPOUNDPATTERN is used to define patterns that, when matching at the
+position where two words are compounded together forbids the compound.
+For example:
+	CHECKCOMPOUNDPATTERN o e ~
+
+This forbids compounding if the first word ends in "o" and the second word
+starts with "e".
+
+The arguments must be plain text, no patterns are actually supported, despite
+the item name.  Case is always ignored.
+
+The Hunspell feature to use three arguments and flags is not supported.
+
 							*spell-SYLLABLE*
 The SYLLABLE item defines characters or character sequences that are used to
 count the number of syllables in a word.  Example:
@@ -1496,6 +1523,10 @@
 ACCENT		(Hunspell)				*spell-ACCENT*
 		Use MAP instead. |spell-MAP|
 
+BREAK		(Hunspell)				*spell-BREAK*
+		Define break points.  Unclear how it works exactly.
+		Not supported.
+
 CHECKCOMPOUNDCASE  (Hunspell)			*spell-CHECKCOMPOUNDCASE*
 		Disallow uppercase letters at compound word boundaries.
 		Not supported.
@@ -1512,9 +1543,6 @@
 		Forbid three identical characters when compounding.  Not
 		supported.
 
-CHECKCOMPOUNDPATTERN  (Hunspell)		*spell-CHECKCOMPOUNDPATTERN*
-		Forbid compounding when patterns match.  Not supported.
-
 COMPLEXPREFIXES  (Hunspell)				*spell-COMPLEXPREFIXES*
 		Enables using two prefixes.  Not supported.
 
@@ -1536,13 +1564,18 @@
 COMPOUNDMIDDLE	(Hunspell)				*spell-COMPOUNDMIDDLE*
 		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|
 
+COMPOUNDRULES	(Hunspell)				*spell-COMPOUNDRULES*
+		Number of COMPOUNDRULE lines following.  Ignored, but the
+		argument must be a number.
+
 COMPOUNDSYLLABLE  (Hunspell)			*spell-COMPOUNDSYLLABLE*
 		Use SYLLABLE and COMPOUNDSYLMAX instead. |spell-SYLLABLE|
 		|spell-COMPOUNDSYLMAX|
 
-FORBIDDENWORD	(Hunspell)				*spell-FORBIDDENWORD*
-		Use BAD instead. |spell-BAD|
-
+KEY		(Hunspell)				*spell-KEY*
+		Define characters that are close together on the keyboard.
+		Used to give better suggestions.  Not supported.
+		
 LANG		(Hunspell)				*spell-LANG*
 		This specifies language-specific behavior.  This actually
 		moves part of the language knowledge into the program,
@@ -1553,10 +1586,7 @@
 		Only needed for morphological analysis.
 
 MAXNGRAMSUGS	(Hunspell)				*spell-MAXNGRAMSUGS*
-		Not supported.
-
-ONLYINCOMPOUND	(Hunspell)				*spell-ONLYINCOMPOUND*
-		Use NEEDCOMPOUND instead. |spell-NEEDCOMPOUND|
+		Set number of n-gram suggestions.  Not supported.
 
 PSEUDOROOT	(Hunspell)				*spell-PSEUDOROOT*
 		Use NEEDAFFIX instead. |spell-NEEDAFFIX|
diff -Naur vim72.orig/runtime/doc/starting.txt vim72/runtime/doc/starting.txt
--- vim72.orig/runtime/doc/starting.txt	2008-08-09 07:23:00.000000000 -0700
+++ vim72/runtime/doc/starting.txt	2009-06-05 14:16:09.000000000 -0700
@@ -1,4 +1,4 @@
-*starting.txt*  For Vim version 7.2.  Last change: 2008 Jun 21
+*starting.txt*  For Vim version 7.2.  Last change: 2008 Nov 09
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -1337,8 +1337,9 @@
 							*viminfo-read*
 When Vim is started and the 'viminfo' option is non-empty, the contents of
 the viminfo file are read and the info can be used in the appropriate places.
-The marks are not read in at startup (but file marks are).  See
-|initialization| for how to set the 'viminfo' option upon startup.
+The |v:oldfiles| variable is filled.  The marks are not read in at startup
+(but file marks are).  See |initialization| for how to set the 'viminfo'
+option upon startup.
 
 							*viminfo-write*
 When Vim exits and 'viminfo' is non-empty, the info is stored in the viminfo
@@ -1372,6 +1373,8 @@
 that start with any string given with the "r" flag in 'viminfo'.  This can be
 used to avoid saving marks for files on removable media (for MS-DOS you would
 use "ra:,rb:", for Amiga "rdf0:,rdf1:,rdf2:").
+The |v:oldfiles| variable is filled with the file names that the viminfo file
+has marks for.
 
 							*viminfo-file-marks*
 Uppercase marks ('A to 'Z) are stored when writing the viminfo file.  The
@@ -1463,8 +1466,8 @@
 						   *:rv* *:rviminfo* *E195*
 :rv[iminfo][!] [file]	Read from viminfo file [file] (default: see above).
 			If [!] is given, then any information that is
-			already set (registers, marks, etc.) will be
-			overwritten.  {not in Vi}
+			already set (registers, marks, |v:oldfiles|, etc.)
+			will be overwritten   {not in Vi}
 
 					*:wv* *:wviminfo* *E137* *E138* *E574*
 :wv[iminfo][!] [file]	Write to viminfo file [file] (default: see above).
@@ -1479,4 +1482,20 @@
 			the .viminfo file.
 			{not in Vi}
 
+						*:ol* *:oldfiles*
+:ol[dfiles]		List the files that have marks stored in the viminfo
+			file.  This list is read on startup and only changes
+			afterwards with ":rviminfo!".  Also see |v:oldfiles|.
+			The number can be used with |c_#<|.
+			{not in Vi, only when compiled with the +eval feature}
+
+:bro[wse] ol[dfiles][!]
+			List file names as with |:oldfiles|, and then prompt
+			for a number.  When the number is valid that file from
+			the list is edited.
+			If you get the |press-enter| prompt you can press "q"
+			and still get the prompt to enter a file number.
+			Use ! to abondon a modified buffer. |abandon|
+			{not when compiled with tiny or small features}
+
  vim:tw=78:ts=8:ft=help:norl:
diff -Naur vim72.orig/runtime/doc/usr_21.txt vim72/runtime/doc/usr_21.txt
--- vim72.orig/runtime/doc/usr_21.txt	2008-08-09 07:23:01.000000000 -0700
+++ vim72/runtime/doc/usr_21.txt	2009-06-05 14:16:09.000000000 -0700
@@ -1,4 +1,4 @@
-*usr_21.txt*	For Vim version 7.2.  Last change: 2007 May 01
+*usr_21.txt*	For Vim version 7.2.  Last change: 2008 Nov 09
 
 		     VIM USER MANUAL - by Bram Moolenaar
 
@@ -153,7 +153,7 @@
 to be lost.  Each item can be remembered only once.
 
 
-GETTING BACK TO WHERE YOU WERE
+GETTING BACK TO WHERE YOU STOPPED VIM
 
 You are halfway editing a file and it's time to leave for holidays.  You exit
 Vim and go enjoy yourselves, forgetting all about your work.  After a couple
@@ -168,6 +168,48 @@
    The |:marks| command is useful to find out where '0 to '9 will take you.
 
 
+GETTING BACK TO SOME FILE
+
+If you want to go back to a file that you edited recently, but not when
+exiting Vim, there is a slightly more complicated way.  You can see a list of
+files by typing the command: >
+
+	:oldfiles
+<	1: ~/.viminfo ~
+	2: ~/text/resume.txt ~
+	3: /tmp/draft ~
+
+Now you would like to edit the second file, which is in the list preceded by
+"2:".  You type: >
+
+	:e #<2
+
+Instead of ":e" you can use any command that has a file name argument, the
+"#<2" item works in the same place as "%" (current file name) and "#"
+(alternate file name).  So you can also split the window to edit the third
+file: >
+
+	:split #<3
+
+That #<123 thing is a bit complicated when you just want to edit a file.
+Fortunately there is a simpler way: >
+
+	:browse oldfiles
+<	1: ~/.viminfo ~
+	2: ~/text/resume.txt ~
+	3: /tmp/draft ~
+	-- More --
+
+You get the same list of files as with |:oldfiles|.  If you want to edit
+"resume.txt" first press "q" to stop the listing.  You will get a prompt:
+
+	Type number and <Enter> (empty cancels): ~
+
+Type "2" and press <Enter> to edit the second file.
+
+More info at |:oldfiles|, |v:oldfiles| and |c_#<|.
+
+
 MOVE INFO FROM ONE VIM TO ANOTHER
 
 You can use the ":wviminfo" and ":rviminfo" commands to save and restore the
diff -Naur vim72.orig/runtime/scripts.vim vim72/runtime/scripts.vim
--- vim72.orig/runtime/scripts.vim	2008-08-08 15:27:21.000000000 -0700
+++ vim72/runtime/scripts.vim	2009-06-05 14:14:19.000000000 -0700
@@ -234,6 +234,10 @@
   elseif s:line1 =~ '\<DTD\s\+XHTML\s'
     set ft=xhtml
 
+    " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
+  elseif s:line1 =~? '\<DOCTYPE\s\+html\>'
+    set ft=html
+
     " PDF
   elseif s:line1 =~ '^%PDF-'
     set ft=pdf
diff -Naur vim72.orig/src/auto/configure vim72/src/auto/configure
--- vim72.orig/src/auto/configure	2008-07-24 05:40:36.000000000 -0700
+++ vim72/src/auto/configure	2009-06-05 14:25:31.000000000 -0700
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.62.
+# Generated by GNU Autoconf 2.63.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -635,138 +635,138 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL
-PATH_SEPARATOR
-PACKAGE_NAME
-PACKAGE_TARNAME
-PACKAGE_VERSION
-PACKAGE_STRING
-PACKAGE_BUGREPORT
-exec_prefix
-prefix
-program_transform_name
-bindir
-sbindir
-libexecdir
-datarootdir
-datadir
-sysconfdir
-sharedstatedir
-localstatedir
-includedir
-oldincludedir
-docdir
-infodir
-htmldir
-dvidir
-pdfdir
-psdir
-libdir
-localedir
-mandir
-DEFS
-ECHO_C
-ECHO_N
-ECHO_T
-LIBS
-build_alias
-host_alias
-target_alias
-SET_MAKE
-CC
-CFLAGS
-LDFLAGS
-CPPFLAGS
-ac_ct_CC
-EXEEXT
-OBJEXT
-CPP
-GREP
-EGREP
-AWK
-STRIP
-CPP_MM
-OS_EXTRA_SRC
-OS_EXTRA_OBJ
-VIMNAME
-EXNAME
-VIEWNAME
-line_break
-dovimdiff
-dogvimdiff
-compiledby
-vi_cv_path_mzscheme
-MZSCHEME_SRC
-MZSCHEME_OBJ
-MZSCHEME_PRO
-MZSCHEME_LIBS
-MZSCHEME_CFLAGS
-vi_cv_path_perl
-vi_cv_perllib
-shrpenv
-PERL_SRC
-PERL_OBJ
-PERL_PRO
-PERL_CFLAGS
-PERL_LIBS
-vi_cv_path_python
-PYTHON_CONFDIR
-PYTHON_LIBS
-PYTHON_GETPATH_CFLAGS
-PYTHON_CFLAGS
-PYTHON_SRC
-PYTHON_OBJ
-vi_cv_path_tcl
-TCL_SRC
-TCL_OBJ
-TCL_PRO
-TCL_CFLAGS
-TCL_LIBS
-vi_cv_path_ruby
-RUBY_SRC
-RUBY_OBJ
-RUBY_PRO
-RUBY_CFLAGS
-RUBY_LIBS
-WORKSHOP_SRC
-WORKSHOP_OBJ
-NETBEANS_SRC
-NETBEANS_OBJ
-SNIFF_SRC
-SNIFF_OBJ
-xmkmfpath
-XMKMF
-X_CFLAGS
-X_PRE_LIBS
-X_LIBS
-X_EXTRA_LIBS
-X_LIB
-GTK_CONFIG
-GTK12_CONFIG
-PKG_CONFIG
-GTK_CFLAGS
-GTK_LIBS
-GTK_LIBNAME
-GNOME_LIBS
-GNOME_LIBDIR
-GNOME_INCLUDEDIR
-GNOME_CONFIG
-MOTIF_LIBNAME
-NARROW_PROTO
-GUI_INC_LOC
-GUI_LIB_LOC
-GUITYPE
-GUI_X_LIBS
-HANGULIN_SRC
-HANGULIN_OBJ
-TAGPRG
-INSTALL_LANGS
-INSTALL_TOOL_LANGS
-MSGFMT
-MAKEMO
-DEPEND_CFLAGS_FILTER
+ac_subst_vars='LTLIBOBJS
 LIBOBJS
-LTLIBOBJS'
+DEPEND_CFLAGS_FILTER
+MAKEMO
+MSGFMT
+INSTALL_TOOL_LANGS
+INSTALL_LANGS
+TAGPRG
+HANGULIN_OBJ
+HANGULIN_SRC
+GUI_X_LIBS
+GUITYPE
+GUI_LIB_LOC
+GUI_INC_LOC
+NARROW_PROTO
+MOTIF_LIBNAME
+GNOME_CONFIG
+GNOME_INCLUDEDIR
+GNOME_LIBDIR
+GNOME_LIBS
+GTK_LIBNAME
+GTK_LIBS
+GTK_CFLAGS
+PKG_CONFIG
+GTK12_CONFIG
+GTK_CONFIG
+X_LIB
+X_EXTRA_LIBS
+X_LIBS
+X_PRE_LIBS
+X_CFLAGS
+XMKMF
+xmkmfpath
+SNIFF_OBJ
+SNIFF_SRC
+NETBEANS_OBJ
+NETBEANS_SRC
+WORKSHOP_OBJ
+WORKSHOP_SRC
+RUBY_LIBS
+RUBY_CFLAGS
+RUBY_PRO
+RUBY_OBJ
+RUBY_SRC
+vi_cv_path_ruby
+TCL_LIBS
+TCL_CFLAGS
+TCL_PRO
+TCL_OBJ
+TCL_SRC
+vi_cv_path_tcl
+PYTHON_OBJ
+PYTHON_SRC
+PYTHON_CFLAGS
+PYTHON_GETPATH_CFLAGS
+PYTHON_LIBS
+PYTHON_CONFDIR
+vi_cv_path_python
+PERL_LIBS
+PERL_CFLAGS
+PERL_PRO
+PERL_OBJ
+PERL_SRC
+shrpenv
+vi_cv_perllib
+vi_cv_path_perl
+MZSCHEME_CFLAGS
+MZSCHEME_LIBS
+MZSCHEME_PRO
+MZSCHEME_OBJ
+MZSCHEME_SRC
+vi_cv_path_mzscheme
+compiledby
+dogvimdiff
+dovimdiff
+line_break
+VIEWNAME
+EXNAME
+VIMNAME
+OS_EXTRA_OBJ
+OS_EXTRA_SRC
+CPP_MM
+STRIP
+AWK
+EGREP
+GREP
+CPP
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+SET_MAKE
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
@@ -1253,9 +1253,9 @@
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) { $as_echo "$as_me: error: Unrecognized options: $ac_unrecognized_opts" >&2
+    fatal) { $as_echo "$as_me: error: unrecognized options: $ac_unrecognized_opts" >&2
    { (exit 1); exit 1; }; } ;;
-    *)     $as_echo "$as_me: WARNING: Unrecognized options: $ac_unrecognized_opts" >&2 ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
 
@@ -1308,7 +1308,7 @@
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  { $as_echo "$as_me: error: Working directory cannot be determined" >&2
+  { $as_echo "$as_me: error: working directory cannot be determined" >&2
    { (exit 1); exit 1; }; }
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
   { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
@@ -1587,7 +1587,7 @@
 if $ac_init_version; then
   cat <<\_ACEOF
 configure
-generated by GNU Autoconf 2.62
+generated by GNU Autoconf 2.63
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -1601,7 +1601,7 @@
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by $as_me, which was
-generated by GNU Autoconf 2.62.  Invocation command line was
+generated by GNU Autoconf 2.63.  Invocation command line was
 
   $ $0 $@
 
@@ -1724,8 +1724,8 @@
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-$as_echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
@@ -1928,6 +1928,8 @@
   fi
 done
 if $ac_cache_corrupted; then
+  { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { $as_echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
   { { $as_echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
@@ -2084,12 +2086,8 @@
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-$as_echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
@@ -2288,12 +2286,8 @@
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-$as_echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
@@ -2303,11 +2297,13 @@
 fi
 
 
-test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 
 # Provide some information about the compiler.
 $as_echo "$as_me:$LINENO: checking for C compiler version" >&5
@@ -2437,11 +2433,13 @@
   $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { $as_echo "$as_me:$LINENO: error: C compiler cannot create executables
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: C compiler cannot create executables
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
+   { (exit 77); exit 77; }; }; }
 fi
 
 ac_exeext=$ac_cv_exeext
@@ -2469,13 +2467,15 @@
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
+	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
     fi
   fi
 fi
@@ -2518,11 +2518,13 @@
   esac
 done
 else
-  { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest$ac_cv_exeext
@@ -2576,11 +2578,13 @@
   $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
@@ -3148,11 +3152,13 @@
 if $ac_preproc_ok; then
   :
 else
-  { { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 ac_ext=c
@@ -4016,8 +4022,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -4154,7 +4161,7 @@
 $as_echo "$ac_cv_header_Carbon_Carbon_h" >&6; }
 
 fi
-if test $ac_cv_header_Carbon_Carbon_h = yes; then
+if test "x$ac_cv_header_Carbon_Carbon_h" = x""yes; then
   CARBON=yes
 fi
 
@@ -4484,7 +4491,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_selinux_is_selinux_enabled" >&5
 $as_echo "$ac_cv_lib_selinux_is_selinux_enabled" >&6; }
-if test $ac_cv_lib_selinux_is_selinux_enabled = yes; then
+if test "x$ac_cv_lib_selinux_is_selinux_enabled" = x""yes; then
   LIBS="$LIBS -lselinux"
 	   cat >>confdefs.h <<\_ACEOF
 #define HAVE_SELINUX 1
@@ -5891,7 +5898,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_socket" >&5
 $as_echo "$ac_cv_lib_socket_socket" >&6; }
-if test $ac_cv_lib_socket_socket = yes; then
+if test "x$ac_cv_lib_socket_socket" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBSOCKET 1
 _ACEOF
@@ -5966,7 +5973,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
 $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
-if test $ac_cv_lib_nsl_gethostbyname = yes; then
+if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBNSL 1
 _ACEOF
@@ -6203,8 +6210,8 @@
   have_x=disabled
 else
   case $x_includes,$x_libraries in #(
-    *\'*) { { $as_echo "$as_me:$LINENO: error: Cannot use X directory names containing '" >&5
-$as_echo "$as_me: error: Cannot use X directory names containing '" >&2;}
+    *\'*) { { $as_echo "$as_me:$LINENO: error: cannot use X directory names containing '" >&5
+$as_echo "$as_me: error: cannot use X directory names containing '" >&2;}
    { (exit 1); exit 1; }; };; #(
     *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then
   $as_echo_n "(cached) " >&6
@@ -6242,7 +6249,7 @@
 	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
     esac
     case $ac_im_usrlibdir in
-	/usr/lib | /lib) ;;
+	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
 	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
     esac
   fi
@@ -6682,7 +6689,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_dnet_ntoa" >&5
 $as_echo "$ac_cv_lib_dnet_dnet_ntoa" >&6; }
-if test $ac_cv_lib_dnet_dnet_ntoa = yes; then
+if test "x$ac_cv_lib_dnet_dnet_ntoa" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
 fi
 
@@ -6752,7 +6759,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_stub_dnet_ntoa" >&5
 $as_echo "$ac_cv_lib_dnet_stub_dnet_ntoa" >&6; }
-if test $ac_cv_lib_dnet_stub_dnet_ntoa = yes; then
+if test "x$ac_cv_lib_dnet_stub_dnet_ntoa" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
 fi
 
@@ -6924,7 +6931,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
 $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
-if test $ac_cv_lib_nsl_gethostbyname = yes; then
+if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
 fi
 
@@ -6994,7 +7001,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_bsd_gethostbyname" >&5
 $as_echo "$ac_cv_lib_bsd_gethostbyname" >&6; }
-if test $ac_cv_lib_bsd_gethostbyname = yes; then
+if test "x$ac_cv_lib_bsd_gethostbyname" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lbsd"
 fi
 
@@ -7160,7 +7167,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_connect" >&5
 $as_echo "$ac_cv_lib_socket_connect" >&6; }
-if test $ac_cv_lib_socket_connect = yes; then
+if test "x$ac_cv_lib_socket_connect" = x""yes; then
   X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
 fi
 
@@ -7319,7 +7326,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix_remove" >&5
 $as_echo "$ac_cv_lib_posix_remove" >&6; }
-if test $ac_cv_lib_posix_remove = yes; then
+if test "x$ac_cv_lib_posix_remove" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
 fi
 
@@ -7478,7 +7485,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ipc_shmat" >&5
 $as_echo "$ac_cv_lib_ipc_shmat" >&6; }
-if test $ac_cv_lib_ipc_shmat = yes; then
+if test "x$ac_cv_lib_ipc_shmat" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
 fi
 
@@ -7559,7 +7566,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceConnectionNumber" >&5
 $as_echo "$ac_cv_lib_ICE_IceConnectionNumber" >&6; }
-if test $ac_cv_lib_ICE_IceConnectionNumber = yes; then
+if test "x$ac_cv_lib_ICE_IceConnectionNumber" = x""yes; then
   X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
 fi
 
@@ -7727,7 +7734,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&5
 $as_echo "$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&6; }
-if test $ac_cv_lib_Xdmcp__XdmcpAuthDoIt = yes; then
+if test "x$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"
 fi
 
@@ -7797,7 +7804,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceOpenConnection" >&5
 $as_echo "$ac_cv_lib_ICE_IceOpenConnection" >&6; }
-if test $ac_cv_lib_ICE_IceOpenConnection = yes; then
+if test "x$ac_cv_lib_ICE_IceOpenConnection" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"
 fi
 
@@ -7868,7 +7875,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&5
 $as_echo "$ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&6; }
-if test $ac_cv_lib_Xpm_XpmCreatePixmapFromData = yes; then
+if test "x$ac_cv_lib_Xpm_XpmCreatePixmapFromData" = x""yes; then
   X_PRE_LIBS="$X_PRE_LIBS -lXpm"
 fi
 
@@ -7970,6 +7977,82 @@
 
     LDFLAGS="$ac_save_LDFLAGS"
 
+    { $as_echo "$as_me:$LINENO: checking size of wchar_t is 2 bytes" >&5
+$as_echo_n "checking size of wchar_t is 2 bytes... " >&6; }
+    if test "${ac_cv_small_wchar_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then
+  { { $as_echo "$as_me:$LINENO: error: failed to compile test program" >&5
+$as_echo "$as_me: error: failed to compile test program" >&2;}
+   { (exit 1); exit 1; }; }
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <X11/Xlib.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+		main()
+		{
+		  if (sizeof(wchar_t) <= 2)
+		    exit(1);
+		  exit(0);
+		}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_small_wchar_t="no"
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_small_wchar_t="yes"
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+
+    { $as_echo "$as_me:$LINENO: result: $ac_cv_small_wchar_t" >&5
+$as_echo "$ac_cv_small_wchar_t" >&6; }
+    if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+      cat >>confdefs.h <<\_ACEOF
+#define SMALL_WCHAR_T 1
+_ACEOF
+
+    fi
+
   fi
 fi
 
@@ -9251,7 +9334,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
 $as_echo "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
-if test $ac_cv_lib_Xext_XShapeQueryExtension = yes; then
+if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = x""yes; then
   GUI_X_LIBS="-lXext"
 fi
 
@@ -9320,7 +9403,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_w_wslen" >&5
 $as_echo "$ac_cv_lib_w_wslen" >&6; }
-if test $ac_cv_lib_w_wslen = yes; then
+if test "x$ac_cv_lib_w_wslen" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"
 fi
 
@@ -9389,7 +9472,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlsym" >&5
 $as_echo "$ac_cv_lib_dl_dlsym" >&6; }
-if test $ac_cv_lib_dl_dlsym = yes; then
+if test "x$ac_cv_lib_dl_dlsym" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"
 fi
 
@@ -9458,7 +9541,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&5
 $as_echo "$ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&6; }
-if test $ac_cv_lib_Xmu_XmuCreateStippledPixmap = yes; then
+if test "x$ac_cv_lib_Xmu_XmuCreateStippledPixmap" = x""yes; then
   GUI_X_LIBS="-lXmu $GUI_X_LIBS"
 fi
 
@@ -9528,7 +9611,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xp_XpEndJob" >&5
 $as_echo "$ac_cv_lib_Xp_XpEndJob" >&6; }
-if test $ac_cv_lib_Xp_XpEndJob = yes; then
+if test "x$ac_cv_lib_Xp_XpEndJob" = x""yes; then
   GUI_X_LIBS="-lXp $GUI_X_LIBS"
 fi
 
@@ -9699,8 +9782,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -9852,8 +9936,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -10098,8 +10183,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -10489,7 +10575,7 @@
 $as_echo "$ac_cv_header_elf_h" >&6; }
 
 fi
-if test $ac_cv_header_elf_h = yes; then
+if test "x$ac_cv_header_elf_h" = x""yes; then
   HAS_ELF=1
 fi
 
@@ -10555,7 +10641,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_elf_main" >&5
 $as_echo "$ac_cv_lib_elf_main" >&6; }
-if test $ac_cv_lib_elf_main = yes; then
+if test "x$ac_cv_lib_elf_main" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBELF 1
 _ACEOF
@@ -10629,8 +10715,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
 _ACEOF
@@ -10916,7 +11003,6 @@
 
 
 
-
 for ac_header in stdarg.h stdlib.h string.h sys/select.h sys/utsname.h \
 	termcap.h fcntl.h sgtty.h sys/ioctl.h sys/time.h sys/types.h termio.h \
 	iconv.h langinfo.h math.h unistd.h stropts.h errno.h \
@@ -10924,7 +11010,7 @@
 	sys/stream.h termios.h libc.h sys/statfs.h \
 	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
 	libgen.h util/debug.h util/msg18n.h frame.h \
-	sys/acl.h sys/access.h sys/sysctl.h sys/sysinfo.h wchar.h wctype.h
+	sys/acl.h sys/access.h sys/sysinfo.h wchar.h wctype.h
 do
 as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
@@ -11058,8 +11144,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -11122,8 +11209,74 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in sys/sysctl.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined HAVE_SYS_PARAM_H
+#  include <sys/param.h>
+#endif
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval "$as_ac_Header=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Header=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -11322,8 +11475,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -11565,6 +11719,67 @@
 
 fi
 
+{ $as_echo "$as_me:$LINENO: checking for working volatile" >&5
+$as_echo_n "checking for working volatile... " >&6; }
+if test "${ac_cv_c_volatile+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+volatile int x;
+int * volatile y = (int *) 0;
+return !x && !y;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_volatile=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_c_volatile=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_volatile" >&5
+$as_echo "$ac_cv_c_volatile" >&6; }
+if test $ac_cv_c_volatile = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define volatile /**/
+_ACEOF
+
+fi
+
 { $as_echo "$as_me:$LINENO: checking for mode_t" >&5
 $as_echo_n "checking for mode_t... " >&6; }
 if test "${ac_cv_type_mode_t+set}" = set; then
@@ -11659,7 +11874,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_mode_t" >&5
 $as_echo "$ac_cv_type_mode_t" >&6; }
-if test $ac_cv_type_mode_t = yes; then
+if test "x$ac_cv_type_mode_t" = x""yes; then
   :
 else
 
@@ -11763,7 +11978,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
 $as_echo "$ac_cv_type_off_t" >&6; }
-if test $ac_cv_type_off_t = yes; then
+if test "x$ac_cv_type_off_t" = x""yes; then
   :
 else
 
@@ -11867,7 +12082,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
 $as_echo "$ac_cv_type_pid_t" >&6; }
-if test $ac_cv_type_pid_t = yes; then
+if test "x$ac_cv_type_pid_t" = x""yes; then
   :
 else
 
@@ -11971,7 +12186,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
 $as_echo "$ac_cv_type_size_t" >&6; }
-if test $ac_cv_type_size_t = yes; then
+if test "x$ac_cv_type_size_t" = x""yes; then
   :
 else
 
@@ -12175,7 +12390,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_ino_t" >&5
 $as_echo "$ac_cv_type_ino_t" >&6; }
-if test $ac_cv_type_ino_t = yes; then
+if test "x$ac_cv_type_ino_t" = x""yes; then
   :
 else
 
@@ -12279,7 +12494,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_dev_t" >&5
 $as_echo "$ac_cv_type_dev_t" >&6; }
-if test $ac_cv_type_dev_t = yes; then
+if test "x$ac_cv_type_dev_t" = x""yes; then
   :
 else
 
@@ -12569,8 +12784,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Lib'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Lib'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_LIB${libname}" | $as_tr_cpp` 1
 _ACEOF
@@ -13818,8 +14034,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -14202,7 +14419,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_m_strtod" >&5
 $as_echo "$ac_cv_lib_m_strtod" >&6; }
-if test $ac_cv_lib_m_strtod = yes; then
+if test "x$ac_cv_lib_m_strtod" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBM 1
 _ACEOF
@@ -14362,7 +14579,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix1e_acl_get_file" >&5
 $as_echo "$ac_cv_lib_posix1e_acl_get_file" >&6; }
-if test $ac_cv_lib_posix1e_acl_get_file = yes; then
+if test "x$ac_cv_lib_posix1e_acl_get_file" = x""yes; then
   LIBS="$LIBS -lposix1e"
 else
   { $as_echo "$as_me:$LINENO: checking for acl_get_file in -lacl" >&5
@@ -14430,7 +14647,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_acl_acl_get_file" >&5
 $as_echo "$ac_cv_lib_acl_acl_get_file" >&6; }
-if test $ac_cv_lib_acl_acl_get_file = yes; then
+if test "x$ac_cv_lib_acl_acl_get_file" = x""yes; then
   LIBS="$LIBS -lacl"
 		  { $as_echo "$as_me:$LINENO: checking for fgetxattr in -lattr" >&5
 $as_echo_n "checking for fgetxattr in -lattr... " >&6; }
@@ -14497,7 +14714,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_attr_fgetxattr" >&5
 $as_echo "$ac_cv_lib_attr_fgetxattr" >&6; }
-if test $ac_cv_lib_attr_fgetxattr = yes; then
+if test "x$ac_cv_lib_attr_fgetxattr" = x""yes; then
   LIBS="$LIBS -lattr"
 fi
 
@@ -15226,7 +15443,6 @@
 
 
 
-
 bcopy_test_prog='
 #include "confdefs.h"
 #ifdef HAVE_STRING_H
@@ -15458,7 +15674,7 @@
 if test "$enable_multibyte" = "yes"; then
   cflags_save=$CFLAGS
   ldflags_save=$LDFLAGS
-  if test -n "$x_includes" ; then
+  if test "x$x_includes" != "xNONE" ; then
     CFLAGS="$CFLAGS -I$x_includes"
     LDFLAGS="$X_LIBS $LDFLAGS -lX11"
     { $as_echo "$as_me:$LINENO: checking whether X_LOCALE needed" >&5
@@ -15635,7 +15851,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_xpg4__xpg4_setrunelocale" >&5
 $as_echo "$ac_cv_lib_xpg4__xpg4_setrunelocale" >&6; }
-if test $ac_cv_lib_xpg4__xpg4_setrunelocale = yes; then
+if test "x$ac_cv_lib_xpg4__xpg4_setrunelocale" = x""yes; then
   LIBS="$LIBS -lxpg4"
 fi
 
@@ -15646,6 +15862,7 @@
 if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
   TAGPRG="ctags -I INIT+ --fields=+S"
 else
+  TAGPRG="ctags"
   (eval etags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags"
   (eval etags -c   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags -c"
   (eval ctags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags"
@@ -15933,8 +16150,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -16134,7 +16352,7 @@
 $as_echo "$ac_cv_header_dlfcn_h" >&6; }
 
 fi
-if test $ac_cv_header_dlfcn_h = yes; then
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then
   DLL=dlfcn.h
 else
   if test "${ac_cv_header_dl_h+set}" = set; then
@@ -16264,7 +16482,7 @@
 $as_echo "$ac_cv_header_dl_h" >&6; }
 
 fi
-if test $ac_cv_header_dl_h = yes; then
+if test "x$ac_cv_header_dl_h" = x""yes; then
   DLL=dl.h
 fi
 
@@ -16783,8 +17001,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -16819,21 +17038,29 @@
   LDFLAGS="$LDFLAGS -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
 fi
 
-{ $as_echo "$as_me:$LINENO: checking for GCC 3 or later" >&5
-$as_echo_n "checking for GCC 3 or later... " >&6; }
 DEPEND_CFLAGS_FILTER=
 if test "$GCC" = yes; then
+  { $as_echo "$as_me:$LINENO: checking for GCC 3 or later" >&5
+$as_echo_n "checking for GCC 3 or later... " >&6; }
   gccmajor=`echo "$gccversion" | sed -e 's/^\([1-9]\)\..*$/\1/g'`
   if test "$gccmajor" -gt "2"; then
     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
-  fi
-fi
-if test "$DEPEND_CFLAGS_FILTER" = ""; then
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+    { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:$LINENO: result: no" >&5
 $as_echo "no" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
+  fi
+      { $as_echo "$as_me:$LINENO: checking whether we need -D_FORTIFY_SOURCE=1" >&5
+$as_echo_n "checking whether we need -D_FORTIFY_SOURCE=1... " >&6; }
+  if test "$gccmajor" -gt "3"; then
+    CFLAGS="$CFLAGS -D_FORTIFY_SOURCE=1"
+    { $as_echo "$as_me:$LINENO: result: yes" >&5
 $as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+  fi
 fi
 
 
@@ -16866,8 +17093,8 @@
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-$as_echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
@@ -17259,7 +17486,7 @@
 # values after options handling.
 ac_log="
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.62.  Invocation command line was
+generated by GNU Autoconf 2.63.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -17272,6 +17499,15 @@
 
 _ACEOF
 
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 # Files that config.status was made for.
 config_files="$ac_config_files"
@@ -17284,16 +17520,17 @@
 \`$as_me' instantiates files from templates according to the
 current configuration.
 
-Usage: $0 [OPTIONS] [FILE]...
+Usage: $0 [OPTION]... [FILE]...
 
   -h, --help       print this help, then exit
   -V, --version    print version number and configuration settings, then exit
-  -q, --quiet      do not print progress messages
+  -q, --quiet, --silent
+                   do not print progress messages
   -d, --debug      don't remove temporary files
       --recheck    update $as_me by reconfiguring in the same conditions
-  --file=FILE[:TEMPLATE]
+      --file=FILE[:TEMPLATE]
                    instantiate the configuration file FILE
-  --header=FILE[:TEMPLATE]
+      --header=FILE[:TEMPLATE]
                    instantiate the configuration header FILE
 
 Configuration files:
@@ -17308,7 +17545,7 @@
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.62,
+configured by $0, generated by GNU Autoconf 2.63,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2008 Free Software Foundation, Inc.
@@ -17505,7 +17742,8 @@
 $as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
    { (exit 1); exit 1; }; }
 
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X` = $ac_delim_num; then
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
     { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
@@ -17710,9 +17948,9 @@
   }
   split(mac1, mac2, "(") #)
   macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
   if (D_is_set[macro]) {
     # Preserve the white space surrounding the "#".
-    prefix = substr(line, 1, index(line, defundef) - 1)
     print prefix "define", macro P[macro] D[macro]
     next
   } else {
@@ -17720,7 +17958,7 @@
     # in the case of _POSIX_SOURCE, which is predefined and required
     # on some systems where configure will not decide to define it.
     if (defundef == "undef") {
-      print "/*", line, "*/"
+      print "/*", prefix defundef, macro, "*/"
       next
     }
   }
@@ -17744,8 +17982,8 @@
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
-$as_echo "$as_me: error: Invalid tag $ac_tag." >&2;}
+  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: invalid tag $ac_tag" >&5
+$as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
    { (exit 1); exit 1; }; };;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
@@ -18063,8 +18301,8 @@
   $ac_cs_success || { (exit 1); exit 1; }
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:$LINENO: WARNING: Unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: Unrecognized options: $ac_unrecognized_opts" >&2;}
+  { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
 
 
diff -Naur vim72.orig/src/buffer.c vim72/src/buffer.c
--- vim72.orig/src/buffer.c	2008-08-06 04:00:48.000000000 -0700
+++ vim72/src/buffer.c	2009-06-05 14:25:15.000000000 -0700
@@ -44,6 +44,7 @@
 #ifdef FEAT_TITLE
 static int	ti_change __ARGS((char_u *str, char_u **last));
 #endif
+static int	append_arg_number __ARGS((win_T *wp, char_u *buf, int buflen, int add_file));
 static void	free_buffer __ARGS((buf_T *));
 static void	free_buffer_stuff __ARGS((buf_T *buf, int free_options));
 static void	clear_wininfo __ARGS((buf_T *buf));
@@ -437,10 +438,6 @@
 	return;
 #endif
 
-#ifdef FEAT_NETBEANS_INTG
-    if (usingNetbeans)
-	netbeans_file_closed(buf);
-#endif
     /* Change directories when the 'acd' option is set. */
     DO_AUTOCHDIR
 
@@ -639,6 +636,10 @@
 #ifdef FEAT_SIGNS
     buf_delete_signs(buf);		/* delete any signs */
 #endif
+#ifdef FEAT_NETBEANS_INTG
+    if (usingNetbeans)
+        netbeans_file_killed(buf);
+#endif
 #ifdef FEAT_LOCALMAP
     map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);  /* clear local mappings */
     map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);   /* clear local abbrevs */
@@ -647,6 +648,9 @@
     vim_free(buf->b_start_fenc);
     buf->b_start_fenc = NULL;
 #endif
+#ifdef FEAT_SPELL
+    ga_clear(&buf->b_langp);
+#endif
 }
 
 /*
@@ -812,9 +816,6 @@
     int		bnr;		/* buffer number */
     char_u	*p;
 
-#ifdef FEAT_NETBEANS_INTG
-    netbeansCloseFile = 1;
-#endif
     if (addr_count == 0)
     {
 	(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);
@@ -909,9 +910,6 @@
 	}
     }
 
-#ifdef FEAT_NETBEANS_INTG
-    netbeansCloseFile = 0;
-#endif
 
     return errormsg;
 }
@@ -1237,7 +1235,7 @@
 	 * "buf" if one exists */
 	if ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))
 	    return OK;
-	/* If 'switchbuf' contians "usetab": jump to first window in any tab
+	/* If 'switchbuf' contains "usetab": jump to first window in any tab
 	 * page containing "buf" if one exists */
 	if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))
 	    return OK;
@@ -1351,11 +1349,12 @@
 	}
     }
 #ifdef FEAT_AUTOCMD
+    /* An autocommand may have deleted "buf", already entered it (e.g., when
+     * it did ":bunload") or aborted the script processing! */
 # ifdef FEAT_EVAL
-    /* An autocommand may have deleted buf or aborted the script processing! */
-    if (buf_valid(buf) && !aborting())
+    if (buf_valid(buf) && buf != curbuf && !aborting())
 # else
-    if (buf_valid(buf))	    /* an autocommand may have deleted buf! */
+    if (buf_valid(buf) && buf != curbuf)
 # endif
 #endif
 	enter_buffer(buf);
@@ -1397,6 +1396,9 @@
     curwin->w_cursor.coladd = 0;
 #endif
     curwin->w_set_curswant = TRUE;
+#ifdef FEAT_AUTOCMD
+    curwin->w_topline_was_set = FALSE;
+#endif
 
     /* Make sure the buffer is loaded. */
     if (curbuf->b_ml.ml_mfp == NULL)	/* need to load the file */
@@ -1436,7 +1438,8 @@
     maketitle();
 #endif
 #ifdef FEAT_AUTOCMD
-    if (curwin->w_topline == 1)		/* when autocmds didn't change it */
+	/* when autocmds didn't change it */
+    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)
 #endif
 	scroll_cursor_halfway(FALSE);	/* redisplay at correct position */
 
@@ -1451,13 +1454,13 @@
 
 #ifdef FEAT_KEYMAP
     if (curbuf->b_kmap_state & KEYMAP_INIT)
-	keymap_init();
+	(void)keymap_init();
 #endif
 #ifdef FEAT_SPELL
     /* May need to set the spell language.  Can only do this after the buffer
      * has been properly setup. */
     if (!curbuf->b_help && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
-	did_set_spelllang(curbuf);
+	(void)did_set_spelllang(curbuf);
 #endif
 
     redraw_later(NOT_VALID);
@@ -1675,9 +1678,10 @@
     buf->b_fname = buf->b_sfname;
 #ifdef UNIX
     if (st.st_dev == (dev_T)-1)
-	buf->b_dev = -1;
+	buf->b_dev_valid = FALSE;
     else
     {
+	buf->b_dev_valid = TRUE;
 	buf->b_dev = st.st_dev;
 	buf->b_ino = st.st_ino;
     }
@@ -2022,13 +2026,12 @@
  * Return fnum of the found buffer.
  * Return < 0 for error.
  */
-/*ARGSUSED*/
     int
 buflist_findpat(pattern, pattern_end, unlisted, diffmode)
     char_u	*pattern;
     char_u	*pattern_end;	/* pointer to first char after pattern */
     int		unlisted;	/* find unlisted buffers */
-    int		diffmode;	/* find diff-mode buffers only */
+    int		diffmode UNUSED; /* find diff-mode buffers only */
 {
     buf_T	*buf;
     regprog_T	*prog;
@@ -2466,7 +2469,7 @@
     buf_T	*buf;
 {
     wininfo_T	*wip;
-    static pos_T no_position = {1, 0};
+    static pos_T no_position = INIT_POS_T(1, 0, 0);
 
     wip = find_wininfo(buf);
     if (wip != NULL)
@@ -2489,7 +2492,6 @@
 /*
  * List all know file names (for :files and :buffers command).
  */
-/*ARGSUSED*/
     void
 buflist_list(eap)
     exarg_T	*eap;
@@ -2527,8 +2529,8 @@
 	{
 	    IObuff[len++] = ' ';
 	} while (--i > 0 && len < IOSIZE - 18);
-	vim_snprintf((char *)IObuff + len, IOSIZE - len, _("line %ld"),
-		buf == curbuf ? curwin->w_cursor.lnum
+	vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),
+		_("line %ld"), buf == curbuf ? curwin->w_cursor.lnum
 					       : (long)buflist_findlnum(buf));
 	msg_outtrans(IObuff);
 	out_flush();	    /* output one line at a time */
@@ -2642,9 +2644,10 @@
     buf->b_fname = buf->b_sfname;
 #ifdef UNIX
     if (st.st_dev == (dev_T)-1)
-	buf->b_dev = -1;
+	buf->b_dev_valid = FALSE;
     else
     {
+	buf->b_dev_valid = TRUE;
 	buf->b_dev = st.st_dev;
 	buf->b_ino = st.st_ino;
     }
@@ -2838,7 +2841,7 @@
 	/* If no struct stat given, get it now */
 	if (stp == NULL)
 	{
-	    if (buf->b_dev < 0 || mch_stat((char *)ffname, &st) < 0)
+	    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)
 		st.st_dev = (dev_T)-1;
 	    stp = &st;
 	}
@@ -2875,11 +2878,12 @@
 
     if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)
     {
+	buf->b_dev_valid = TRUE;
 	buf->b_dev = st.st_dev;
 	buf->b_ino = st.st_ino;
     }
     else
-	buf->b_dev = -1;
+	buf->b_dev_valid = FALSE;
 }
 
 /*
@@ -2890,7 +2894,7 @@
     buf_T	*buf;
     struct stat *stp;
 {
-    return (buf->b_dev >= 0
+    return (buf->b_dev_valid
 	    && stp->st_dev == buf->b_dev
 	    && stp->st_ino == buf->b_ino);
 }
@@ -2917,7 +2921,7 @@
 
     if (fullname > 1)	    /* 2 CTRL-G: include buffer number */
     {
-	sprintf((char *)buffer, "buf %d: ", curbuf->b_fnum);
+	vim_snprintf((char *)buffer, IOSIZE, "buf %d: ", curbuf->b_fnum);
 	p = buffer + STRLEN(buffer);
     }
     else
@@ -2991,11 +2995,12 @@
 		(long)curbuf->b_ml.ml_line_count,
 		n);
 	validate_virtcol();
-	col_print(buffer + STRLEN(buffer),
+	len = STRLEN(buffer);
+	col_print(buffer + len, IOSIZE - len,
 		   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);
     }
 
-    (void)append_arg_number(curwin, buffer, !shortmess(SHM_FILE), IOSIZE);
+    (void)append_arg_number(curwin, buffer, IOSIZE, !shortmess(SHM_FILE));
 
     if (dont_truncate)
     {
@@ -3023,15 +3028,16 @@
 }
 
     void
-col_print(buf, col, vcol)
+col_print(buf, buflen, col, vcol)
     char_u  *buf;
+    size_t  buflen;
     int	    col;
     int	    vcol;
 {
     if (col == vcol)
-	sprintf((char *)buf, "%d", col);
+	vim_snprintf((char *)buf, buflen, "%d", col);
     else
-	sprintf((char *)buf, "%d-%d", col, vcol);
+	vim_snprintf((char *)buf, buflen, "%d-%d", col, vcol);
 }
 
 #if defined(FEAT_TITLE) || defined(PROTO)
@@ -3144,18 +3150,18 @@
 		if (p == buf + off)
 		    /* must be a help buffer */
 		    vim_strncpy(buf + off, (char_u *)_("help"),
-							    IOSIZE - off - 1);
+						  (size_t)(IOSIZE - off - 1));
 		else
 		    *p = NUL;
 
 		/* translate unprintable chars */
 		p = transstr(buf + off);
-		vim_strncpy(buf + off, p, IOSIZE - off - 1);
+		vim_strncpy(buf + off, p, (size_t)(IOSIZE - off - 1));
 		vim_free(p);
 		STRCAT(buf, ")");
 	    }
 
-	    append_arg_number(curwin, buf, FALSE, IOSIZE);
+	    append_arg_number(curwin, buf, IOSIZE, FALSE);
 
 #if defined(FEAT_CLIENTSERVER)
 	    if (serverName != NULL)
@@ -3292,14 +3298,13 @@
  * If maxwidth is not zero, the string will be filled at any middle marker
  * or truncated if too long, fillchar is used for all whitespace.
  */
-/*ARGSUSED*/
     int
 build_stl_str_hl(wp, out, outlen, fmt, use_sandbox, fillchar, maxwidth, hltab, tabtab)
     win_T	*wp;
     char_u	*out;		/* buffer to write into != NameBuff */
     size_t	outlen;		/* length of out[] */
     char_u	*fmt;
-    int		use_sandbox;	/* "fmt" was set insecurely, use sandbox */
+    int		use_sandbox UNUSED; /* "fmt" was set insecurely, use sandbox */
     int		fillchar;
     int		maxwidth;
     struct stl_hlrec *hltab;	/* return: HL attributes (can be NULL) */
@@ -3470,7 +3475,7 @@
 		    n = (long)(p - t) - item[groupitem[groupdepth]].maxwid + 1;
 
 		*t = '<';
-		mch_memmove(t + 1, t + n, p - (t + n));
+		mch_memmove(t + 1, t + n, (size_t)(p - (t + n)));
 		p = p - n + 1;
 #ifdef FEAT_MBYTE
 		/* Fill up space left over by half a double-wide char. */
@@ -3500,7 +3505,7 @@
 		else
 		{
 		    /* fill by inserting characters */
-		    mch_memmove(t + n - l, t, p - t);
+		    mch_memmove(t + n - l, t, (size_t)(p - t));
 		    l = n - l;
 		    if (p + l >= out + outlen)
 			l = (long)((out + outlen) - p - 1);
@@ -3636,7 +3641,7 @@
 	    p = t;
 
 #ifdef FEAT_EVAL
-	    sprintf((char *)tmp, "%d", curbuf->b_fnum);
+	    vim_snprintf((char *)tmp, sizeof(tmp), "%d", curbuf->b_fnum);
 	    set_internal_string_var((char_u *)"actual_curbuf", tmp);
 
 	    o_curbuf = curbuf;
@@ -3703,13 +3708,13 @@
 
 	case STL_ALTPERCENT:
 	    str = tmp;
-	    get_rel_pos(wp, str);
+	    get_rel_pos(wp, str, TMPLEN);
 	    break;
 
 	case STL_ARGLISTSTAT:
 	    fillable = FALSE;
 	    tmp[0] = 0;
-	    if (append_arg_number(wp, tmp, FALSE, (int)sizeof(tmp)))
+	    if (append_arg_number(wp, tmp, (int)sizeof(tmp), FALSE))
 		str = tmp;
 	    break;
 
@@ -3744,7 +3749,7 @@
 	case STL_BYTEVAL_X:
 	    base = 'X';
 	case STL_BYTEVAL:
-	    if (wp->w_cursor.col > STRLEN(linecont))
+	    if (wp->w_cursor.col > (colnr_T)STRLEN(linecont))
 		num = 0;
 	    else
 	    {
@@ -3917,7 +3922,7 @@
 	    if (zeropad)
 		*t++ = '0';
 	    *t++ = '*';
-	    *t++ = nbase == 16 ? base : (nbase == 8 ? 'o' : 'd');
+	    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');
 	    *t = 0;
 
 	    for (n = num, l = 1; n >= nbase; n /= nbase)
@@ -3963,7 +3968,7 @@
     width = vim_strsize(out);
     if (maxwidth > 0 && width > maxwidth)
     {
-	/* Result is too long, must trunctate somewhere. */
+	/* Result is too long, must truncate somewhere. */
 	l = 0;
 	if (itemcnt == 0)
 	    s = out;
@@ -4110,13 +4115,14 @@
 #if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \
 	    || defined(FEAT_GUI_TABLINE) || defined(PROTO)
 /*
- * Get relative cursor position in window into "str[]", in the form 99%, using
- * "Top", "Bot" or "All" when appropriate.
+ * Get relative cursor position in window into "buf[buflen]", in the form 99%,
+ * using "Top", "Bot" or "All" when appropriate.
  */
     void
-get_rel_pos(wp, str)
+get_rel_pos(wp, buf, buflen)
     win_T	*wp;
-    char_u	*str;
+    char_u	*buf;
+    int		buflen;
 {
     long	above; /* number of lines above window */
     long	below; /* number of lines below window */
@@ -4127,34 +4133,35 @@
 #endif
     below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;
     if (below <= 0)
-	STRCPY(str, above == 0 ? _("All") : _("Bot"));
+	vim_strncpy(buf, (char_u *)(above == 0 ? _("All") : _("Bot")),
+							(size_t)(buflen - 1));
     else if (above <= 0)
-	STRCPY(str, _("Top"));
+	vim_strncpy(buf, (char_u *)_("Top"), (size_t)(buflen - 1));
     else
-	sprintf((char *)str, "%2d%%", above > 1000000L
+	vim_snprintf((char *)buf, (size_t)buflen, "%2d%%", above > 1000000L
 				    ? (int)(above / ((above + below) / 100L))
 				    : (int)(above * 100L / (above + below)));
 }
 #endif
 
 /*
- * Append (file 2 of 8) to 'buf', if editing more than one file.
+ * Append (file 2 of 8) to "buf[buflen]", if editing more than one file.
  * Return TRUE if it was appended.
  */
-    int
-append_arg_number(wp, buf, add_file, maxlen)
+    static int
+append_arg_number(wp, buf, buflen, add_file)
     win_T	*wp;
     char_u	*buf;
+    int		buflen;
     int		add_file;	/* Add "file" before the arg number */
-    int		maxlen;		/* maximum nr of chars in buf or zero*/
 {
     char_u	*p;
 
     if (ARGCOUNT <= 1)		/* nothing to do */
 	return FALSE;
 
-    p = buf + STRLEN(buf);		/* go to the end of the buffer */
-    if (maxlen && p - buf + 35 >= maxlen) /* getting too long */
+    p = buf + STRLEN(buf);	/* go to the end of the buffer */
+    if (p - buf + 35 >= buflen)	/* getting too long */
 	return FALSE;
     *p++ = ' ';
     *p++ = '(';
@@ -4163,7 +4170,8 @@
 	STRCPY(p, "file ");
 	p += 5;
     }
-    sprintf((char *)p, wp->w_arg_idx_invalid ? "(%d) of %d)"
+    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),
+		wp->w_arg_idx_invalid ? "(%d) of %d)"
 				  : "%d of %d)", wp->w_arg_idx + 1, ARGCOUNT);
     return TRUE;
 }
@@ -4946,7 +4954,7 @@
 	if (tab != NULL)
 	{
 	    *tab++ = '\0';
-	    col = atoi((char *)tab);
+	    col = (colnr_T)atoi((char *)tab);
 	    tab = vim_strrchr(xline, '\t');
 	    if (tab != NULL)
 	    {
@@ -4984,6 +4992,7 @@
 #endif
     char_u	*line;
     int		max_buffers;
+    size_t	len;
 
     if (find_viminfo_parameter('%') == NULL)
 	return;
@@ -4992,7 +5001,8 @@
     max_buffers = get_viminfo_parameter('%');
 
     /* Allocate room for the file name, lnum and col. */
-    line = alloc(MAXPATHL + 40);
+#define LINE_BUF_LEN (MAXPATHL + 40)
+    line = alloc(LINE_BUF_LEN);
     if (line == NULL)
 	return;
 
@@ -5018,7 +5028,8 @@
 	    break;
 	putc('%', fp);
 	home_replace(NULL, buf->b_ffname, line, MAXPATHL, TRUE);
-	sprintf((char *)line + STRLEN(line), "\t%ld\t%d",
+	len = STRLEN(line);
+	vim_snprintf((char *)line + len, len - LINE_BUF_LEN, "\t%ld\t%d",
 			(long)buf->b_last_cursor.lnum,
 			buf->b_last_cursor.col);
 	viminfo_writestring(fp, line);
@@ -5048,7 +5059,8 @@
 	 */
 	FOR_ALL_TAB_WINDOWS(tp, win)
 	    if (win->w_buffer == buf)
-		break;
+		goto win_found;
+win_found:
 	if (win != NULL && win->w_llist_ref != NULL)
 	    return _("[Location List]");
 	else
@@ -5062,7 +5074,7 @@
     {
 	if (buf->b_sfname != NULL)
 	    return (char *)buf->b_sfname;
-	return "[Scratch]";
+	return _("[Scratch]");
     }
 #endif
     if (buf->b_fname == NULL)
@@ -5175,7 +5187,7 @@
     return;
 }
 
-    int
+    linenr_T
 buf_change_sign_type(buf, markId, typenr)
     buf_T	*buf;		/* buffer to store sign in */
     int		markId;		/* sign ID */
@@ -5192,10 +5204,10 @@
 	}
     }
 
-    return 0;
+    return (linenr_T)0;
 }
 
-    int_u
+    int
 buf_getsigntype(buf, lnum, type)
     buf_T	*buf;
     linenr_T	lnum;
diff -Naur vim72.orig/src/charset.c vim72/src/charset.c
--- vim72.orig/src/charset.c	2008-07-24 07:59:44.000000000 -0700
+++ vim72/src/charset.c	2009-06-05 14:24:27.000000000 -0700
@@ -17,7 +17,7 @@
 static int win_nolbr_chartabsize __ARGS((win_T *wp, char_u *s, colnr_T col, int *headp));
 #endif
 
-static int nr2hex __ARGS((int c));
+static unsigned nr2hex __ARGS((unsigned c));
 
 static int    chartab_initialized = FALSE;
 
@@ -664,7 +664,7 @@
     }
 #endif
     buf[++i] = nr2hex((unsigned)c >> 4);
-    buf[++i] = nr2hex(c);
+    buf[++i] = nr2hex((unsigned)c);
     buf[++i] = '>';
     buf[++i] = NUL;
 }
@@ -674,9 +674,9 @@
  * Lower case letters are used to avoid the confusion of <F1> being 0xf1 or
  * function key 1.
  */
-    static int
+    static unsigned
 nr2hex(c)
-    int		c;
+    unsigned	c;
 {
     if ((c & 0xf) <= 9)
 	return (c & 0xf) + '0';
@@ -884,7 +884,7 @@
     if (c >= 0x100)
     {
 	if (enc_dbcs != 0)
-	    return dbcs_class((unsigned)c >> 8, c & 0xff) >= 2;
+	    return dbcs_class((unsigned)c >> 8, (unsigned)(c & 0xff)) >= 2;
 	if (enc_utf8)
 	    return utf_class(c) >= 2;
     }
@@ -1090,7 +1090,7 @@
 	 */
 	numberextra = win_col_off(wp);
 	col2 = col;
-	colmax = W_WIDTH(wp) - numberextra;
+	colmax = (colnr_T)(W_WIDTH(wp) - numberextra);
 	if (col >= colmax)
 	{
 	    n = colmax + win_col_off2(wp);
@@ -1201,17 +1201,17 @@
     win_T	*wp;
     colnr_T	vcol;
 {
-    colnr_T	width1;		/* width of first line (after line number) */
-    colnr_T	width2;		/* width of further lines */
+    int		width1;		/* width of first line (after line number) */
+    int		width2;		/* width of further lines */
 
 #ifdef FEAT_VERTSPLIT
     if (wp->w_width == 0)	/* there is no border */
 	return FALSE;
 #endif
     width1 = W_WIDTH(wp) - win_col_off(wp);
-    if (vcol < width1 - 1)
+    if ((int)vcol < width1 - 1)
 	return FALSE;
-    if (vcol == width1 - 1)
+    if ((int)vcol == width1 - 1)
 	return TRUE;
     width2 = width1 + win_col_off2(wp);
     return ((vcol - width1) % width2 == width2 - 1);
@@ -1396,13 +1396,13 @@
 # ifdef FEAT_MBYTE
 	/* Cannot put the cursor on part of a wide character. */
 	ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
-	if (pos->col < STRLEN(ptr))
+	if (pos->col < (colnr_T)STRLEN(ptr))
 	{
 	    int c = (*mb_ptr2char)(ptr + pos->col);
 
 	    if (c != TAB && vim_isprintc(c))
 	    {
-		endadd = char2cells(c) - 1;
+		endadd = (colnr_T)(char2cells(c) - 1);
 		if (coladd > endadd)	/* past end of line */
 		    endadd = 0;
 		else
diff -Naur vim72.orig/src/config.h.in vim72/src/config.h.in
--- vim72.orig/src/config.h.in	2008-06-21 08:01:41.000000000 -0700
+++ vim72/src/config.h.in	2009-06-05 14:25:31.000000000 -0700
@@ -36,6 +36,9 @@
 /* Defined to the size of an int */
 #undef SIZEOF_INT
 
+/* Define when wchar_t is only 2 bytes. */
+#undef SMALL_WCHAR_T
+
 /*
  * If we cannot trust one of the following from the libraries, we use our
  * own safe but probably slower vim_memmove().
@@ -50,6 +53,9 @@
 /* Define to empty if the keyword does not work.  */
 #undef const
 
+/* Define to empty if the keyword does not work.  */
+#undef volatile
+
 /* Define to `int' if <sys/types.h> doesn't define.  */
 #undef mode_t
 
diff -Naur vim72.orig/src/configure.in vim72/src/configure.in
--- vim72.orig/src/configure.in	2008-07-24 05:40:26.000000000 -0700
+++ vim72/src/configure.in	2009-06-05 14:25:31.000000000 -0700
@@ -1193,6 +1193,28 @@
 
     LDFLAGS="$ac_save_LDFLAGS"
 
+    AC_MSG_CHECKING(size of wchar_t is 2 bytes)
+    AC_CACHE_VAL(ac_cv_small_wchar_t,
+	[AC_TRY_RUN([
+#include <X11/Xlib.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+		main()
+		{
+		  if (sizeof(wchar_t) <= 2)
+		    exit(1);
+		  exit(0);
+		}],
+		ac_cv_small_wchar_t="no",
+		ac_cv_small_wchar_t="yes",
+		AC_MSG_ERROR(failed to compile test program))])
+    AC_MSG_RESULT($ac_cv_small_wchar_t)
+    if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+      AC_DEFINE(SMALL_WCHAR_T)
+    fi
+
   fi
 fi
 
@@ -2095,7 +2117,7 @@
 	sys/stream.h termios.h libc.h sys/statfs.h \
 	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
 	libgen.h util/debug.h util/msg18n.h frame.h \
-	sys/acl.h sys/access.h sys/sysctl.h sys/sysinfo.h wchar.h wctype.h)
+	sys/acl.h sys/access.h sys/sysinfo.h wchar.h wctype.h)
 
 dnl sys/ptem.h depends on sys/stream.h on Solaris
 AC_CHECK_HEADERS(sys/ptem.h, [], [],
@@ -2103,6 +2125,12 @@
 #  include <sys/stream.h>
 #endif])
 
+dnl sys/sysctl.h depends on sys/param.h on OpenBSD
+AC_CHECK_HEADERS(sys/sysctl.h, [], [],
+[#if defined HAVE_SYS_PARAM_H
+#  include <sys/param.h>
+#endif])
+
 
 dnl pthread_np.h may exist but can only be used after including pthread.h
 AC_MSG_CHECKING([for pthread_np.h])
@@ -2148,6 +2176,7 @@
 dnl Checks for typedefs, structures, and compiler characteristics.
 AC_PROG_GCC_TRADITIONAL
 AC_C_CONST
+AC_C_VOLATILE
 AC_TYPE_MODE_T
 AC_TYPE_OFF_T
 AC_TYPE_PID_T
@@ -2869,7 +2898,6 @@
 AC_MSG_RESULT($ac_cv_sizeof_int)
 AC_DEFINE_UNQUOTED(SIZEOF_INT, $ac_cv_sizeof_int)
 
-
 dnl Check for memmove() before bcopy(), makes memmove() be used when both are
 dnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.
 
@@ -2951,7 +2979,7 @@
 if test "$enable_multibyte" = "yes"; then
   cflags_save=$CFLAGS
   ldflags_save=$LDFLAGS
-  if test -n "$x_includes" ; then
+  if test "x$x_includes" != "xNONE" ; then
     CFLAGS="$CFLAGS -I$x_includes"
     LDFLAGS="$X_LIBS $LDFLAGS -lX11"
     AC_MSG_CHECKING(whether X_LOCALE needed)
@@ -2967,7 +2995,7 @@
 dnl Link with xpg4, it is said to make Korean locale working
 AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
 
-dnl Check how we can run ctags
+dnl Check how we can run ctags.  Default to "ctags" when nothing works.
 dnl --version for Exuberant ctags (preferred)
 dnl       Add --fields=+S to get function signatures for omni completion.
 dnl -t for typedefs (many ctags have this)
@@ -2979,6 +3007,7 @@
 if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
   TAGPRG="ctags -I INIT+ --fields=+S"
 else
+  TAGPRG="ctags"
   (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
   (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags -c"
   (eval ctags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags"
@@ -3152,18 +3181,25 @@
 dnl But only when making dependencies, cproto and lint don't take "-isystem".
 dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
 dnl the number before the version number.
-AC_MSG_CHECKING(for GCC 3 or later)
 DEPEND_CFLAGS_FILTER=
 if test "$GCC" = yes; then
+  AC_MSG_CHECKING(for GCC 3 or later)
   gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
   if test "$gccmajor" -gt "2"; then
     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no)
+  fi
+  dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, "000") when buf is
+  dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
+  AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
+  if test "$gccmajor" -gt "3"; then
+    CFLAGS="$CFLAGS -D_FORTIFY_SOURCE=1"
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no)
   fi
-fi
-if test "$DEPEND_CFLAGS_FILTER" = ""; then
-  AC_MSG_RESULT(no)
-else
-  AC_MSG_RESULT(yes)
 fi
 AC_SUBST(DEPEND_CFLAGS_FILTER)
 
diff -Naur vim72.orig/src/diff.c vim72/src/diff.c
--- vim72.orig/src/diff.c	2008-03-05 03:16:56.000000000 -0800
+++ vim72/src/diff.c	2009-06-05 14:24:34.000000000 -0700
@@ -8,7 +8,7 @@
  */
 
 /*
- * diff.c: code for diff'ing two or three buffers.
+ * diff.c: code for diff'ing two, three or four buffers.
  */
 
 #include "vim.h"
@@ -73,6 +73,8 @@
 	{
 	    tp->tp_diffbuf[i] = NULL;
 	    tp->tp_diff_invalid = TRUE;
+	    if (tp == curtab)
+		diff_redraw(TRUE);
 	}
     }
 }
@@ -102,6 +104,7 @@
 	    {
 		curtab->tp_diffbuf[i] = NULL;
 		curtab->tp_diff_invalid = TRUE;
+		diff_redraw(TRUE);
 	    }
 	}
     }
@@ -113,7 +116,7 @@
  * Add a buffer to make diffs for.
  * Call this when a new buffer is being edited in the current window where
  * 'diff' is set.
- * Marks the current buffer as being part of the diff and requireing updating.
+ * Marks the current buffer as being part of the diff and requiring updating.
  * This must be done before any autocmd, because a command may use info
  * about the screen contents.
  */
@@ -131,6 +134,7 @@
 	{
 	    curtab->tp_diffbuf[i] = buf;
 	    curtab->tp_diff_invalid = TRUE;
+	    diff_redraw(TRUE);
 	    return;
 	}
 
@@ -661,6 +665,7 @@
     char_u	*tmp_diff;
     FILE	*fd;
     int		ok;
+    int		io_error = FALSE;
 
     /* Delete all diffblocks. */
     diff_clear(curtab);
@@ -697,18 +702,26 @@
     {
 	ok = FALSE;
 	fd = mch_fopen((char *)tmp_orig, "w");
-	if (fd != NULL)
+	if (fd == NULL)
+	    io_error = TRUE;
+	else
 	{
-	    fwrite("line1\n", (size_t)6, (size_t)1, fd);
+	    if (fwrite("line1\n", (size_t)6, (size_t)1, fd) != 1)
+		io_error = TRUE;
 	    fclose(fd);
 	    fd = mch_fopen((char *)tmp_new, "w");
-	    if (fd != NULL)
+	    if (fd == NULL)
+		io_error = TRUE;
+	    else
 	    {
-		fwrite("line2\n", (size_t)6, (size_t)1, fd);
+		if (fwrite("line2\n", (size_t)6, (size_t)1, fd) != 1)
+		    io_error = TRUE;
 		fclose(fd);
 		diff_file(tmp_orig, tmp_new, tmp_diff);
 		fd = mch_fopen((char *)tmp_diff, "r");
-		if (fd != NULL)
+		if (fd == NULL)
+		    io_error = TRUE;
+		else
 		{
 		    char_u	linebuf[LBUFLEN];
 
@@ -761,6 +774,8 @@
     }
     if (!ok)
     {
+	if (io_error)
+	    EMSG(_("E810: Cannot read or write temp files"));
 	EMSG(_("E97: Cannot create diffs"));
 	diff_a_works = MAYBE;
 #if defined(MSWIN) || defined(MSDOS)
@@ -812,6 +827,7 @@
     char_u	*tmp_diff;
 {
     char_u	*cmd;
+    size_t	len;
 
 #ifdef FEAT_EVAL
     if (*p_dex != NUL)
@@ -820,8 +836,9 @@
     else
 #endif
     {
-	cmd = alloc((unsigned)(STRLEN(tmp_orig) + STRLEN(tmp_new)
-				+ STRLEN(tmp_diff) + STRLEN(p_srr) + 27));
+	len = STRLEN(tmp_orig) + STRLEN(tmp_new)
+				      + STRLEN(tmp_diff) + STRLEN(p_srr) + 27;
+	cmd = alloc((unsigned)len);
 	if (cmd != NULL)
 	{
 	    /* We don't want $DIFF_OPTIONS to get in the way. */
@@ -831,7 +848,7 @@
 	    /* Build the diff command and execute it.  Always use -a, binary
 	     * differences are of no use.  Ignore errors, diff returns
 	     * non-zero when differences have been found. */
-	    sprintf((char *)cmd, "diff %s%s%s%s%s %s",
+	    vim_snprintf((char *)cmd, len, "diff %s%s%s%s%s %s",
 		    diff_a_works == FALSE ? "" : "-a ",
 #if defined(MSWIN) || defined(MSDOS)
 		    diff_bin_works == TRUE ? "--binary " : "",
@@ -841,7 +858,7 @@
 		    (diff_flags & DIFF_IWHITE) ? "-b " : "",
 		    (diff_flags & DIFF_ICASE) ? "-i " : "",
 		    tmp_orig, tmp_new);
-	    append_redir(cmd, p_srr, tmp_diff);
+	    append_redir(cmd, (int)len, p_srr, tmp_diff);
 #ifdef FEAT_AUTOCMD
 	    block_autocmds();	/* Avoid ShellCmdPost stuff */
 #endif
@@ -866,6 +883,7 @@
     char_u	*tmp_orig;	/* name of original temp file */
     char_u	*tmp_new;	/* name of patched temp file */
     char_u	*buf = NULL;
+    size_t	buflen;
     win_T	*old_curwin = curwin;
     char_u	*newname = NULL;	/* name of patched file buffer */
 #ifdef UNIX
@@ -905,16 +923,17 @@
     /* Get the absolute path of the patchfile, changing directory below. */
     fullname = FullName_save(eap->arg, FALSE);
 #endif
-    buf = alloc((unsigned)(STRLEN(tmp_orig) + (
+    buflen = STRLEN(tmp_orig) + (
 # ifdef UNIX
 		    fullname != NULL ? STRLEN(fullname) :
 # endif
-		    STRLEN(eap->arg)) + STRLEN(tmp_new) + 16));
+		    STRLEN(eap->arg)) + STRLEN(tmp_new) + 16;
+    buf = alloc((unsigned)buflen);
     if (buf == NULL)
 	goto theend;
 
 #ifdef UNIX
-    /* Temporaraly chdir to /tmp, to avoid patching files in the current
+    /* Temporarily chdir to /tmp, to avoid patching files in the current
      * directory when the patch file contains more than one patch.  When we
      * have our own temp dir use that instead, it will be cleaned up when we
      * exit (any .rej files created).  Don't change directory if we can't
@@ -925,10 +944,10 @@
     {
 # ifdef TEMPDIRNAMES
 	if (vim_tempdir != NULL)
-	    mch_chdir((char *)vim_tempdir);
+	    ignored = mch_chdir((char *)vim_tempdir);
 	else
 # endif
-	    mch_chdir("/tmp");
+	    ignored = mch_chdir("/tmp");
 	shorten_fnames(TRUE);
     }
 #endif
@@ -946,7 +965,8 @@
     {
 	/* Build the patch command and execute it.  Ignore errors.  Switch to
 	 * cooked mode to allow the user to respond to prompts. */
-	sprintf((char *)buf, "patch -o %s %s < \"%s\"", tmp_new, tmp_orig,
+	vim_snprintf((char *)buf, buflen, "patch -o %s %s < \"%s\"",
+		tmp_new, tmp_orig,
 # ifdef UNIX
 		fullname != NULL ? fullname :
 # endif
@@ -1138,7 +1158,7 @@
 
     for (wp = firstwin; wp != NULL; wp = wp->w_next)
     {
-	if (wp == curwin || eap->forceit)
+	if (wp == curwin || (eap->forceit && wp->w_p_diff))
 	{
 	    /* Set 'diff', 'scrollbind' off and 'wrap' on. */
 	    wp->w_p_diff = FALSE;
@@ -2114,6 +2134,8 @@
 	    EMSG2(_("E102: Can't find buffer \"%s\""), eap->arg);
 	    return;
 	}
+	if (buf == curbuf)
+	    return;		/* nothing to do */
 	idx_other = diff_buf_idx(buf);
 	if (idx_other == DB_COUNT)
 	{
diff -Naur vim72.orig/src/digraph.c vim72/src/digraph.c
--- vim72.orig/src/digraph.c	2008-06-23 14:12:51.000000000 -0700
+++ vim72/src/digraph.c	2009-06-05 14:24:27.000000000 -0700
@@ -32,7 +32,7 @@
 static void printdigraph __ARGS((digr_T *));
 
 /* digraphs added by the user */
-static garray_T	user_digraphs = {0, 0, sizeof(digr_T), 10, NULL};
+static garray_T	user_digraphs = {0, 0, (int)sizeof(digr_T), 10, NULL};
 
 /*
  * Note: Characters marked with XX are not included literally, because some
@@ -2371,10 +2371,10 @@
 	}
 	else
 #endif
-	    *p++ = dp->result;
+	    *p++ = (char_u)dp->result;
 	if (char2cells(dp->result) == 1)
 	    *p++ = ' ';
-	sprintf((char *)p, " %3d", dp->result);
+	vim_snprintf((char *)p, sizeof(buf) - (p - buf), " %3d", dp->result);
 	msg_outtrans(buf);
     }
 }
@@ -2395,7 +2395,10 @@
 static void keymap_unload __ARGS((void));
 
 /*
- * Set up key mapping tables for the 'keymap' option
+ * Set up key mapping tables for the 'keymap' option.
+ * Returns NULL if OK, an error message for failure.  This only needs to be
+ * used when setting the option, not later when the value has already been
+ * checked.
  */
     char_u *
 keymap_init()
@@ -2412,25 +2415,29 @@
     else
     {
 	char_u	*buf;
+	size_t  buflen;
 
 	/* Source the keymap file.  It will contain a ":loadkeymap" command
 	 * which will call ex_loadkeymap() below. */
-	buf = alloc((unsigned)(STRLEN(curbuf->b_p_keymap)
+	buflen = STRLEN(curbuf->b_p_keymap)
 # ifdef FEAT_MBYTE
-						       + STRLEN(p_enc)
+					   + STRLEN(p_enc)
 # endif
-						       + 14));
+						       + 14;
+	buf = alloc((unsigned)buflen);
 	if (buf == NULL)
 	    return e_outofmem;
 
 # ifdef FEAT_MBYTE
 	/* try finding "keymap/'keymap'_'encoding'.vim"  in 'runtimepath' */
-	sprintf((char *)buf, "keymap/%s_%s.vim", curbuf->b_p_keymap, p_enc);
+	vim_snprintf((char *)buf, buflen, "keymap/%s_%s.vim",
+						   curbuf->b_p_keymap, p_enc);
 	if (source_runtime(buf, FALSE) == FAIL)
 # endif
 	{
 	    /* try finding "keymap/'keymap'.vim" in 'runtimepath'  */
-	    sprintf((char *)buf, "keymap/%s.vim", curbuf->b_p_keymap);
+	    vim_snprintf((char *)buf, buflen, "keymap/%s.vim",
+							  curbuf->b_p_keymap);
 	    if (source_runtime(buf, FALSE) == FAIL)
 	    {
 		vim_free(buf);
diff -Naur vim72.orig/src/edit.c vim72/src/edit.c
--- vim72.orig/src/edit.c	2008-08-06 05:51:17.000000000 -0700
+++ vim72/src/edit.c	2009-06-05 14:25:48.000000000 -0700
@@ -57,7 +57,7 @@
     N_(" Keyword Local completion (^N^P)"),
 };
 
-static char_u e_hitend[] = N_("Hit end of paragraph");
+static char e_hitend[] = N_("Hit end of paragraph");
 
 /*
  * Structure used to store one match for insert completion.
@@ -147,6 +147,7 @@
 static int  ins_compl_bs __ARGS((void));
 static void ins_compl_new_leader __ARGS((void));
 static void ins_compl_addleader __ARGS((int c));
+static int ins_compl_len __ARGS((void));
 static void ins_compl_restart __ARGS((void));
 static void ins_compl_set_original_text __ARGS((char_u *str));
 static void ins_compl_addfrommatch __ARGS((void));
@@ -164,7 +165,7 @@
 static int  ins_compl_key2count __ARGS((int c));
 static int  ins_compl_use_match __ARGS((int c));
 static int  ins_complete __ARGS((int c));
-static int  quote_meta __ARGS((char_u *dest, char_u *str, int len));
+static unsigned  quote_meta __ARGS((char_u *dest, char_u *str, int len));
 #endif /* FEAT_INS_EXPAND */
 
 #define BACKSPACE_CHAR		    1
@@ -197,7 +198,8 @@
 static void mb_replace_pop_ins __ARGS((int cc));
 #endif
 static void replace_flush __ARGS((void));
-static void replace_do_bs __ARGS((void));
+static void replace_do_bs __ARGS((int limit_col));
+static int del_char_after_col __ARGS((int limit_col));
 #ifdef FEAT_CINDENT
 static int cindent_on __ARGS((void));
 #endif
@@ -304,7 +306,7 @@
     int		c = 0;
     char_u	*ptr;
     int		lastc;
-    colnr_T	mincol;
+    int		mincol;
     static linenr_T o_lnum = 0;
     int		i;
     int		did_backspace = TRUE;	    /* previous char was backspace */
@@ -385,7 +387,7 @@
 	if (startln)
 	    Insstart.col = 0;
     }
-    Insstart_textlen = linetabsize(ml_get_curline());
+    Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
     Insstart_blank_vcol = MAXCOL;
     if (!did_ai)
 	ai_col = 0;
@@ -651,7 +653,7 @@
 	    mincol = curwin->w_wcol;
 	    validate_cursor_col();
 
-	    if ((int)curwin->w_wcol < (int)mincol - curbuf->b_p_ts
+	    if ((int)curwin->w_wcol < mincol - curbuf->b_p_ts
 		    && curwin->w_wrow == W_WINROW(curwin)
 						 + curwin->w_height - 1 - p_so
 		    && (curwin->w_cursor.lnum != curwin->w_topline
@@ -751,7 +753,7 @@
 		 * there is nothing to add, CTRL-L works like CTRL-P then. */
 		if (c == Ctrl_L
 			&& (ctrl_x_mode != CTRL_X_WHOLE_LINE
-			    || STRLEN(compl_shown_match->cp_str)
+			    || (int)STRLEN(compl_shown_match->cp_str)
 					  > curwin->w_cursor.col - compl_col))
 		{
 		    ins_compl_addfrommatch();
@@ -1771,7 +1773,7 @@
 	 * Compute the screen column where the cursor should be.
 	 */
 	vcol = get_indent() - vcol;
-	curwin->w_virtcol = (vcol < 0) ? 0 : vcol;
+	curwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);
 
 	/*
 	 * Advance the cursor until we reach the right screen column.
@@ -1798,9 +1800,9 @@
 	 */
 	if (vcol != (int)curwin->w_virtcol)
 	{
-	    curwin->w_cursor.col = new_cursor_col;
+	    curwin->w_cursor.col = (colnr_T)new_cursor_col;
 	    i = (int)curwin->w_virtcol - vcol;
-	    ptr = alloc(i + 1);
+	    ptr = alloc((unsigned)(i + 1));
 	    if (ptr != NULL)
 	    {
 		new_cursor_col += i;
@@ -1824,7 +1826,7 @@
     if (new_cursor_col <= 0)
 	curwin->w_cursor.col = 0;
     else
-	curwin->w_cursor.col = new_cursor_col;
+	curwin->w_cursor.col = (colnr_T)new_cursor_col;
     curwin->w_set_curswant = TRUE;
     changed_cline_bef_curs();
 
@@ -1933,6 +1935,8 @@
 /*
  * Backspace the cursor until the given column.  Handles REPLACE and VREPLACE
  * modes correctly.  May also be used when not in insert mode at all.
+ * Will attempt not to go before "col" even when there is a composing
+ * character.
  */
     void
 backspace_until_column(col)
@@ -1942,13 +1946,50 @@
     {
 	curwin->w_cursor.col--;
 	if (State & REPLACE_FLAG)
-	    replace_do_bs();
-	else
-	    (void)del_char(FALSE);
+	    replace_do_bs(col);
+	else if (!del_char_after_col(col))
+	    break;
     }
 }
 #endif
 
+/*
+ * Like del_char(), but make sure not to go before column "limit_col".
+ * Only matters when there are composing characters.
+ * Return TRUE when something was deleted.
+ */
+/*ARGSUSED*/
+   static int
+del_char_after_col(limit_col)
+    int limit_col;
+{
+#ifdef FEAT_MBYTE
+    if (enc_utf8 && limit_col >= 0)
+    {
+	colnr_T ecol = curwin->w_cursor.col + 1;
+
+	/* Make sure the cursor is at the start of a character, but
+	 * skip forward again when going too far back because of a
+	 * composing character. */
+	mb_adjust_cursor();
+	while (curwin->w_cursor.col < (colnr_T)limit_col)
+	{
+	    int l = utf_ptr2len(ml_get_cursor());
+
+	    if (l == 0)  /* end of line */
+		break;
+	    curwin->w_cursor.col += l;
+	}
+	if (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)
+	    return FALSE;
+	del_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);
+    }
+    else
+#endif
+	(void)del_char(FALSE);
+    return TRUE;
+}
+
 #if defined(FEAT_INS_EXPAND) || defined(PROTO)
 /*
  * CTRL-X pressed in Insert mode.
@@ -2160,7 +2201,7 @@
 	    actual_compl_length = compl_length;
 
 	/* Allocate wide character array for the completion and fill it. */
-	wca = (int *)alloc(actual_len * sizeof(int));
+	wca = (int *)alloc((unsigned)(actual_len * sizeof(int)));
 	if (wca != NULL)
 	{
 	    p = str;
@@ -2418,7 +2459,7 @@
 	{
 	    had_match = (curwin->w_cursor.col > compl_col);
 	    ins_compl_delete();
-	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+	    ins_bytes(compl_leader + ins_compl_len());
 	    ins_redraw(FALSE);
 
 	    /* When the match isn't there (to avoid matching itself) remove it
@@ -2470,7 +2511,7 @@
 	    *p = NUL;
 	    had_match = (curwin->w_cursor.col > compl_col);
 	    ins_compl_delete();
-	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+	    ins_bytes(compl_leader + ins_compl_len());
 	    ins_redraw(FALSE);
 
 	    /* When the match isn't there (to avoid matching itself) remove it
@@ -2539,7 +2580,7 @@
  */
     void
 set_completion(startcol, list)
-    int	    startcol;
+    colnr_T startcol;
     list_T  *list;
 {
     /* If already doing completions stop it. */
@@ -2550,10 +2591,10 @@
     if (stop_arrow() == FAIL)
 	return;
 
-    if (startcol > (int)curwin->w_cursor.col)
+    if (startcol > curwin->w_cursor.col)
 	startcol = curwin->w_cursor.col;
     compl_col = startcol;
-    compl_length = curwin->w_cursor.col - startcol;
+    compl_length = (int)curwin->w_cursor.col - (int)startcol;
     /* compl_pattern doesn't need to be set */
     compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);
     if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,
@@ -2819,7 +2860,6 @@
     regmatch_T	regmatch;
     char_u	**files;
     int		count;
-    int		i;
     int		save_p_scs;
     int		dir = compl_direction;
 
@@ -2851,17 +2891,18 @@
     if (ctrl_x_mode == CTRL_X_WHOLE_LINE)
     {
 	char_u *pat_esc = vim_strsave_escaped(pat, (char_u *)"\\");
+	size_t len;
 
 	if (pat_esc == NULL)
 	    goto theend;
-	i = (int)STRLEN(pat_esc) + 10;
-	ptr = alloc(i);
+	len = STRLEN(pat_esc) + 10;
+	ptr = alloc((unsigned)len);
 	if (ptr == NULL)
 	{
 	    vim_free(pat_esc);
 	    goto theend;
 	}
-	vim_snprintf((char *)ptr, i, "^\\s*\\zs\\V%s", pat_esc);
+	vim_snprintf((char *)ptr, len, "^\\s*\\zs\\V%s", pat_esc);
 	regmatch.regprog = vim_regcomp(ptr, RE_MAGIC);
 	vim_free(pat_esc);
 	vim_free(ptr);
@@ -2952,7 +2993,7 @@
 	{
 	    vim_snprintf((char *)IObuff, IOSIZE,
 			      _("Scanning dictionary: %s"), (char *)files[i]);
-	    msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
+	    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
 	}
 
 	if (fp != NULL)
@@ -3209,7 +3250,7 @@
 {
     ins_compl_del_pum();
     ins_compl_delete();
-    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+    ins_bytes(compl_leader + ins_compl_len());
     compl_used_match = FALSE;
 
     if (compl_started)
@@ -3264,6 +3305,20 @@
 }
 
 /*
+ * Return the length of the completion, from the completion start column to
+ * the cursor column.  Making sure it never goes below zero.
+ */
+    static int
+ins_compl_len()
+{
+    int off = (int)curwin->w_cursor.col - (int)compl_col;
+
+    if (off < 0)
+	return 0;
+    return off;
+}
+
+/*
  * Append one character to the match leader.  May reduce the number of
  * matches.
  */
@@ -3292,7 +3347,7 @@
 
     vim_free(compl_leader);
     compl_leader = vim_strnsave(ml_get_curline() + compl_col,
-					    curwin->w_cursor.col - compl_col);
+				     (int)(curwin->w_cursor.col - compl_col));
     if (compl_leader != NULL)
 	ins_compl_new_leader();
 }
@@ -3340,7 +3395,7 @@
 ins_compl_addfrommatch()
 {
     char_u	*p;
-    int		len = curwin->w_cursor.col - compl_col;
+    int		len = (int)curwin->w_cursor.col - (int)compl_col;
     int		c;
     compl_T	*cp;
 
@@ -3621,10 +3676,9 @@
 	    {
 		ins_compl_delete();
 		if (compl_leader != NULL)
-		    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+		    ins_bytes(compl_leader + ins_compl_len());
 		else if (compl_first_match != NULL)
-		    ins_bytes(compl_orig_text
-					  + curwin->w_cursor.col - compl_col);
+		    ins_bytes(compl_orig_text + ins_compl_len());
 		retval = TRUE;
 	    }
 
@@ -3907,7 +3961,7 @@
 			    : ins_buf->b_sfname == NULL
 				? (char *)ins_buf->b_fname
 				: (char *)ins_buf->b_sfname);
-		msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
+		(void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
 	    }
 	    else if (*e_cpt == NUL)
 		break;
@@ -3936,8 +3990,8 @@
 		else if (*e_cpt == ']' || *e_cpt == 't')
 		{
 		    type = CTRL_X_TAGS;
-		    sprintf((char*)IObuff, _("Scanning tags."));
-		    msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
+		    vim_snprintf((char *)IObuff, IOSIZE, _("Scanning tags."));
+		    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
 		}
 		else
 		    type = -1;
@@ -4035,7 +4089,7 @@
 	case CTRL_X_SPELL:
 #ifdef FEAT_SPELL
 	    num_matches = expand_spelling(first_match_pos.lnum,
-				 first_match_pos.col, compl_pattern, &matches);
+						     compl_pattern, &matches);
 	    if (num_matches > 0)
 		ins_compl_add_matches(num_matches, matches, p_ic);
 #endif
@@ -4187,7 +4241,7 @@
 	}
 
 	/* check if compl_curr_match has changed, (e.g. other type of
-	 * expansion added somenthing) */
+	 * expansion added something) */
 	if (type != 0 && compl_curr_match != old_match)
 	    found_new_match = OK;
 
@@ -4256,7 +4310,7 @@
     static void
 ins_compl_insert()
 {
-    ins_bytes(compl_shown_match->cp_str + curwin->w_cursor.col - compl_col);
+    ins_bytes(compl_shown_match->cp_str + ins_compl_len());
     if (compl_shown_match->cp_flags & ORIGINAL_TEXT)
 	compl_used_match = FALSE;
     else
@@ -4425,7 +4479,7 @@
 	if (!compl_get_longest || compl_used_match)
 	    ins_compl_insert();
 	else
-	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+	    ins_bytes(compl_leader + ins_compl_len());
     }
     else
 	compl_used_match = FALSE;
@@ -4688,7 +4742,7 @@
 		}
 		compl_length = curwin->w_cursor.col - (int)compl_col;
 		/* IObuff is used to add a "word from the next line" would we
-		 * have enough space?  just being paranoic */
+		 * have enough space?  just being paranoid */
 #define	MIN_SPACE 75
 		if (compl_length > (IOSIZE - MIN_SPACE))
 		{
@@ -4745,10 +4799,9 @@
 	    {
 		char_u	    *prefix = (char_u *)"\\<";
 
-		/* we need 3 extra chars, 1 for the NUL and
-		 * 2 >= strlen(prefix)	-- Acevedo */
+		/* we need up to 2 extra chars for the prefix */
 		compl_pattern = alloc(quote_meta(NULL, line + compl_col,
-							   compl_length) + 3);
+							   compl_length) + 2);
 		if (compl_pattern == NULL)
 		    return FAIL;
 		if (!vim_iswordp(line + compl_col)
@@ -4823,7 +4876,7 @@
 		else
 		{
 		    compl_pattern = alloc(quote_meta(NULL, line + compl_col,
-							   compl_length) + 3);
+							   compl_length) + 2);
 		    if (compl_pattern == NULL)
 			return FAIL;
 		    STRCPY((char *)compl_pattern, "\\<");
@@ -4905,7 +4958,7 @@
 	    if (col < 0)
 		col = curs_col;
 	    compl_col = col;
-	    if ((colnr_T)compl_col > curs_col)
+	    if (compl_col > curs_col)
 		compl_col = curs_col;
 
 	    /* Setup variables for completion.  Need to obtain "line" again,
@@ -5178,15 +5231,15 @@
  * a backslash) the metachars, and dest would be NUL terminated.
  * Returns the length (needed) of dest
  */
-    static int
+    static unsigned
 quote_meta(dest, src, len)
     char_u	*dest;
     char_u	*src;
     int		len;
 {
-    int	m;
+    unsigned	m = (unsigned)len + 1;  /* one extra for the NUL */
 
-    for (m = len; --len >= 0; src++)
+    for ( ; --len >= 0; src++)
     {
 	switch (*src)
 	{
@@ -6015,7 +6068,7 @@
      * in 'formatoptions' and there is a single character before the cursor.
      * Otherwise the line would be broken and when typing another non-white
      * next they are not joined back together. */
-    wasatend = (pos.col == STRLEN(old));
+    wasatend = (pos.col == (colnr_T)STRLEN(old));
     if (*old != NUL && !trailblank && wasatend)
     {
 	dec_cursor();
@@ -6192,7 +6245,7 @@
      * three digits. */
     if (VIM_ISDIGIT(c))
     {
-	sprintf((char *)buf, "%03d", c);
+	vim_snprintf((char *)buf, sizeof(buf), "%03d", c);
 	AppendToRedobuff(buf);
     }
     else
@@ -6266,7 +6319,7 @@
 	    ins_need_undo = FALSE;
 	}
 	Insstart = curwin->w_cursor;	/* new insertion starts here */
-	Insstart_textlen = linetabsize(ml_get_curline());
+	Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
 	ai_col = 0;
 #ifdef FEAT_VREPLACE
 	if (State & VREPLACE_FLAG)
@@ -6369,13 +6422,17 @@
 
 	/* If we just did an auto-indent, remove the white space from the end
 	 * of the line, and put the cursor back.
-	 * Do this when ESC was used or moving the cursor up/down. */
+	 * Do this when ESC was used or moving the cursor up/down.
+	 * Check for the old position still being valid, just in case the text
+	 * got changed unexpectedly. */
 	if (did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL
-			&& curwin->w_cursor.lnum != end_insert_pos->lnum)))
+			&& curwin->w_cursor.lnum != end_insert_pos->lnum))
+		&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)
 	{
 	    pos_T	tpos = curwin->w_cursor;
 
 	    curwin->w_cursor = *end_insert_pos;
+	    check_cursor_col();  /* make sure it is not past the line */
 	    for (;;)
 	    {
 		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
@@ -6383,7 +6440,8 @@
 		cc = gchar_cursor();
 		if (!vim_iswhite(cc))
 		    break;
-		(void)del_char(TRUE);
+		if (del_char(TRUE) == FAIL)
+		    break;  /* should not happen */
 	    }
 	    if (curwin->w_cursor.lnum != tpos.lnum)
 		curwin->w_cursor = tpos;
@@ -6395,10 +6453,11 @@
 	     * deleted characters. */
 	    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)
 	    {
-		cc = (int)STRLEN(ml_get_curline());
-		if (VIsual.col > (colnr_T)cc)
+		int len = (int)STRLEN(ml_get_curline());
+
+		if (VIsual.col > len)
 		{
-		    VIsual.col = cc;
+		    VIsual.col = len;
 # ifdef FEAT_VIRTUALEDIT
 		    VIsual.coladd = 0;
 # endif
@@ -7123,9 +7182,12 @@
  * cc == 0: character was inserted, delete it
  * cc > 0: character was replaced, put cc (first byte of original char) back
  * and check for more characters to be put back
+ * When "limit_col" is >= 0, don't delete before this column.  Matters when
+ * using composing characters, use del_char_after_col() instead of del_char().
  */
     static void
-replace_do_bs()
+replace_do_bs(limit_col)
+    int		limit_col;
 {
     int		cc;
 #ifdef FEAT_VREPLACE
@@ -7153,7 +7215,7 @@
 #ifdef FEAT_MBYTE
 	if (has_mbyte)
 	{
-	    del_char(FALSE);
+	    (void)del_char_after_col(limit_col);
 # ifdef FEAT_VREPLACE
 	    if (State & VREPLACE_FLAG)
 		orig_len = (int)STRLEN(ml_get_cursor());
@@ -7203,7 +7265,7 @@
 	changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);
     }
     else if (cc == 0)
-	(void)del_char(FALSE);
+	(void)del_char_after_col(limit_col);
 }
 
 #ifdef FEAT_CINDENT
@@ -7646,9 +7708,7 @@
      */
     ++no_mapping;
     regname = plain_vgetc();
-#ifdef FEAT_LANGMAP
     LANGMAP_ADJUST(regname, TRUE);
-#endif
     if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P)
     {
 	/* Get a third key for literal register insertion */
@@ -7657,9 +7717,7 @@
 	add_to_showcmd_c(literally);
 #endif
 	regname = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	LANGMAP_ADJUST(regname, TRUE);
-#endif
     }
     --no_mapping;
 
@@ -8150,7 +8208,7 @@
 /*
  * If the cursor is on an indent, ^T/^D insert/delete one
  * shiftwidth.	Otherwise ^T/^D behave like a "<<" or ">>".
- * Always round the indent to 'shiftwith', this is compatible
+ * Always round the indent to 'shiftwidth', this is compatible
  * with vi.  But vi only supports ^T and ^D after an
  * autoindent, we support it everywhere.
  */
@@ -8239,7 +8297,7 @@
 	 * Replace mode */
 	if (curwin->w_cursor.lnum != Insstart.lnum
 		|| curwin->w_cursor.col >= Insstart.col)
-	    replace_do_bs();
+	    replace_do_bs(-1);
     }
     else
 	(void)del_char(FALSE);
@@ -8258,6 +8316,7 @@
     linenr_T	lnum;
     int		cc;
     int		temp = 0;	    /* init for GCC */
+    colnr_T	save_col;
     colnr_T	mincol;
     int		did_backspace = FALSE;
     int		in_indent;
@@ -8415,13 +8474,13 @@
 		 */
 		while (cc > 0)
 		{
-		    temp = curwin->w_cursor.col;
+		    save_col = curwin->w_cursor.col;
 #ifdef FEAT_MBYTE
 		    mb_replace_pop_ins(cc);
 #else
 		    ins_char(cc);
 #endif
-		    curwin->w_cursor.col = temp;
+		    curwin->w_cursor.col = save_col;
 		    cc = replace_pop();
 		}
 		/* restore the characters that NL replaced */
@@ -8453,11 +8512,11 @@
 #endif
 			    )
 	{
-	    temp = curwin->w_cursor.col;
+	    save_col = curwin->w_cursor.col;
 	    beginline(BL_WHITE);
 	    if (curwin->w_cursor.col < (colnr_T)temp)
 		mincol = curwin->w_cursor.col;
-	    curwin->w_cursor.col = temp;
+	    curwin->w_cursor.col = save_col;
 	}
 
 	/*
@@ -8556,7 +8615,7 @@
 		break;
 	    }
 	    if (State & REPLACE_FLAG)
-		replace_do_bs();
+		replace_do_bs(-1);
 	    else
 	    {
 #ifdef FEAT_MBYTE
@@ -8931,7 +8990,10 @@
 	foldOpenCursor();
 #endif
     undisplay_dollar();
-    if (gchar_cursor() != NUL || virtual_active()
+    if (gchar_cursor() != NUL
+#ifdef FEAT_VIRTUALEDIT
+	    || virtual_active()
+#endif
 	    )
     {
 	start_arrow(&curwin->w_cursor);
diff -Naur vim72.orig/src/eval.c vim72/src/eval.c
--- vim72.orig/src/eval.c	2008-08-07 12:37:22.000000000 -0700
+++ vim72/src/eval.c	2009-06-05 14:26:02.000000000 -0700
@@ -32,6 +32,9 @@
 
 #define DICT_MAXNEST 100	/* maximum nesting of lists and dicts */
 
+#define DO_NOT_FREE_CNT 99999	/* refcount for dict or list that should not
+				   be freed. */
+
 /*
  * In a hashtab item "hi_key" points to "di_key" in a dictitem.
  * This avoids adding a pointer to the hashtab item.
@@ -126,8 +129,11 @@
 /*
  * When recursively copying lists and dicts we need to remember which ones we
  * have done to avoid endless recursiveness.  This unique ID is used for that.
+ * The last bit is used for previous_funccal, ignored when comparing.
  */
 static int current_copyID = 0;
+#define COPYID_INC 2
+#define COPYID_MASK (~0x1)
 
 /*
  * Array to hold the hashtab with variables local to each sourced script.
@@ -280,7 +286,7 @@
 #define VV_RO		2	/* read-only */
 #define VV_RO_SBX	4	/* read-only in the sandbox */
 
-#define VV_NAME(s, t)	s, {{t}}, {0}
+#define VV_NAME(s, t)	s, {{t, 0, {0}}, 0, {0}}, {0}
 
 static struct vimvar
 {
@@ -348,6 +354,7 @@
     {VV_NAME("mouse_col",	 VAR_NUMBER), 0},
     {VV_NAME("operator",	 VAR_STRING), VV_RO},
     {VV_NAME("searchforward",	 VAR_NUMBER), 0},
+    {VV_NAME("oldfiles",	 VAR_LIST), 0},
 };
 
 /* shorthand */
@@ -355,6 +362,7 @@
 #define vv_nr		vv_di.di_tv.vval.v_number
 #define vv_float	vv_di.di_tv.vval.v_float
 #define vv_str		vv_di.di_tv.vval.v_string
+#define vv_list		vv_di.di_tv.vval.v_list
 #define vv_tv		vv_di.di_tv
 
 /*
@@ -426,7 +434,6 @@
 static long list_idx_of_item __ARGS((list_T *l, listitem_T *item));
 static void list_append __ARGS((list_T *l, listitem_T *item));
 static int list_append_tv __ARGS((list_T *l, typval_T *tv));
-static int list_append_string __ARGS((list_T *l, char_u *str, int len));
 static int list_append_number __ARGS((list_T *l, varnumber_T n));
 static int list_insert_tv __ARGS((list_T *l, typval_T *tv, listitem_T *item));
 static int list_extend __ARGS((list_T	*l1, list_T *l2, listitem_T *bef));
@@ -435,6 +442,7 @@
 static void list_remove __ARGS((list_T *l, listitem_T *item, listitem_T *item2));
 static char_u *list2string __ARGS((typval_T *tv, int copyID));
 static int list_join __ARGS((garray_T *gap, list_T *l, char_u *sep, int echo, int copyID));
+static int free_unref_items __ARGS((int copyID));
 static void set_ref_in_ht __ARGS((hashtab_T *ht, int copyID));
 static void set_ref_in_list __ARGS((list_T *l, int copyID));
 static void set_ref_in_item __ARGS((typval_T *tv, int copyID));
@@ -788,6 +796,8 @@
 static void func_unref __ARGS((char_u *name));
 static void func_ref __ARGS((char_u *name));
 static void call_user_func __ARGS((ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, linenr_T firstline, linenr_T lastline, dict_T *selfdict));
+static int can_free_funccal __ARGS((funccall_T *fc, int copyID)) ;
+static void free_funccal __ARGS((funccall_T *fc, int free_val));
 static void add_nr_var __ARGS((dict_T *dp, dictitem_T *v, char *name, varnumber_T nr));
 static win_T *find_win_by_nr __ARGS((typval_T *vp, tabpage_T *tp));
 static void getwinvar __ARGS((typval_T *argvars, typval_T *rettv, int off));
@@ -845,11 +855,17 @@
 	p = &vimvars[i];
 	if (p->vv_di.di_tv.v_type == VAR_STRING)
 	{
-	    vim_free(p->vv_di.di_tv.vval.v_string);
-	    p->vv_di.di_tv.vval.v_string = NULL;
+	    vim_free(p->vv_str);
+	    p->vv_str = NULL;
+	}
+	else if (p->vv_di.di_tv.v_type == VAR_LIST)
+	{
+	    list_unref(p->vv_list);
+	    p->vv_list = NULL;
 	}
     }
     hash_clear(&vimvarht);
+    hash_init(&vimvarht);  /* garbage_collect() will access it */
     hash_clear(&compat_hashtab);
 
     /* script-local variables */
@@ -916,6 +932,10 @@
 /* pointer to funccal for currently active function */
 funccall_T *current_funccal = NULL;
 
+/* pointer to list of previously used funccal, still around because some
+ * item in it is still being used. */
+funccall_T *previous_funccal = NULL;
+
 /*
  * Return TRUE when a function was ended by a ":return" command.
  */
@@ -1256,23 +1276,28 @@
 
 /*
  * Top level evaluation function, returning a string.
+ * When "convert" is TRUE convert a List into a sequence of lines and convert
+ * a Float to a String.
  * Return pointer to allocated memory, or NULL for failure.
  */
     char_u *
-eval_to_string(arg, nextcmd, dolist)
+eval_to_string(arg, nextcmd, convert)
     char_u	*arg;
     char_u	**nextcmd;
-    int		dolist;		/* turn List into sequence of lines */
+    int		convert;
 {
     typval_T	tv;
     char_u	*retval;
     garray_T	ga;
+#ifdef FEAT_FLOAT
+    char_u	numbuf[NUMBUFLEN];
+#endif
 
     if (eval0(arg, &tv, nextcmd, TRUE) == FAIL)
 	retval = NULL;
     else
     {
-	if (dolist && tv.v_type == VAR_LIST)
+	if (convert && tv.v_type == VAR_LIST)
 	{
 	    ga_init2(&ga, (int)sizeof(char), 80);
 	    if (tv.vval.v_list != NULL)
@@ -1280,6 +1305,13 @@
 	    ga_append(&ga, NUL);
 	    retval = (char_u *)ga.ga_data;
 	}
+#ifdef FEAT_FLOAT
+	else if (convert && tv.v_type == VAR_FLOAT)
+	{
+	    vim_snprintf((char *)numbuf, NUMBUFLEN, "%g", tv.vval.v_float);
+	    retval = vim_strsave(numbuf);
+	}
+#endif
 	else
 	    retval = vim_strsave(get_tv_string(&tv));
 	clear_tv(&tv);
@@ -3277,7 +3309,7 @@
 
     if (*startarg != '(')
     {
-	EMSG2(_("E107: Missing braces: %s"), eap->arg);
+	EMSG2(_("E107: Missing parentheses: %s"), eap->arg);
 	goto end;
     }
 
@@ -3657,8 +3689,8 @@
 }
 
 /*
- * Return TRUE if typeval "tv" is locked: Either tha value is locked itself or
- * it refers to a List or Dictionary that is locked.
+ * Return TRUE if typeval "tv" is locked: Either that value is locked itself
+ * or it refers to a List or Dictionary that is locked.
  */
     static int
 tv_islocked(tv)
@@ -3744,7 +3776,6 @@
  * Function given to ExpandGeneric() to obtain the list of user defined
  * (global/buffer/window/built-in) variable names.
  */
-/*ARGSUSED*/
     char_u *
 get_user_var_name(xp, idx)
     expand_T	*xp;
@@ -3902,7 +3933,7 @@
 
 /*
  * Handle top level expression:
- *	expr1 ? expr0 : expr0
+ *	expr2 ? expr1 : expr1
  *
  * "arg" must point to the first non-white of the expression.
  * "arg" is advanced to the next non-white after the recognized expression.
@@ -6047,6 +6078,25 @@
 }
 
 /*
+ * Get list item "l[idx - 1]" as a string.  Returns NULL for failure.
+ */
+    char_u *
+list_find_str(l, idx)
+    list_T	*l;
+    long	idx;
+{
+    listitem_T	*li;
+
+    li = list_find(l, idx - 1);
+    if (li == NULL)
+    {
+	EMSGN(_(e_listidx), idx);
+	return NULL;
+    }
+    return get_tv_string(&li->li_tv);
+}
+
+/*
  * Locate "item" list "l" and return its index.
  * Returns -1 when "item" is not in the list.
  */
@@ -6137,7 +6187,7 @@
  * When "len" >= 0 use "str[len]".
  * Returns FAIL when out of memory.
  */
-    static int
+    int
 list_append_string(l, str, len)
     list_T	*l;
     char_u	*str;
@@ -6448,14 +6498,13 @@
     int
 garbage_collect()
 {
-    dict_T	*dd;
-    list_T	*ll;
-    int		copyID = ++current_copyID;
+    int		copyID;
     buf_T	*buf;
     win_T	*wp;
     int		i;
-    funccall_T	*fc;
-    int		did_free = FALSE;
+    funccall_T	*fc, **pfc;
+    int		did_free;
+    int		did_free_funccal = FALSE;
 #ifdef FEAT_WINDOWS
     tabpage_T	*tp;
 #endif
@@ -6465,10 +6514,25 @@
     may_garbage_collect = FALSE;
     garbage_collect_at_exit = FALSE;
 
+    /* We advance by two because we add one for items referenced through
+     * previous_funccal. */
+    current_copyID += COPYID_INC;
+    copyID = current_copyID;
+
     /*
      * 1. Go through all accessible variables and mark all lists and dicts
      *    with copyID.
      */
+
+    /* Don't free variables in the previous_funccal list unless they are only
+     * referenced through previous_funccal.  This must be first, because if
+     * the item is referenced elsewhere the funccal must not be freed. */
+    for (fc = previous_funccal; fc != NULL; fc = fc->caller)
+    {
+	set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1);
+	set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1);
+    }
+
     /* script-local variables */
     for (i = 1; i <= ga_scripts.ga_len; ++i)
 	set_ref_in_ht(&SCRIPT_VARS(i), copyID);
@@ -6497,11 +6561,54 @@
 	set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID);
     }
 
+    /* v: vars */
+    set_ref_in_ht(&vimvarht, copyID);
+
+    /*
+     * 2. Free lists and dictionaries that are not referenced.
+     */
+    did_free = free_unref_items(copyID);
+
     /*
-     * 2. Go through the list of dicts and free items without the copyID.
+     * 3. Check if any funccal can be freed now.
+     */
+    for (pfc = &previous_funccal; *pfc != NULL; )
+    {
+	if (can_free_funccal(*pfc, copyID))
+	{
+	    fc = *pfc;
+	    *pfc = fc->caller;
+	    free_funccal(fc, TRUE);
+	    did_free = TRUE;
+	    did_free_funccal = TRUE;
+	}
+	else
+	    pfc = &(*pfc)->caller;
+    }
+    if (did_free_funccal)
+	/* When a funccal was freed some more items might be garbage
+	 * collected, so run again. */
+	(void)garbage_collect();
+
+    return did_free;
+}
+
+/*
+ * Free lists and dictionaries that are no longer referenced.
+ */
+    static int
+free_unref_items(copyID)
+    int copyID;
+{
+    dict_T	*dd;
+    list_T	*ll;
+    int		did_free = FALSE;
+
+    /*
+     * Go through the list of dicts and free items without the copyID.
      */
     for (dd = first_dict; dd != NULL; )
-	if (dd->dv_copyID != copyID)
+	if ((dd->dv_copyID & COPYID_MASK) != (copyID & COPYID_MASK))
 	{
 	    /* Free the Dictionary and ordinary items it contains, but don't
 	     * recurse into Lists and Dictionaries, they will be in the list
@@ -6516,12 +6623,13 @@
 	    dd = dd->dv_used_next;
 
     /*
-     * 3. Go through the list of lists and free items without the copyID.
-     *    But don't free a list that has a watcher (used in a for loop), these
-     *    are not referenced anywhere.
+     * Go through the list of lists and free items without the copyID.
+     * But don't free a list that has a watcher (used in a for loop), these
+     * are not referenced anywhere.
      */
     for (ll = first_list; ll != NULL; )
-	if (ll->lv_copyID != copyID && ll->lv_watch == NULL)
+	if ((ll->lv_copyID & COPYID_MASK) != (copyID & COPYID_MASK)
+						      && ll->lv_watch == NULL)
 	{
 	    /* Free the List and ordinary items it contains, but don't recurse
 	     * into Lists and Dictionaries, they will be in the list of dicts
@@ -6587,7 +6695,7 @@
     {
 	case VAR_DICT:
 	    dd = tv->vval.v_dict;
-	    if (dd->dv_copyID != copyID)
+	    if (dd != NULL && dd->dv_copyID != copyID)
 	    {
 		/* Didn't see this dict yet. */
 		dd->dv_copyID = copyID;
@@ -6597,7 +6705,7 @@
 
 	case VAR_LIST:
 	    ll = tv->vval.v_list;
-	    if (ll->lv_copyID != copyID)
+	    if (ll != NULL && ll->lv_copyID != copyID)
 	    {
 		/* Didn't see this list yet. */
 		ll->lv_copyID = copyID;
@@ -7525,8 +7633,8 @@
     {"getwinposx",	0, 0, f_getwinposx},
     {"getwinposy",	0, 0, f_getwinposy},
     {"getwinvar",	2, 2, f_getwinvar},
-    {"glob",		1, 1, f_glob},
-    {"globpath",	2, 2, f_globpath},
+    {"glob",		1, 2, f_glob},
+    {"globpath",	2, 3, f_globpath},
     {"has",		1, 1, f_has},
     {"has_key",		2, 2, f_has_key},
     {"haslocaldir",	0, 0, f_haslocaldir},
@@ -7723,7 +7831,6 @@
  * Function given to ExpandGeneric() to obtain the list of internal or
  * user defined variable or function names.
  */
-/*ARGSUSED*/
     char_u *
 get_expr_name(xp, idx)
     expand_T	*xp;
@@ -7856,9 +7963,9 @@
     else if (!aborting())
     {
 	if (argcount == MAX_FUNC_ARGS)
-	    emsg_funcname("E740: Too many arguments for function %s", name);
+	    emsg_funcname(N_("E740: Too many arguments for function %s"), name);
 	else
-	    emsg_funcname("E116: Invalid arguments for function %s", name);
+	    emsg_funcname(N_("E116: Invalid arguments for function %s"), name);
     }
 
     while (--argcount >= 0)
@@ -7956,7 +8063,8 @@
     /* execute the function if no errors detected and executing */
     if (evaluate && error == ERROR_NONE)
     {
-	rettv->v_type = VAR_NUMBER;	/* default is number rettv */
+	rettv->v_type = VAR_NUMBER;	/* default rettv is number zero */
+	rettv->vval.v_number = 0;
 	error = ERROR_UNKNOWN;
 
 	if (!builtin_function(fname))
@@ -8091,6 +8199,7 @@
 
 /*
  * Give an error message with a function name.  Handle <SNR> things.
+ * "ermsg" is to be passed without translation, use N_() instead of _().
  */
     static void
 emsg_funcname(ermsg, name)
@@ -8205,7 +8314,6 @@
 		return;
 	    li = l->lv_first;
 	}
-	rettv->vval.v_number = 0;	/* Default: Success */
 	for (;;)
 	{
 	    if (l == NULL)
@@ -8238,10 +8346,9 @@
 /*
  * "argc()" function
  */
-/* ARGSUSED */
     static void
 f_argc(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = ARGCOUNT;
@@ -8250,10 +8357,9 @@
 /*
  * "argidx()" function
  */
-/* ARGSUSED */
     static void
 f_argidx(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = curwin->w_arg_idx;
@@ -8331,10 +8437,9 @@
 /*
  * "browse(save, title, initdir, default)" function
  */
-/* ARGSUSED */
     static void
 f_browse(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_BROWSE
@@ -8366,10 +8471,9 @@
 /*
  * "browsedir(title, initdir)" function
  */
-/* ARGSUSED */
     static void
 f_browsedir(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_BROWSE
@@ -8594,10 +8698,9 @@
 /*
  * "byte2line(byte)" function
  */
-/*ARGSUSED*/
     static void
 f_byte2line(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifndef FEAT_BYTEOFF
@@ -8617,7 +8720,6 @@
 /*
  * "byteidx()" function
  */
-/*ARGSUSED*/
     static void
 f_byteidx(argvars, rettv)
     typval_T	*argvars;
@@ -8665,7 +8767,6 @@
     int		dummy;
     dict_T	*selfdict = NULL;
 
-    rettv->vval.v_number = 0;
     if (argvars[1].v_type != VAR_LIST)
     {
 	EMSG(_(e_listreq));
@@ -8737,10 +8838,9 @@
 /*
  * "changenr()" function
  */
-/*ARGSUSED*/
     static void
 f_changenr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = curbuf->b_u_seq_cur;
@@ -8790,11 +8890,10 @@
 /*
  * "clearmatches()" function
  */
-/*ARGSUSED*/
     static void
 f_clearmatches(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_SEARCH_EXTRA
     clear_matches(curwin);
@@ -8858,11 +8957,10 @@
 /*
  * "complete()" function
  */
-/*ARGSUSED*/
     static void
 f_complete(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     int	    startcol;
 
@@ -8893,7 +8991,6 @@
 /*
  * "complete_add()" function
  */
-/*ARGSUSED*/
     static void
 f_complete_add(argvars, rettv)
     typval_T	*argvars;
@@ -8905,10 +9002,9 @@
 /*
  * "complete_check()" function
  */
-/*ARGSUSED*/
     static void
 f_complete_check(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		saved = RedrawingDisabled;
@@ -8923,11 +9019,10 @@
 /*
  * "confirm(message, buttons[, default [, type]])" function
  */
-/*ARGSUSED*/
     static void
 f_confirm(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
     char_u	*message;
@@ -8973,13 +9068,9 @@
     if (buttons == NULL || *buttons == NUL)
 	buttons = (char_u *)_("&Ok");
 
-    if (error)
-	rettv->vval.v_number = 0;
-    else
+    if (!error)
 	rettv->vval.v_number = do_dialog(type, NULL, message, buttons,
 								   def, NULL);
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
@@ -9096,11 +9187,10 @@
  *
  * Checks the existence of a cscope connection.
  */
-/*ARGSUSED*/
     static void
 f_cscope_connection(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_CSCOPE
     int		num = 0;
@@ -9118,17 +9208,15 @@
     }
 
     rettv->vval.v_number = cs_connection(num, dbpath, prepend);
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "cursor(lnum, col)" function
  *
- * Moves the cursor to the specified line and column
+ * Moves the cursor to the specified line and column.
+ * Returns 0 when the position could be set, -1 otherwise.
  */
-/*ARGSUSED*/
     static void
 f_cursor(argvars, rettv)
     typval_T	*argvars;
@@ -9139,6 +9227,7 @@
     long	coladd = 0;
 #endif
 
+    rettv->vval.v_number = -1;
     if (argvars[1].v_type == VAR_UNKNOWN)
     {
 	pos_T	    pos;
@@ -9183,6 +9272,7 @@
 #endif
 
     curwin->w_set_curswant = TRUE;
+    rettv->vval.v_number = 0;
 }
 
 /*
@@ -9200,7 +9290,10 @@
     if (noref < 0 || noref > 1)
 	EMSG(_(e_invarg));
     else
-	item_copy(&argvars[0], rettv, TRUE, noref == 0 ? ++current_copyID : 0);
+    {
+	current_copyID += COPYID_INC;
+	item_copy(&argvars[0], rettv, TRUE, noref == 0 ? current_copyID : 0);
+    }
 }
 
 /*
@@ -9220,27 +9313,23 @@
 /*
  * "did_filetype()" function
  */
-/*ARGSUSED*/
     static void
 f_did_filetype(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_AUTOCMD
     rettv->vval.v_number = did_filetype;
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "diff_filler()" function
  */
-/*ARGSUSED*/
     static void
 f_diff_filler(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_DIFF
     rettv->vval.v_number = diff_check_fill(curwin, get_tv_lnum(argvars));
@@ -9250,11 +9339,10 @@
 /*
  * "diff_hlID()" function
  */
-/*ARGSUSED*/
     static void
 f_diff_hlID(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_DIFF
     linenr_T		lnum = get_tv_lnum(argvars);
@@ -9367,7 +9455,6 @@
 /*
  * "eval()" function
  */
-/*ARGSUSED*/
     static void
 f_eval(argvars, rettv)
     typval_T	*argvars;
@@ -9391,10 +9478,9 @@
 /*
  * "eventhandler()" function
  */
-/*ARGSUSED*/
     static void
 f_eventhandler(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = vgetc_busy;
@@ -9518,7 +9604,7 @@
     else
     {
 	/* When the optional second argument is non-zero, don't remove matches
-	 * for 'suffixes' and 'wildignore' */
+	 * for 'wildignore' and don't put matches for 'suffixes' at the end. */
 	if (argvars[1].v_type != VAR_UNKNOWN
 				    && get_tv_number_chk(&argvars[1], &error))
 	    flags |= WILD_KEEP_ALL;
@@ -9542,7 +9628,6 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_LIST && argvars[1].v_type == VAR_LIST)
     {
 	list_T		*l1, *l2;
@@ -9652,11 +9737,10 @@
 /*
  * "feedkeys()" function
  */
-/*ARGSUSED*/
     static void
 f_feedkeys(argvars, rettv)
     typval_T    *argvars;
-    typval_T    *rettv;
+    typval_T    *rettv UNUSED;
 {
     int		remap = TRUE;
     char_u	*keys, *flags;
@@ -9670,7 +9754,6 @@
     if (check_secure())
 	return;
 
-    rettv->vval.v_number = 0;
     keys = get_tv_string(&argvars[0]);
     if (*keys != NUL)
     {
@@ -9838,7 +9921,6 @@
     char_u	*ermsg = map ? (char_u *)"map()" : (char_u *)"filter()";
     int		save_did_emsg;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_LIST)
     {
 	if ((l = argvars[0].vval.v_list) == NULL
@@ -10021,8 +10103,6 @@
 	else
 	    rettv->vval.v_number = (varnumber_T)f;
     }
-    else
-	rettv->vval.v_number = 0;
 }
 
 /*
@@ -10156,18 +10236,15 @@
     lnum = get_tv_lnum(argvars);
     if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)
 	rettv->vval.v_number = foldLevel(lnum);
-    else
 #endif
-	rettv->vval.v_number = 0;
 }
 
 /*
  * "foldtext()" function
  */
-/*ARGSUSED*/
     static void
 f_foldtext(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_FOLDING
@@ -10232,10 +10309,9 @@
 /*
  * "foldtextresult(lnum)" function
  */
-/*ARGSUSED*/
     static void
 f_foldtextresult(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_FOLDING
@@ -10268,13 +10344,11 @@
 /*
  * "foreground()" function
  */
-/*ARGSUSED*/
     static void
 f_foreground(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-    rettv->vval.v_number = 0;
 #ifdef FEAT_GUI
     if (gui.in_use)
 	gui_mch_set_foreground();
@@ -10288,7 +10362,6 @@
 /*
  * "function()" function
  */
-/*ARGSUSED*/
     static void
 f_function(argvars, rettv)
     typval_T	*argvars;
@@ -10296,11 +10369,11 @@
 {
     char_u	*s;
 
-    rettv->vval.v_number = 0;
     s = get_tv_string(&argvars[0]);
     if (s == NULL || *s == NUL || VIM_ISDIGIT(*s))
 	EMSG2(_(e_invarg2), s);
-    else if (!function_exists(s))
+    /* Don't check an autoload name for existence here. */
+    else if (vim_strchr(s, AUTOLOAD_CHAR) == NULL && !function_exists(s))
 	EMSG2(_("E700: Unknown function: %s"), s);
     else
     {
@@ -10312,11 +10385,10 @@
 /*
  * "garbagecollect()" function
  */
-/*ARGSUSED*/
     static void
 f_garbagecollect(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     /* This is postponed until we are back at the toplevel, because we may be
      * using Lists and Dicts internally.  E.g.: ":echo [garbagecollect()]". */
@@ -10365,9 +10437,7 @@
 
     if (tv == NULL)
     {
-	if (argvars[2].v_type == VAR_UNKNOWN)
-	    rettv->vval.v_number = 0;
-	else
+	if (argvars[2].v_type != VAR_UNKNOWN)
 	    copy_tv(&argvars[2], rettv);
     }
     else
@@ -10392,13 +10462,8 @@
 {
     char_u	*p;
 
-    if (retlist)
-    {
-	if (rettv_list_alloc(rettv) == FAIL)
-	    return;
-    }
-    else
-	rettv->vval.v_number = 0;
+    if (retlist && rettv_list_alloc(rettv) == FAIL)
+	return;
 
     if (buf == NULL || buf->b_ml.ml_mfp == NULL || start < 0)
 	return;
@@ -10602,7 +10667,7 @@
 # ifdef FEAT_WINDOWS
 	    win_T	*wp;
 # endif
-	    int		n = 1;
+	    int		winnr = 1;
 
 	    if (row >= 0 && col >= 0)
 	    {
@@ -10612,9 +10677,9 @@
 		(void)mouse_comp_pos(win, &row, &col, &lnum);
 # ifdef FEAT_WINDOWS
 		for (wp = firstwin; wp != win; wp = wp->w_next)
-		    ++n;
+		    ++winnr;
 # endif
-		vimvars[VV_MOUSE_WIN].vv_nr = n;
+		vimvars[VV_MOUSE_WIN].vv_nr = winnr;
 		vimvars[VV_MOUSE_LNUM].vv_nr = lnum;
 		vimvars[VV_MOUSE_COL].vv_nr = col + 1;
 	    }
@@ -10626,10 +10691,9 @@
 /*
  * "getcharmod()" function
  */
-/*ARGSUSED*/
     static void
 f_getcharmod(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = mod_mask;
@@ -10638,10 +10702,9 @@
 /*
  * "getcmdline()" function
  */
-/*ARGSUSED*/
     static void
 f_getcmdline(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -10651,10 +10714,9 @@
 /*
  * "getcmdpos()" function
  */
-/*ARGSUSED*/
     static void
 f_getcmdpos(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = get_cmdline_pos() + 1;
@@ -10663,10 +10725,9 @@
 /*
  * "getcmdtype()" function
  */
-/*ARGSUSED*/
     static void
 f_getcmdtype(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -10681,10 +10742,9 @@
 /*
  * "getcwd()" function
  */
-/*ARGSUSED*/
     static void
 f_getcwd(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	cwd[MAXPATHL];
@@ -10705,10 +10765,9 @@
 /*
  * "getfontname()" function
  */
-/*ARGSUSED*/
     static void
 f_getfontname(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -10935,18 +10994,15 @@
 /*
  * "getmatches()" function
  */
-/*ARGSUSED*/
     static void
 f_getmatches(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_SEARCH_EXTRA
     dict_T	*dict;
     matchitem_T	*cur = curwin->w_match_head;
 
-    rettv->vval.v_number = 0;
-
     if (rettv_list_alloc(rettv) == OK)
     {
 	while (cur != NULL)
@@ -10968,10 +11024,9 @@
 /*
  * "getpid()" function
  */
-/*ARGSUSED*/
     static void
 f_getpid(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = mch_get_pid();
@@ -11015,17 +11070,15 @@
 /*
  * "getqflist()" and "getloclist()" functions
  */
-/*ARGSUSED*/
     static void
 f_getqflist(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_QUICKFIX
     win_T	*wp;
 #endif
 
-    rettv->vval.v_number = 0;
 #ifdef FEAT_QUICKFIX
     if (rettv_list_alloc(rettv) == OK)
     {
@@ -11135,10 +11188,9 @@
 /*
  * "getwinposx()" function
  */
-/*ARGSUSED*/
     static void
 f_getwinposx(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = -1;
@@ -11156,10 +11208,9 @@
 /*
  * "getwinposy()" function
  */
-/*ARGSUSED*/
     static void
 f_getwinposy(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = -1;
@@ -11284,13 +11335,25 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
+    int		flags = WILD_SILENT|WILD_USE_NL;
     expand_T	xpc;
+    int		error = FALSE;
 
-    ExpandInit(&xpc);
-    xpc.xp_context = EXPAND_FILES;
+    /* When the optional second argument is non-zero, don't remove matches
+    * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+    if (argvars[1].v_type != VAR_UNKNOWN
+				&& get_tv_number_chk(&argvars[1], &error))
+	flags |= WILD_KEEP_ALL;
     rettv->v_type = VAR_STRING;
-    rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
-				     NULL, WILD_USE_NL|WILD_SILENT, WILD_ALL);
+    if (!error)
+    {
+	ExpandInit(&xpc);
+	xpc.xp_context = EXPAND_FILES;
+	rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
+						       NULL, flags, WILD_ALL);
+    }
+    else
+	rettv->vval.v_string = NULL;
 }
 
 /*
@@ -11301,14 +11364,22 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
+    int		flags = 0;
     char_u	buf1[NUMBUFLEN];
     char_u	*file = get_tv_string_buf_chk(&argvars[1], buf1);
+    int		error = FALSE;
 
+    /* When the optional second argument is non-zero, don't remove matches
+    * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+    if (argvars[2].v_type != VAR_UNKNOWN
+				&& get_tv_number_chk(&argvars[2], &error))
+	flags |= WILD_KEEP_ALL;
     rettv->v_type = VAR_STRING;
-    if (file == NULL)
+    if (file == NULL || error)
 	rettv->vval.v_string = NULL;
     else
-	rettv->vval.v_string = globpath(get_tv_string(&argvars[0]), file);
+	rettv->vval.v_string = globpath(get_tv_string(&argvars[0]), file,
+								       flags);
 }
 
 /*
@@ -11782,6 +11853,10 @@
 	    n = has_patch(atoi((char *)name + 5));
 	else if (STRICMP(name, "vim_starting") == 0)
 	    n = (starting != 0);
+#ifdef FEAT_MBYTE
+	else if (STRICMP(name, "multi_byte_encoding") == 0)
+	    n = has_mbyte;
+#endif
 #if defined(FEAT_BEVAL) && defined(FEAT_GUI_W32)
 	else if (STRICMP(name, "balloon_multiline") == 0)
 	    n = multiline_balloon_available();
@@ -11847,7 +11922,6 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_DICT)
     {
 	EMSG(_(e_dictreq));
@@ -11863,10 +11937,9 @@
 /*
  * "haslocaldir()" function
  */
-/*ARGSUSED*/
     static void
 f_haslocaldir(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = (curwin->w_localdir != NULL);
@@ -11904,10 +11977,9 @@
 /*
  * "histadd()" function
  */
-/*ARGSUSED*/
     static void
 f_histadd(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CMDHIST
@@ -11938,11 +12010,10 @@
 /*
  * "histdel()" function
  */
-/*ARGSUSED*/
     static void
 f_histdel(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_CMDHIST
     int		n;
@@ -11964,18 +12035,15 @@
 	n = del_history_entry(get_histtype(str),
 				      get_tv_string_buf(&argvars[1], buf));
     rettv->vval.v_number = n;
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "histget()" function
  */
-/*ARGSUSED*/
     static void
 f_histget(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CMDHIST
@@ -12005,10 +12073,9 @@
 /*
  * "histnr()" function
  */
-/*ARGSUSED*/
     static void
 f_histnr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		i;
@@ -12050,10 +12117,9 @@
 /*
  * "hostname()" function
  */
-/*ARGSUSED*/
     static void
 f_hostname(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u hostname[256];
@@ -12066,10 +12132,9 @@
 /*
  * iconv() function
  */
-/*ARGSUSED*/
     static void
 f_iconv(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_MBYTE
@@ -12327,7 +12392,6 @@
     int		selected;
     int		mouse_used;
 
-    rettv->vval.v_number = 0;
 #ifdef NO_CONSOLE_INPUT
     /* While starting up, there is no place to enter text. */
     if (no_console_input())
@@ -12365,10 +12429,9 @@
 /*
  * "inputrestore()" function
  */
-/*ARGSUSED*/
     static void
 f_inputrestore(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     if (ga_userinput.ga_len > 0)
@@ -12376,7 +12439,7 @@
 	--ga_userinput.ga_len;
 	restore_typeahead((tasave_T *)(ga_userinput.ga_data)
 						       + ga_userinput.ga_len);
-	rettv->vval.v_number = 0; /* OK */
+	/* default return is zero == OK */
     }
     else if (p_verbose > 1)
     {
@@ -12388,10 +12451,9 @@
 /*
  * "inputsave()" function
  */
-/*ARGSUSED*/
     static void
 f_inputsave(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     /* Add an entry to the stack of typeahead storage. */
@@ -12400,7 +12462,7 @@
 	save_typeahead((tasave_T *)(ga_userinput.ga_data)
 						       + ga_userinput.ga_len);
 	++ga_userinput.ga_len;
-	rettv->vval.v_number = 0; /* OK */
+	/* default return is zero == OK */
     }
     else
 	rettv->vval.v_number = 1; /* Failed */
@@ -12434,7 +12496,6 @@
     list_T	*l;
     int		error = FALSE;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "insert()");
     else if ((l = argvars[0].vval.v_list) != NULL
@@ -12553,7 +12614,6 @@
     dict_T	*d;
     int		todo;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_DICT)
     {
 	EMSG(_(e_dictreq));
@@ -12641,7 +12701,6 @@
     garray_T	ga;
     char_u	*sep;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
     {
 	EMSG(_(e_listreq));
@@ -12681,10 +12740,9 @@
 /*
  * "last_buffer_nr()" function.
  */
-/*ARGSUSED*/
     static void
 f_last_buffer_nr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		n = 0;
@@ -12739,9 +12797,7 @@
 #endif
 
     rettv->v_type = type;
-    if (type == VAR_NUMBER)
-	rettv->vval.v_number = 0;
-    else
+    if (type != VAR_NUMBER)
 	rettv->vval.v_string = NULL;
 
     if (check_restricted() || check_secure())
@@ -12813,10 +12869,9 @@
 /*
  * "line2byte(lnum)" function
  */
-/*ARGSUSED*/
     static void
 f_line2byte(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifndef FEAT_BYTEOFF
@@ -12862,10 +12917,9 @@
 /*
  * "localtime()" function
  */
-/*ARGSUSED*/
     static void
 f_localtime(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = (varnumber_T)time(NULL);
@@ -13447,7 +13501,6 @@
 /*
  * "mode()" function
  */
-/*ARGSUSED*/
     static void
 f_mode(argvars, rettv)
     typval_T	*argvars;
@@ -13676,13 +13729,11 @@
 /*
  * "pumvisible()" function
  */
-/*ARGSUSED*/
     static void
 f_pumvisible(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-    rettv->vval.v_number = 0;
 #ifdef FEAT_INS_EXPAND
     if (pum_visible())
 	rettv->vval.v_number = 1;
@@ -13716,7 +13767,6 @@
 	    stride = get_tv_number_chk(&argvars[2], &error);
     }
 
-    rettv->vval.v_number = 0;
     if (error)
 	return;		/* type error; errmsg already given */
     if (stride == 0)
@@ -14083,10 +14133,9 @@
 /*
  * "remote_expr()" function
  */
-/*ARGSUSED*/
     static void
 f_remote_expr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -14099,13 +14148,11 @@
 /*
  * "remote_foreground()" function
  */
-/*ARGSUSED*/
     static void
 f_remote_foreground(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-    rettv->vval.v_number = 0;
 #ifdef FEAT_CLIENTSERVER
 # ifdef WIN32
     /* On Win32 it's done in this application. */
@@ -14126,10 +14173,9 @@
 #endif
 }
 
-/*ARGSUSED*/
     static void
 f_remote_peek(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CLIENTSERVER
@@ -14161,7 +14207,6 @@
 	rettv->vval.v_number = (s != NULL);
     }
 # else
-    rettv->vval.v_number = 0;
     if (check_connection() == FAIL)
 	return;
 
@@ -14185,10 +14230,9 @@
 #endif
 }
 
-/*ARGSUSED*/
     static void
 f_remote_read(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*r = NULL;
@@ -14220,10 +14264,9 @@
 /*
  * "remote_send()" function
  */
-/*ARGSUSED*/
     static void
 f_remote_send(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -14250,7 +14293,6 @@
     dict_T	*d;
     dictitem_T	*di;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_DICT)
     {
 	if (argvars[2].v_type != VAR_UNKNOWN)
@@ -14353,7 +14395,6 @@
 /*
  * "repeat()" function
  */
-/*ARGSUSED*/
     static void
 f_repeat(argvars, rettv)
     typval_T	*argvars;
@@ -14608,7 +14649,6 @@
     list_T	*l;
     listitem_T	*li, *ni;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "reverse()");
     else if ((l = argvars[0].vval.v_list) != NULL
@@ -14960,8 +15000,6 @@
     int		lnum = 0;
     int		col = 0;
 
-    rettv->vval.v_number = 0;
-
     if (rettv_list_alloc(rettv) == FAIL)
 	return;
 
@@ -15148,8 +15186,6 @@
     int		n;
     int		flags = 0;
 
-    rettv->vval.v_number = 0;
-
     if (rettv_list_alloc(rettv) == FAIL)
 	return;
 
@@ -15167,10 +15203,9 @@
 }
 
 
-/*ARGSUSED*/
     static void
 f_server2client(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CLIENTSERVER
@@ -15199,10 +15234,9 @@
 #endif
 }
 
-/*ARGSUSED*/
     static void
 f_serverlist(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*r = NULL;
@@ -15223,11 +15257,10 @@
 /*
  * "setbufvar()" function
  */
-/*ARGSUSED*/
     static void
 f_setbufvar(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     buf_T	*buf;
     aco_save_T	aco;
@@ -15235,8 +15268,6 @@
     typval_T	*varp;
     char_u	nbuf[NUMBUFLEN];
 
-    rettv->vval.v_number = 0;
-
     if (check_restricted() || check_secure())
 	return;
     (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
@@ -15316,7 +15347,7 @@
     else
 	line = get_tv_string_chk(&argvars[1]);
 
-    rettv->vval.v_number = 0;		/* OK */
+    /* default result is zero == OK */
     for (;;)
     {
 	if (l != NULL)
@@ -15364,12 +15395,11 @@
 /*
  * Used by "setqflist()" and "setloclist()" functions
  */
-/*ARGSUSED*/
     static void
 set_qf_ll_list(wp, list_arg, action_arg, rettv)
-    win_T	*wp;
-    typval_T	*list_arg;
-    typval_T	*action_arg;
+    win_T	*wp UNUSED;
+    typval_T	*list_arg UNUSED;
+    typval_T	*action_arg UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_QUICKFIX
@@ -15404,7 +15434,6 @@
 /*
  * "setloclist()" function
  */
-/*ARGSUSED*/
     static void
 f_setloclist(argvars, rettv)
     typval_T	*argvars;
@@ -15482,7 +15511,6 @@
 /*
  * "setpos()" function
  */
-/*ARGSUSED*/
     static void
 f_setpos(argvars, rettv)
     typval_T	*argvars;
@@ -15526,7 +15554,6 @@
 /*
  * "setqflist()" function
  */
-/*ARGSUSED*/
     static void
 f_setqflist(argvars, rettv)
     typval_T	*argvars;
@@ -15632,7 +15659,7 @@
     static void
 setwinvar(argvars, rettv, off)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
     int		off;
 {
     win_T	*win;
@@ -15645,8 +15672,6 @@
     char_u	nbuf[NUMBUFLEN];
     tabpage_T	*tp;
 
-    rettv->vval.v_number = 0;
-
     if (check_restricted() || check_secure())
 	return;
 
@@ -15838,10 +15863,9 @@
     if (res == FAIL)
 	res = ITEM_COMPARE_FAIL;
     else
-	/* return value has wrong type */
 	res = get_tv_number_chk(&rettv, &item_compare_func_err);
     if (item_compare_func_err)
-	res = ITEM_COMPARE_FAIL;
+	res = ITEM_COMPARE_FAIL;  /* return value has wrong type */
     clear_tv(&rettv);
     return res;
 }
@@ -15860,7 +15884,6 @@
     long	len;
     long	i;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "sort()");
     else
@@ -15952,10 +15975,9 @@
 /*
  * "spellbadword()" function
  */
-/* ARGSUSED */
     static void
 f_spellbadword(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*word = (char_u *)"";
@@ -16007,10 +16029,9 @@
 /*
  * "spellsuggest()" function
  */
-/*ARGSUSED*/
     static void
 f_spellsuggest(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_SPELL
@@ -16493,10 +16514,9 @@
 /*
  * "synID(lnum, col, trans)" function
  */
-/*ARGSUSED*/
     static void
 f_synID(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		id = 0;
@@ -16521,10 +16541,9 @@
 /*
  * "synIDattr(id, what [, mode])" function
  */
-/*ARGSUSED*/
     static void
 f_synIDattr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*p = NULL;
@@ -16590,8 +16609,11 @@
 		p = highlight_has_attr(id, HL_INVERSE, modec);
 		break;
 
-	case 's':					/* standout */
-		p = highlight_has_attr(id, HL_STANDOUT, modec);
+	case 's':
+		if (TOLOWER_ASC(what[1]) == 'p')	/* sp[#] */
+		    p = highlight_color(id, what, modec);
+		else					/* standout */
+		    p = highlight_has_attr(id, HL_STANDOUT, modec);
 		break;
 
 	case 'u':
@@ -16614,10 +16636,9 @@
 /*
  * "synIDtrans(id)" function
  */
-/*ARGSUSED*/
     static void
 f_synIDtrans(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		id;
@@ -16637,10 +16658,9 @@
 /*
  * "synstack(lnum, col)" function
  */
-/*ARGSUSED*/
     static void
 f_synstack(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_SYN_HL
@@ -16658,7 +16678,7 @@
     col = get_tv_number(&argvars[1]) - 1;	/* -1 on type error */
 
     if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
-	    && col >= 0 && col < (long)STRLEN(ml_get(lnum))
+	    && col >= 0 && (col == 0 || col < (long)STRLEN(ml_get(lnum)))
 	    && rettv_list_alloc(rettv) != FAIL)
     {
 	(void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL, TRUE);
@@ -16774,15 +16794,12 @@
 /*
  * "tabpagebuflist()" function
  */
-/* ARGSUSED */
     static void
 f_tabpagebuflist(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-#ifndef FEAT_WINDOWS
-    rettv->vval.v_number = 0;
-#else
+#ifdef FEAT_WINDOWS
     tabpage_T	*tp;
     win_T	*wp = NULL;
 
@@ -16794,19 +16811,12 @@
 	if (tp != NULL)
 	    wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
     }
-    if (wp == NULL)
-	rettv->vval.v_number = 0;
-    else
+    if (wp != NULL && rettv_list_alloc(rettv) != FAIL)
     {
-	if (rettv_list_alloc(rettv) == FAIL)
-	    rettv->vval.v_number = 0;
-	else
-	{
-	    for (; wp != NULL; wp = wp->w_next)
-		if (list_append_number(rettv->vval.v_list,
+	for (; wp != NULL; wp = wp->w_next)
+	    if (list_append_number(rettv->vval.v_list,
 						wp->w_buffer->b_fnum) == FAIL)
-		    break;
-	}
+		break;
     }
 #endif
 }
@@ -16815,10 +16825,9 @@
 /*
  * "tabpagenr()" function
  */
-/* ARGSUSED */
     static void
 f_tabpagenr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		nr = 1;
@@ -16900,10 +16909,9 @@
 /*
  * "tabpagewinnr()" function
  */
-/* ARGSUSED */
     static void
 f_tabpagewinnr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		nr = 1;
@@ -16923,10 +16931,9 @@
 /*
  * "tagfiles()" function
  */
-/*ARGSUSED*/
     static void
 f_tagfiles(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	fname[MAXPATHL + 1];
@@ -16934,10 +16941,7 @@
     int		first;
 
     if (rettv_list_alloc(rettv) == FAIL)
-    {
-	rettv->vval.v_number = 0;
 	return;
-    }
 
     for (first = TRUE; ; first = FALSE)
 	if (get_tagfname(&tn, first, fname) == FAIL
@@ -16969,10 +16973,9 @@
 /*
  * "tempname()" function
  */
-/*ARGSUSED*/
     static void
 f_tempname(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     static int	x = 'A';
@@ -17005,11 +17008,10 @@
 /*
  * "test(list)" function: Just checking the walls...
  */
-/*ARGSUSED*/
     static void
 f_test(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
     /* Used for unit testing.  Change the code below to your liking. */
 #if 0
@@ -17294,11 +17296,10 @@
 /*
  * "visualmode()" function
  */
-/*ARGSUSED*/
     static void
 f_visualmode(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_VISUAL
     char_u	str[2];
@@ -17311,8 +17312,6 @@
     /* A non-zero number or non-empty string argument: reset mode. */
     if (non_zero_arg(&argvars[0]))
 	curbuf->b_visual_mode_eval = NUL;
-#else
-    rettv->vval.v_number = 0; /* return anything, it won't work anyway */
 #endif
 }
 
@@ -17336,10 +17335,9 @@
 /*
  * "wincol()" function
  */
-/*ARGSUSED*/
     static void
 f_wincol(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     validate_cursor();
@@ -17366,10 +17364,9 @@
 /*
  * "winline()" function
  */
-/*ARGSUSED*/
     static void
 f_winline(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     validate_cursor();
@@ -17379,10 +17376,9 @@
 /*
  * "winnr()" function
  */
-/* ARGSUSED */
     static void
 f_winnr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		nr = 1;
@@ -17396,10 +17392,9 @@
 /*
  * "winrestcmd()" function
  */
-/* ARGSUSED */
     static void
 f_winrestcmd(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_WINDOWS
@@ -17431,11 +17426,10 @@
 /*
  * "winrestview()" function
  */
-/* ARGSUSED */
     static void
 f_winrestview(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     dict_T	*dict;
 
@@ -17477,10 +17471,9 @@
 /*
  * "winsaveview()" function
  */
-/* ARGSUSED */
     static void
 f_winsaveview(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     dict_T	*dict;
@@ -18097,14 +18090,28 @@
 }
 
 /*
- * Set v:count, v:count1 and v:prevcount.
+ * Get List v: variable value.  Caller must take care of reference count when
+ * needed.
+ */
+    list_T *
+get_vim_var_list(idx)
+    int		idx;
+{
+    return vimvars[idx].vv_list;
+}
+
+/*
+ * Set v:count to "count" and v:count1 to "count1".
+ * When "set_prevcount" is TRUE first set v:prevcount from v:count.
  */
     void
-set_vcount(count, count1)
+set_vcount(count, count1, set_prevcount)
     long	count;
     long	count1;
+    int		set_prevcount;
 {
-    vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
+    if (set_prevcount)
+	vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
     vimvars[VV_COUNT].vv_nr = count;
     vimvars[VV_COUNT1].vv_nr = count1;
 }
@@ -18132,6 +18139,20 @@
 }
 
 /*
+ * Set List v: variable to "val".
+ */
+    void
+set_vim_var_list(idx, val)
+    int		idx;
+    list_T	*val;
+{
+    list_unref(vimvars[idx].vv_list);
+    vimvars[idx].vv_list = val;
+    if (val != NULL)
+	++val->lv_refcount;
+}
+
+/*
  * Set v:register if needed.
  */
     void
@@ -18868,7 +18889,8 @@
     dictitem_T	*dict_var;
 {
     hash_init(&dict->dv_hashtab);
-    dict->dv_refcount = 99999;
+    dict->dv_refcount = DO_NOT_FREE_CNT;
+    dict->dv_copyID = 0;
     dict_var->di_tv.vval.v_dict = dict;
     dict_var->di_tv.v_type = VAR_DICT;
     dict_var->di_tv.v_lock = VAR_FIXED;
@@ -18951,7 +18973,8 @@
     char_u	*s;
     char_u	numbuf[NUMBUFLEN];
 
-    s = echo_string(&v->di_tv, &tofree, numbuf, ++current_copyID);
+    current_copyID += COPYID_INC;
+    s = echo_string(&v->di_tv, &tofree, numbuf, current_copyID);
     list_one_var_a(prefix, v->di_key, v->di_tv.v_type,
 					 s == NULL ? (char_u *)"" : s, first);
     vim_free(tofree);
@@ -19205,6 +19228,8 @@
  * Copy the values from typval_T "from" to typval_T "to".
  * When needed allocates string or increases reference count.
  * Does not make a copy of a list or dict but copies the reference!
+ * It is OK for "from" and "to" to point to the same item.  This is used to
+ * make a copy later.
  */
     static void
 copy_tv(from, to)
@@ -19384,7 +19409,8 @@
 	    }
 	    else if (eap->cmdidx == CMD_echo)
 		msg_puts_attr((char_u *)" ", echo_attr);
-	    p = echo_string(&rettv, &tofree, numbuf, ++current_copyID);
+	    current_copyID += COPYID_INC;
+	    p = echo_string(&rettv, &tofree, numbuf, current_copyID);
 	    if (p != NULL)
 		for ( ; *p != NUL && !got_int; ++p)
 		{
@@ -19660,6 +19686,7 @@
 			    list_func_head(fp, FALSE);
 		    }
 		}
+		vim_free(regmatch.regprog);
 	    }
 	}
 	if (*p == '/')
@@ -19748,7 +19775,7 @@
 		}
 	    }
 	    else
-		emsg_funcname("E123: Undefined function: %s", name);
+		emsg_funcname(N_("E123: Undefined function: %s"), name);
 	}
 	goto ret_free;
     }
@@ -19792,7 +19819,7 @@
 						      : eval_isnamec(arg[j])))
 		++j;
 	    if (arg[j] != NUL)
-		emsg_funcname(_(e_invarg2), arg);
+		emsg_funcname((char *)e_invarg2, arg);
 	}
     }
 
@@ -20064,7 +20091,7 @@
 	v = find_var(name, &ht);
 	if (v != NULL && v->di_tv.v_type == VAR_FUNC)
 	{
-	    emsg_funcname("E707: Function name conflicts with variable: %s",
+	    emsg_funcname(N_("E707: Function name conflicts with variable: %s"),
 									name);
 	    goto erret;
 	}
@@ -20079,7 +20106,7 @@
 	    }
 	    if (fp->uf_calls > 0)
 	    {
-		emsg_funcname("E127: Cannot redefine function %s: It is in use",
+		emsg_funcname(N_("E127: Cannot redefine function %s: It is in use"),
 									name);
 		goto erret;
 	    }
@@ -20590,6 +20617,9 @@
     int		st_len = 0;
 
     todo = (int)func_hashtab.ht_used;
+    if (todo == 0)
+	return;     /* nothing to dump */
+
     sorttab = (ufunc_T **)alloc((unsigned)(sizeof(ufunc_T) * todo));
 
     for (hi = func_hashtab.ht_array; todo > 0; ++hi)
@@ -20638,6 +20668,8 @@
 							      prof_self_cmp);
 	prof_sort_list(fd, sorttab, st_len, "SELF", TRUE);
     }
+
+    vim_free(sorttab);
 }
 
     static void
@@ -21012,7 +21044,7 @@
     char_u	*save_sourcing_name;
     linenr_T	save_sourcing_lnum;
     scid_T	save_current_SID;
-    funccall_T	fc;
+    funccall_T	*fc;
     int		save_did_emsg;
     static int	depth = 0;
     dictitem_T	*v;
@@ -21038,36 +21070,37 @@
 
     line_breakcheck();		/* check for CTRL-C hit */
 
-    fc.caller = current_funccal;
-    current_funccal = &fc;
-    fc.func = fp;
-    fc.rettv = rettv;
+    fc = (funccall_T *)alloc(sizeof(funccall_T));
+    fc->caller = current_funccal;
+    current_funccal = fc;
+    fc->func = fp;
+    fc->rettv = rettv;
     rettv->vval.v_number = 0;
-    fc.linenr = 0;
-    fc.returned = FALSE;
-    fc.level = ex_nesting_level;
+    fc->linenr = 0;
+    fc->returned = FALSE;
+    fc->level = ex_nesting_level;
     /* Check if this function has a breakpoint. */
-    fc.breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);
-    fc.dbg_tick = debug_tick;
+    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);
+    fc->dbg_tick = debug_tick;
 
     /*
-     * Note about using fc.fixvar[]: This is an array of FIXVAR_CNT variables
+     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables
      * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free
      * each argument variable and saves a lot of time.
      */
     /*
      * Init l: variables.
      */
-    init_var_dict(&fc.l_vars, &fc.l_vars_var);
+    init_var_dict(&fc->l_vars, &fc->l_vars_var);
     if (selfdict != NULL)
     {
 	/* Set l:self to "selfdict".  Use "name" to avoid a warning from
 	 * some compiler that checks the destination size. */
-	v = &fc.fixvar[fixvar_idx++].var;
+	v = &fc->fixvar[fixvar_idx++].var;
 	name = v->di_key;
 	STRCPY(name, "self");
 	v->di_flags = DI_FLAGS_RO + DI_FLAGS_FIX;
-	hash_add(&fc.l_vars.dv_hashtab, DI2HIKEY(v));
+	hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));
 	v->di_tv.v_type = VAR_DICT;
 	v->di_tv.v_lock = 0;
 	v->di_tv.vval.v_dict = selfdict;
@@ -21079,28 +21112,31 @@
      * Set a:0 to "argcount".
      * Set a:000 to a list with room for the "..." arguments.
      */
-    init_var_dict(&fc.l_avars, &fc.l_avars_var);
-    add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "0",
+    init_var_dict(&fc->l_avars, &fc->l_avars_var);
+    add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "0",
 				(varnumber_T)(argcount - fp->uf_args.ga_len));
-    v = &fc.fixvar[fixvar_idx++].var;
-    STRCPY(v->di_key, "000");
+    /* Use "name" to avoid a warning from some compiler that checks the
+     * destination size. */
+    v = &fc->fixvar[fixvar_idx++].var;
+    name = v->di_key;
+    STRCPY(name, "000");
     v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
-    hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
+    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));
     v->di_tv.v_type = VAR_LIST;
     v->di_tv.v_lock = VAR_FIXED;
-    v->di_tv.vval.v_list = &fc.l_varlist;
-    vim_memset(&fc.l_varlist, 0, sizeof(list_T));
-    fc.l_varlist.lv_refcount = 99999;
-    fc.l_varlist.lv_lock = VAR_FIXED;
+    v->di_tv.vval.v_list = &fc->l_varlist;
+    vim_memset(&fc->l_varlist, 0, sizeof(list_T));
+    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;
+    fc->l_varlist.lv_lock = VAR_FIXED;
 
     /*
      * Set a:firstline to "firstline" and a:lastline to "lastline".
      * Set a:name to named arguments.
      * Set a:N to the "..." arguments.
      */
-    add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "firstline",
+    add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "firstline",
 						      (varnumber_T)firstline);
-    add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "lastline",
+    add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "lastline",
 						       (varnumber_T)lastline);
     for (i = 0; i < argcount; ++i)
     {
@@ -21116,7 +21152,7 @@
 	}
 	if (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)
 	{
-	    v = &fc.fixvar[fixvar_idx++].var;
+	    v = &fc->fixvar[fixvar_idx++].var;
 	    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
 	}
 	else
@@ -21128,7 +21164,7 @@
 	    v->di_flags = DI_FLAGS_RO;
 	}
 	STRCPY(v->di_key, name);
-	hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
+	hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));
 
 	/* Note: the values are copied directly to avoid alloc/free.
 	 * "argvars" must have VAR_FIXED for v_lock. */
@@ -21137,9 +21173,9 @@
 
 	if (ai >= 0 && ai < MAX_FUNC_ARGS)
 	{
-	    list_append(&fc.l_varlist, &fc.l_listitems[ai]);
-	    fc.l_listitems[ai].li_tv = argvars[i];
-	    fc.l_listitems[ai].li_tv.v_lock = VAR_FIXED;
+	    list_append(&fc->l_varlist, &fc->l_listitems[ai]);
+	    fc->l_listitems[ai].li_tv = argvars[i];
+	    fc->l_listitems[ai].li_tv.v_lock = VAR_FIXED;
 	}
     }
 
@@ -21204,7 +21240,7 @@
 	if (!fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL))
 	    func_do_profile(fp);
 	if (fp->uf_profiling
-		       || (fc.caller != NULL && &fc.caller->func->uf_profiling))
+		    || (fc->caller != NULL && fc->caller->func->uf_profiling))
 	{
 	    ++fp->uf_tm_count;
 	    profile_start(&call_start);
@@ -21220,7 +21256,7 @@
     did_emsg = FALSE;
 
     /* call do_cmdline() to execute the lines */
-    do_cmdline(NULL, get_func_line, (void *)&fc,
+    do_cmdline(NULL, get_func_line, (void *)fc,
 				     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);
 
     --RedrawingDisabled;
@@ -21235,16 +21271,16 @@
 
 #ifdef FEAT_PROFILE
     if (do_profiling == PROF_YES && (fp->uf_profiling
-		    || (fc.caller != NULL && &fc.caller->func->uf_profiling)))
+		    || (fc->caller != NULL && fc->caller->func->uf_profiling)))
     {
 	profile_end(&call_start);
 	profile_sub_wait(&wait_start, &call_start);
 	profile_add(&fp->uf_tm_total, &call_start);
 	profile_self(&fp->uf_tm_self, &call_start, &fp->uf_tm_children);
-	if (fc.caller != NULL && &fc.caller->func->uf_profiling)
+	if (fc->caller != NULL && fc->caller->func->uf_profiling)
 	{
-	    profile_add(&fc.caller->func->uf_tm_children, &call_start);
-	    profile_add(&fc.caller->func->uf_tml_children, &call_start);
+	    profile_add(&fc->caller->func->uf_tm_children, &call_start);
+	    profile_add(&fc->caller->func->uf_tml_children, &call_start);
 	}
     }
 #endif
@@ -21257,9 +21293,9 @@
 
 	if (aborting())
 	    smsg((char_u *)_("%s aborted"), sourcing_name);
-	else if (fc.rettv->v_type == VAR_NUMBER)
+	else if (fc->rettv->v_type == VAR_NUMBER)
 	    smsg((char_u *)_("%s returning #%ld"), sourcing_name,
-					       (long)fc.rettv->vval.v_number);
+					       (long)fc->rettv->vval.v_number);
 	else
 	{
 	    char_u	buf[MSG_BUF_LEN];
@@ -21270,7 +21306,7 @@
 	    /* The value may be very long.  Skip the middle part, so that we
 	     * have some idea how it starts and ends. smsg() would always
 	     * truncate it at the end. */
-	    s = tv2string(fc.rettv, &tofree, numbuf2, 0);
+	    s = tv2string(fc->rettv, &tofree, numbuf2, 0);
 	    if (s != NULL)
 	    {
 		trunc_string(s, buf, MSG_BUF_CLEN);
@@ -21306,14 +21342,84 @@
     }
 
     did_emsg |= save_did_emsg;
-    current_funccal = fc.caller;
+    current_funccal = fc->caller;
+    --depth;
 
-    /* The a: variables typevals were not allocated, only free the allocated
-     * variables. */
-    vars_clear_ext(&fc.l_avars.dv_hashtab, FALSE);
+    /* If the a:000 list and the l: and a: dicts are not referenced we can
+     * free the funccall_T and what's in it. */
+    if (fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT
+	    && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT
+	    && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)
+    {
+	free_funccal(fc, FALSE);
+    }
+    else
+    {
+	hashitem_T	*hi;
+	listitem_T	*li;
+	int		todo;
 
-    vars_clear(&fc.l_vars.dv_hashtab);		/* free all l: variables */
-    --depth;
+	/* "fc" is still in use.  This can happen when returning "a:000" or
+	 * assigning "l:" to a global variable.
+	 * Link "fc" in the list for garbage collection later. */
+	fc->caller = previous_funccal;
+	previous_funccal = fc;
+
+	/* Make a copy of the a: variables, since we didn't do that above. */
+	todo = (int)fc->l_avars.dv_hashtab.ht_used;
+	for (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)
+	{
+	    if (!HASHITEM_EMPTY(hi))
+	    {
+		--todo;
+		v = HI2DI(hi);
+		copy_tv(&v->di_tv, &v->di_tv);
+	    }
+	}
+
+	/* Make a copy of the a:000 items, since we didn't do that above. */
+	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
+	    copy_tv(&li->li_tv, &li->li_tv);
+    }
+}
+
+/*
+ * Return TRUE if items in "fc" do not have "copyID".  That means they are not
+ * referenced from anywhere that is in use.
+ */
+    static int
+can_free_funccal(fc, copyID)
+    funccall_T	*fc;
+    int		copyID;
+{
+    return (fc->l_varlist.lv_copyID != copyID
+	    && fc->l_vars.dv_copyID != copyID
+	    && fc->l_avars.dv_copyID != copyID);
+}
+
+/*
+ * Free "fc" and what it contains.
+ */
+   static void
+free_funccal(fc, free_val)
+    funccall_T	*fc;
+    int		free_val;  /* a: vars were allocated */
+{
+    listitem_T	*li;
+
+    /* The a: variables typevals may not have been allocated, only free the
+     * allocated variables. */
+    vars_clear_ext(&fc->l_avars.dv_hashtab, free_val);
+
+    /* free all l: variables */
+    vars_clear(&fc->l_vars.dv_hashtab);
+
+    /* Free the a:000 variables if they were allocated. */
+    if (free_val)
+	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
+	    clear_tv(&li->li_tv);
+
+    vim_free(fc);
 }
 
 /*
@@ -21512,12 +21618,11 @@
  * Called by do_cmdline() to get the next line.
  * Returns allocated string, or NULL for end of function.
  */
-/* ARGSUSED */
     char_u *
 get_func_line(c, cookie, indent)
-    int	    c;		    /* not used */
+    int	    c UNUSED;
     void    *cookie;
-    int	    indent;	    /* not used */
+    int	    indent UNUSED;
 {
     funccall_T	*fcp = (funccall_T *)cookie;
     ufunc_T	*fp = fcp->func;
@@ -21886,6 +21991,61 @@
     }
 }
 
+/*
+ * List v:oldfiles in a nice way.
+ */
+    void
+ex_oldfiles(eap)
+    exarg_T	*eap UNUSED;
+{
+    list_T	*l = vimvars[VV_OLDFILES].vv_list;
+    listitem_T	*li;
+    int		nr = 0;
+
+    if (l == NULL)
+	msg((char_u *)_("No old files"));
+    else
+    {
+	msg_start();
+	msg_scroll = TRUE;
+	for (li = l->lv_first; li != NULL && !got_int; li = li->li_next)
+	{
+	    msg_outnum((long)++nr);
+	    MSG_PUTS(": ");
+	    msg_outtrans(get_tv_string(&li->li_tv));
+	    msg_putchar('\n');
+	    out_flush();	    /* output one line at a time */
+	    ui_breakcheck();
+	}
+	/* Assume "got_int" was set to truncate the listing. */
+	got_int = FALSE;
+
+#ifdef FEAT_BROWSE_CMD
+	if (cmdmod.browse)
+	{
+	    quit_more = FALSE;
+	    nr = prompt_for_number(FALSE);
+	    msg_starthere();
+	    if (nr > 0)
+	    {
+		char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),
+								    (long)nr);
+
+		if (p != NULL)
+		{
+		    p = expand_env_save(p);
+		    eap->arg = p;
+		    eap->cmdidx = CMD_edit;
+		    cmdmod.browse = FALSE;
+		    do_exedit(eap, NULL);
+		    vim_free(p);
+		}
+	    }
+	}
+#endif
+    }
+}
+
 #endif /* FEAT_EVAL */
 
 
diff -Naur vim72.orig/src/ex_cmds2.c vim72/src/ex_cmds2.c
--- vim72.orig/src/ex_cmds2.c	2008-07-13 09:18:22.000000000 -0700
+++ vim72/src/ex_cmds2.c	2009-06-05 14:25:09.000000000 -0700
@@ -28,7 +28,8 @@
 {
     char_u	*sn_name;
 # ifdef UNIX
-    int		sn_dev;
+    int		sn_dev_valid;
+    dev_t	sn_dev;
     ino_t	sn_ino;
 # endif
 # ifdef FEAT_PROFILE
@@ -2842,6 +2843,7 @@
     linenr_T		    save_sourcing_lnum;
     char_u		    *p;
     char_u		    *fname_exp;
+    char_u		    *firstline = NULL;
     int			    retval = FAIL;
 #ifdef FEAT_EVAL
     scid_T		    save_current_SID;
@@ -2992,23 +2994,6 @@
 
     cookie.level = ex_nesting_level;
 #endif
-#ifdef FEAT_MBYTE
-    cookie.conv.vc_type = CONV_NONE;		/* no conversion */
-
-    /* Try reading the first few bytes to check for a UTF-8 BOM. */
-    {
-	char_u	    buf[3];
-
-	if (fread((char *)buf, sizeof(char_u), (size_t)3, cookie.fp)
-								  == (size_t)3
-		&& buf[0] == 0xef && buf[1] == 0xbb && buf[2] == 0xbf)
-	    /* Found BOM, setup conversion and skip over it. */
-	    convert_setup(&cookie.conv, (char_u *)"utf-8", p_enc);
-	else
-	    /* No BOM found, rewind. */
-	    fseek(cookie.fp, 0L, SEEK_SET);
-    }
-#endif
 
     /*
      * Keep the sourcing name/lnum, for recursive calls.
@@ -3018,6 +3003,27 @@
     save_sourcing_lnum = sourcing_lnum;
     sourcing_lnum = 0;
 
+#ifdef FEAT_MBYTE
+    cookie.conv.vc_type = CONV_NONE;		/* no conversion */
+
+    /* Read the first line so we can check for a UTF-8 BOM. */
+    firstline = getsourceline(0, (void *)&cookie, 0);
+    if (firstline != NULL && STRLEN(firstline) >= 3 && firstline[0] == 0xef
+			      && firstline[1] == 0xbb && firstline[2] == 0xbf)
+    {
+	/* Found BOM; setup conversion, skip over BOM and recode the line. */
+	convert_setup(&cookie.conv, (char_u *)"utf-8", p_enc);
+	p = string_convert(&cookie.conv, firstline + 3, NULL);
+	if (p == NULL)
+	    p = vim_strsave(firstline + 3);
+	if (p != NULL)
+	{
+	    vim_free(firstline);
+	    firstline = p;
+	}
+    }
+#endif
+
 #ifdef STARTUPTIME
     time_push(&tv_rel, &tv_start);
 #endif
@@ -3049,7 +3055,7 @@
 		    /* Compare dev/ino when possible, it catches symbolic
 		     * links.  Also compare file names, the inode may change
 		     * when the file was edited. */
-		    ((stat_ok && si->sn_dev != -1)
+		    ((stat_ok && si->sn_dev_valid)
 			&& (si->sn_dev == st.st_dev
 			    && si->sn_ino == st.st_ino)) ||
 # endif
@@ -3076,11 +3082,12 @@
 # ifdef UNIX
 	if (stat_ok)
 	{
+	    si->sn_dev_valid = TRUE;
 	    si->sn_dev = st.st_dev;
 	    si->sn_ino = st.st_ino;
 	}
 	else
-	    si->sn_dev = -1;
+	    si->sn_dev_valid = FALSE;
 # endif
 
 	/* Allocate the local script variables to use for this script. */
@@ -3111,9 +3118,8 @@
     /*
      * Call do_cmdline, which will call getsourceline() to get the lines.
      */
-    do_cmdline(NULL, getsourceline, (void *)&cookie,
+    do_cmdline(firstline, getsourceline, (void *)&cookie,
 				     DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_REPEAT);
-
     retval = OK;
 
 #ifdef FEAT_PROFILE
@@ -3145,8 +3151,8 @@
 	verbose_leave();
     }
 #ifdef STARTUPTIME
-    vim_snprintf(IObuff, IOSIZE, "sourcing %s", fname);
-    time_msg(IObuff, &tv_start);
+    vim_snprintf((char *)IObuff, IOSIZE, "sourcing %s", fname);
+    time_msg((char *)IObuff, &tv_start);
     time_pop(&tv_rel);
 #endif
 
@@ -3171,6 +3177,7 @@
 #endif
     fclose(cookie.fp);
     vim_free(cookie.nextline);
+    vim_free(firstline);
 #ifdef FEAT_MBYTE
     convert_setup(&cookie.conv, NULL, NULL);
 #endif
@@ -3368,7 +3375,7 @@
 	    p = skipwhite(sp->nextline);
 	    if (*p != '\\')
 		break;
-	    s = alloc((int)(STRLEN(line) + STRLEN(p)));
+	    s = alloc((unsigned)(STRLEN(line) + STRLEN(p)));
 	    if (s == NULL)	/* out of memory */
 		break;
 	    STRCPY(s, line);
diff -Naur vim72.orig/src/ex_cmds.c vim72/src/ex_cmds.c
--- vim72.orig/src/ex_cmds.c	2008-08-04 12:15:00.000000000 -0700
+++ vim72/src/ex_cmds.c	2009-06-05 14:25:15.000000000 -0700
@@ -24,7 +24,7 @@
 static void do_filter __ARGS((linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out));
 #ifdef FEAT_VIMINFO
 static char_u *viminfo_filename __ARGS((char_u	*));
-static void do_viminfo __ARGS((FILE *fp_in, FILE *fp_out, int want_info, int want_marks, int force_read));
+static void do_viminfo __ARGS((FILE *fp_in, FILE *fp_out, int flags));
 static int viminfo_encoding __ARGS((vir_T *virp));
 static int read_viminfo_up_to_marks __ARGS((vir_T *virp, int forceit, int writing));
 #endif
@@ -49,6 +49,7 @@
     exarg_T	*eap;
 {
     int		c;
+    int		cval;
     char	buf1[20];
     char	buf2[20];
     char_u	buf3[7];
@@ -75,6 +76,10 @@
     {
 	if (c == NL)	    /* NUL is stored as NL */
 	    c = NUL;
+	if (c == CAR && get_fileformat(curbuf) == EOL_MAC)
+	    cval = NL;	    /* NL is stored as CR */
+	else
+	    cval = c;
 	if (vim_isprintc_strict(c) && (c < ' '
 #ifndef EBCDIC
 		    || c > '~'
@@ -82,19 +87,20 @@
 			       ))
 	{
 	    transchar_nonprint(buf3, c);
-	    sprintf(buf1, "  <%s>", (char *)buf3);
+	    vim_snprintf(buf1, sizeof(buf1), "  <%s>", (char *)buf3);
 	}
 	else
 	    buf1[0] = NUL;
 #ifndef EBCDIC
 	if (c >= 0x80)
-	    sprintf(buf2, "  <M-%s>", transchar(c & 0x7f));
+	    vim_snprintf(buf2, sizeof(buf2), "  <M-%s>",
+						 (char *)transchar(c & 0x7f));
 	else
 #endif
 	    buf2[0] = NUL;
 	vim_snprintf((char *)IObuff, IOSIZE,
 		_("<%s>%s%s  %d,  Hex %02x,  Octal %03o"),
-					   transchar(c), buf1, buf2, c, c, c);
+				  transchar(c), buf1, buf2, cval, cval, cval);
 #ifdef FEAT_MBYTE
 	if (enc_utf8)
 	    c = cc[ci++];
@@ -353,7 +359,7 @@
     linenr_T	lnum;
     long	maxlen = 0;
     sorti_T	*nrs;
-    size_t	count = eap->line2 - eap->line1 + 1;
+    size_t	count = (size_t)(eap->line2 - eap->line1 + 1);
     size_t	i;
     char_u	*p;
     char_u	*s;
@@ -952,7 +958,7 @@
 	    }
 	    len += (int)STRLEN(prevcmd);
 	}
-	if ((t = alloc(len)) == NULL)
+	if ((t = alloc((unsigned)len)) == NULL)
 	{
 	    vim_free(newcmd);
 	    return;
@@ -1543,7 +1549,7 @@
      * redirecting input and/or output.
      */
     if (itmp != NULL || otmp != NULL)
-	sprintf((char *)buf, "(%s)", (char *)cmd);
+	vim_snprintf((char *)buf, len, "(%s)", (char *)cmd);
     else
 	STRCPY(buf, cmd);
     if (itmp != NULL)
@@ -1592,37 +1598,41 @@
     }
 #endif
     if (otmp != NULL)
-	append_redir(buf, p_srr, otmp);
+	append_redir(buf, (int)len, p_srr, otmp);
 
     return buf;
 }
 
 /*
- * Append output redirection for file "fname" to the end of string buffer "buf"
+ * Append output redirection for file "fname" to the end of string buffer
+ * "buf[buflen]"
  * Works with the 'shellredir' and 'shellpipe' options.
  * The caller should make sure that there is enough room:
  *	STRLEN(opt) + STRLEN(fname) + 3
  */
     void
-append_redir(buf, opt, fname)
+append_redir(buf, buflen, opt, fname)
     char_u	*buf;
+    int		buflen;
     char_u	*opt;
     char_u	*fname;
 {
     char_u	*p;
+    char_u	*end;
 
-    buf += STRLEN(buf);
+    end = buf + STRLEN(buf);
     /* find "%s", skipping "%%" */
     for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)
 	if (p[1] == 's')
 	    break;
     if (p != NULL)
     {
-	*buf = ' '; /* not really needed? Not with sh, ksh or bash */
-	sprintf((char *)buf + 1, (char *)opt, (char *)fname);
+	*end = ' '; /* not really needed? Not with sh, ksh or bash */
+	vim_snprintf((char *)end + 1, (size_t)(buflen - (end + 1 - buf)),
+						  (char *)opt, (char *)fname);
     }
     else
-	sprintf((char *)buf,
+	vim_snprintf((char *)end, (size_t)(buflen - (end - buf)),
 #ifdef FEAT_QUICKFIX
 # ifndef RISCOS
 		opt != p_sp ? " %s%s" :
@@ -1676,14 +1686,12 @@
 
 /*
  * read_viminfo() -- Read the viminfo file.  Registers etc. which are already
- * set are not over-written unless force is TRUE. -- webb
+ * set are not over-written unless "flags" includes VIF_FORCEIT. -- webb
  */
     int
-read_viminfo(file, want_info, want_marks, forceit)
-    char_u	*file;
-    int		want_info;
-    int		want_marks;
-    int		forceit;
+read_viminfo(file, flags)
+    char_u	*file;	    /* file name or NULL to use default name */
+    int		flags;	    /* VIF_WANT_INFO et al. */
 {
     FILE	*fp;
     char_u	*fname;
@@ -1691,7 +1699,7 @@
     if (no_viminfo())
 	return FAIL;
 
-    fname = viminfo_filename(file);	    /* may set to default if NULL */
+    fname = viminfo_filename(file);	/* get file name in allocated buffer */
     if (fname == NULL)
 	return FAIL;
     fp = mch_fopen((char *)fname, READBIN);
@@ -1701,8 +1709,9 @@
 	verbose_enter();
 	smsg((char_u *)_("Reading viminfo file \"%s\"%s%s%s"),
 		fname,
-		want_info ? _(" info") : "",
-		want_marks ? _(" marks") : "",
+		(flags & VIF_WANT_INFO) ? _(" info") : "",
+		(flags & VIF_WANT_MARKS) ? _(" marks") : "",
+		(flags & VIF_GET_OLDFILES) ? _(" oldfiles") : "",
 		fp == NULL ? _(" FAILED") : "");
 	verbose_leave();
     }
@@ -1712,10 +1721,9 @@
 	return FAIL;
 
     viminfo_errcnt = 0;
-    do_viminfo(fp, NULL, want_info, want_marks, forceit);
+    do_viminfo(fp, NULL, flags);
 
     fclose(fp);
-
     return OK;
 }
 
@@ -1786,7 +1794,7 @@
 	 * overwrite a user's viminfo file after a "su root", with a
 	 * viminfo file that the user can't read.
 	 */
-	st_old.st_dev = 0;
+	st_old.st_dev = (dev_t)0;
 	st_old.st_ino = 0;
 	st_old.st_mode = 0600;
 	if (mch_stat((char *)fname, &st_old) == 0
@@ -1943,7 +1951,7 @@
 	     * root.
 	     */
 	    if (fp_out != NULL)
-		(void)fchown(fileno(fp_out), st_old.st_uid, st_old.st_gid);
+		ignored = fchown(fileno(fp_out), st_old.st_uid, st_old.st_gid);
 #endif
 	}
     }
@@ -1968,7 +1976,7 @@
     }
 
     viminfo_errcnt = 0;
-    do_viminfo(fp_in, fp_out, !forceit, !forceit, FALSE);
+    do_viminfo(fp_in, fp_out, forceit ? 0 : (VIF_WANT_INFO | VIF_WANT_MARKS));
 
     fclose(fp_out);	    /* errors are ignored !? */
     if (fp_in != NULL)
@@ -2041,12 +2049,10 @@
  * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().
  */
     static void
-do_viminfo(fp_in, fp_out, want_info, want_marks, force_read)
+do_viminfo(fp_in, fp_out, flags)
     FILE	*fp_in;
     FILE	*fp_out;
-    int		want_info;
-    int		want_marks;
-    int		force_read;
+    int		flags;
 {
     int		count = 0;
     int		eof = FALSE;
@@ -2061,8 +2067,9 @@
 
     if (fp_in != NULL)
     {
-	if (want_info)
-	    eof = read_viminfo_up_to_marks(&vir, force_read, fp_out != NULL);
+	if (flags & VIF_WANT_INFO)
+	    eof = read_viminfo_up_to_marks(&vir,
+					 flags & VIF_FORCEIT, fp_out != NULL);
 	else
 	    /* Skip info, find start of marks */
 	    while (!(eof = viminfo_readline(&vir))
@@ -2092,8 +2099,9 @@
 	write_viminfo_bufferlist(fp_out);
 	count = write_viminfo_marks(fp_out);
     }
-    if (fp_in != NULL && want_marks)
-	copy_viminfo_marks(&vir, fp_out, count, eof);
+    if (fp_in != NULL
+	    && (flags & (VIF_WANT_MARKS | VIF_GET_OLDFILES | VIF_FORCEIT)))
+	copy_viminfo_marks(&vir, fp_out, count, eof, flags);
 
     vim_free(vir.vir_line);
 #ifdef FEAT_MBYTE
@@ -2248,12 +2256,11 @@
  *
  * Return the string in allocated memory (NULL when out of memory).
  */
-/*ARGSUSED*/
     char_u *
 viminfo_readstring(virp, off, convert)
     vir_T	*virp;
     int		off;		    /* offset for virp->vir_line */
-    int		convert;	    /* convert the string */
+    int		convert UNUSED;	    /* convert the string */
 {
     char_u	*retval;
     char_u	*s, *d;
@@ -2387,7 +2394,8 @@
 
     if (curwin->w_p_nu || use_number)
     {
-	sprintf((char *)numbuf, "%*ld ", number_width(curwin), (long)lnum);
+	vim_snprintf((char *)numbuf, sizeof(numbuf),
+				   "%*ld ", number_width(curwin), (long)lnum);
 	msg_puts_attr(numbuf, hl_attr(HLF_N));	/* Highlight line nrs */
     }
     msg_prt_line(ml_get(lnum), list);
@@ -2414,8 +2422,8 @@
 	cursor_on();		/* msg_start() switches it off */
 	out_flush();
 	silent_mode = save_silent;
-	info_message = FALSE;
     }
+    info_message = FALSE;
 }
 
 /*
@@ -2704,7 +2712,12 @@
 	if (eap->cmdidx == CMD_saveas)
 	{
 	    if (retval == OK)
+	    {
 		curbuf->b_p_ro = FALSE;
+#ifdef FEAT_WINDOWS
+		redraw_tabline = TRUE;
+#endif
+	    }
 	    /* Change directories when the 'acd' option is set. */
 	    DO_AUTOCHDIR
 	}
@@ -2724,7 +2737,6 @@
  * May set eap->forceit if a dialog says it's OK to overwrite.
  * Return OK if it's OK, FAIL if it is not.
  */
-/*ARGSUSED*/
     static int
 check_overwrite(eap, buf, fname, ffname, other)
     exarg_T	*eap;
@@ -3701,7 +3713,7 @@
     /* If the window options were changed may need to set the spell language.
      * Can only do this after the buffer has been properly setup. */
     if (did_get_winopts && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
-	did_set_spelllang(curbuf);
+	(void)did_set_spelllang(curbuf);
 #endif
 
     if (command == NULL)
@@ -3774,7 +3786,7 @@
 
 #ifdef FEAT_KEYMAP
     if (curbuf->b_kmap_state & KEYMAP_INIT)
-	keymap_init();
+	(void)keymap_init();
 #endif
 
     --RedrawingDisabled;
@@ -4022,8 +4034,10 @@
 	bigness = curwin->w_height;
     else if (firstwin == lastwin)
 	bigness = curwin->w_p_scr * 2;
+#ifdef FEAT_WINDOWS
     else
 	bigness = curwin->w_height - 3;
+#endif
     if (bigness < 1)
 	bigness = 1;
 
@@ -4472,7 +4486,7 @@
 	    char_u	*p1;
 	    int		did_sub = FALSE;
 	    int		lastone;
-	    unsigned	len, needed_len;
+	    int		len, copy_len, needed_len;
 	    long	nmatch_tl = 0;	/* nr of lines matched below lnum */
 	    int		do_again;	/* do it again after joining lines */
 	    int		skip_match = FALSE;
@@ -4617,6 +4631,8 @@
 
 		if (do_ask)
 		{
+		    int typed = 0;
+
 		    /* change State to CONFIRM, so that the mouse works
 		     * properly */
 		    save_State = State;
@@ -4655,7 +4671,7 @@
 			    resp = getexmodeline('?', NULL, 0);
 			    if (resp != NULL)
 			    {
-				i = *resp;
+				typed = *resp;
 				vim_free(resp);
 			    }
 			}
@@ -4707,7 +4723,7 @@
 #endif
 			    ++no_mapping;	/* don't map this key */
 			    ++allow_keys;	/* allow special keys */
-			    i = plain_vgetc();
+			    typed = plain_vgetc();
 			    --allow_keys;
 			    --no_mapping;
 
@@ -4718,35 +4734,35 @@
 			}
 
 			need_wait_return = FALSE; /* no hit-return prompt */
-			if (i == 'q' || i == ESC || i == Ctrl_C
+			if (typed == 'q' || typed == ESC || typed == Ctrl_C
 #ifdef UNIX
-				|| i == intr_char
+				|| typed == intr_char
 #endif
 				)
 			{
 			    got_quit = TRUE;
 			    break;
 			}
-			if (i == 'n')
+			if (typed == 'n')
 			    break;
-			if (i == 'y')
+			if (typed == 'y')
 			    break;
-			if (i == 'l')
+			if (typed == 'l')
 			{
 			    /* last: replace and then stop */
 			    do_all = FALSE;
 			    line2 = lnum;
 			    break;
 			}
-			if (i == 'a')
+			if (typed == 'a')
 			{
 			    do_ask = FALSE;
 			    break;
 			}
 #ifdef FEAT_INS_EXPAND
-			if (i == Ctrl_E)
+			if (typed == Ctrl_E)
 			    scrollup_clamp();
-			else if (i == Ctrl_Y)
+			else if (typed == Ctrl_Y)
 			    scrolldown_clamp();
 #endif
 		    }
@@ -4757,7 +4773,7 @@
 		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)
 			--no_u_sync;
 
-		    if (i == 'n')
+		    if (typed == 'n')
 		    {
 			/* For a multi-line match, put matchcol at the NUL at
 			 * the end of the line and set nmatch to one, so that
@@ -4808,9 +4824,9 @@
 		    p1 = ml_get(sub_firstlnum + nmatch - 1);
 		    nmatch_tl += nmatch - 1;
 		}
-		i = regmatch.startpos[0].col - copycol;
-		needed_len = i + ((unsigned)STRLEN(p1) - regmatch.endpos[0].col)
-								 + sublen + 1;
+		copy_len = regmatch.startpos[0].col - copycol;
+		needed_len = copy_len + ((unsigned)STRLEN(p1)
+				       - regmatch.endpos[0].col) + sublen + 1;
 		if (new_start == NULL)
 		{
 		    /*
@@ -4833,7 +4849,7 @@
 		     */
 		    len = (unsigned)STRLEN(new_start);
 		    needed_len += len;
-		    if (needed_len > new_start_len)
+		    if (needed_len > (int)new_start_len)
 		    {
 			new_start_len = needed_len + 50;
 			if ((p1 = alloc_check(new_start_len)) == NULL)
@@ -4851,8 +4867,8 @@
 		/*
 		 * copy the text up to the part that matched
 		 */
-		mch_memmove(new_end, sub_firstline + copycol, (size_t)i);
-		new_end += i;
+		mch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);
+		new_end += copy_len;
 
 		(void)vim_regsub_multi(&regmatch,
 				    sub_firstlnum - regmatch.startpos[0].lnum,
@@ -5059,6 +5075,7 @@
 
 	    if (did_sub)
 		++sub_nlines;
+	    vim_free(new_start);	/* for when substitute was cancelled */
 	    vim_free(sub_firstline);	/* free the copy of the original line */
 	    sub_firstline = NULL;
 	}
@@ -5769,7 +5786,7 @@
      * Recognize a few exceptions to the rule.	Some strings that contain '*'
      * with "star".  Otherwise '*' is recognized as a wildcard.
      */
-    for (i = sizeof(mtable) / sizeof(char *); --i >= 0; )
+    for (i = (int)(sizeof(mtable) / sizeof(char *)); --i >= 0; )
 	if (STRCMP(arg, mtable[i]) == 0)
 	{
 	    STRCPY(d, rtable[i]);
@@ -6519,22 +6536,11 @@
 static sign_T	*first_sign = NULL;
 static int	last_sign_typenr = MAX_TYPENR;	/* is decremented */
 
+static int sign_cmd_idx __ARGS((char_u *begin_cmd, char_u *end_cmd));
 static void sign_list_defined __ARGS((sign_T *sp));
+static void sign_undefine __ARGS((sign_T *sp, sign_T *sp_prev));
 
-/*
- * ":sign" command
- */
-    void
-ex_sign(eap)
-    exarg_T	*eap;
-{
-    char_u	*arg = eap->arg;
-    char_u	*p;
-    int		idx;
-    sign_T	*sp;
-    sign_T	*sp_prev;
-    buf_T	*buf;
-    static char	*cmds[] = {
+static char *cmds[] = {
 			"define",
 #define SIGNCMD_DEFINE	0
 			"undefine",
@@ -6547,22 +6553,51 @@
 #define SIGNCMD_UNPLACE	4
 			"jump",
 #define SIGNCMD_JUMP	5
+			NULL
 #define SIGNCMD_LAST	6
-    };
+};
+
+/*
+ * Find index of a ":sign" subcmd from its name.
+ * "*end_cmd" must be writable.
+ */
+    static int
+sign_cmd_idx(begin_cmd, end_cmd)
+    char_u	*begin_cmd;	/* begin of sign subcmd */
+    char_u	*end_cmd;	/* just after sign subcmd */
+{
+    int		idx;
+    char	save = *end_cmd;
+
+    *end_cmd = NUL;
+    for (idx = 0; ; ++idx)
+	if (cmds[idx] == NULL || STRCMP(begin_cmd, cmds[idx]) == 0)
+	    break;
+    *end_cmd = save;
+    return idx;
+}
+
+/*
+ * ":sign" command
+ */
+    void
+ex_sign(eap)
+    exarg_T	*eap;
+{
+    char_u	*arg = eap->arg;
+    char_u	*p;
+    int		idx;
+    sign_T	*sp;
+    sign_T	*sp_prev;
+    buf_T	*buf;
 
     /* Parse the subcommand. */
     p = skiptowhite(arg);
-    if (*p != NUL)
-	*p++ = NUL;
-    for (idx = 0; ; ++idx)
+    idx = sign_cmd_idx(arg, p);
+    if (idx == SIGNCMD_LAST)
     {
-	if (idx == SIGNCMD_LAST)
-	{
-	    EMSG2(_("E160: Unknown sign command: %s"), arg);
-	    return;
-	}
-	if (STRCMP(arg, cmds[idx]) == 0)
-	    break;
+	EMSG2(_("E160: Unknown sign command: %s"), arg);
+	return;
     }
     arg = skipwhite(p);
 
@@ -6728,24 +6763,8 @@
 		/* ":sign list {name}" */
 		sign_list_defined(sp);
 	    else
-	    {
 		/* ":sign undefine {name}" */
-		vim_free(sp->sn_name);
-		vim_free(sp->sn_icon);
-#ifdef FEAT_SIGN_ICONS
-		if (sp->sn_image != NULL)
-		{
-		    out_flush();
-		    gui_mch_destroy_sign(sp->sn_image);
-		}
-#endif
-		vim_free(sp->sn_text);
-		if (sp_prev == NULL)
-		    first_sign = sp->sn_next;
-		else
-		    sp_prev->sn_next = sp->sn_next;
-		vim_free(sp);
-	    }
+		sign_undefine(sp, sp_prev);
 	}
     }
     else
@@ -6994,6 +7013,31 @@
 }
 
 /*
+ * Undefine a sign and free its memory.
+ */
+    static void
+sign_undefine(sp, sp_prev)
+    sign_T	*sp;
+    sign_T	*sp_prev;
+{
+    vim_free(sp->sn_name);
+    vim_free(sp->sn_icon);
+#ifdef FEAT_SIGN_ICONS
+    if (sp->sn_image != NULL)
+    {
+	out_flush();
+	gui_mch_destroy_sign(sp->sn_image);
+    }
+#endif
+    vim_free(sp->sn_text);
+    if (sp_prev == NULL)
+	first_sign = sp->sn_next;
+    else
+	sp_prev->sn_next = sp->sn_next;
+    vim_free(sp);
+}
+
+/*
  * Get highlighting attribute for sign "typenr".
  * If "line" is TRUE: line highl, if FALSE: text highl.
  */
@@ -7067,6 +7111,198 @@
     return (char_u *)_("[Deleted]");
 }
 
+#if defined(EXITFREE) || defined(PROTO)
+/*
+ * Undefine/free all signs.
+ */
+    void
+free_signs()
+{
+    while (first_sign != NULL)
+	sign_undefine(first_sign, NULL);
+}
+#endif
+
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+static enum
+{
+    EXP_SUBCMD,		/* expand :sign sub-commands */
+    EXP_DEFINE,		/* expand :sign define {name} args */
+    EXP_PLACE,		/* expand :sign place {id} args */
+    EXP_UNPLACE,	/* expand :sign unplace" */
+    EXP_SIGN_NAMES	/* expand with name of placed signs */
+} expand_what;
+
+/*
+ * Function given to ExpandGeneric() to obtain the sign command
+ * expansion.
+ */
+/*ARGSUSED*/
+    char_u *
+get_sign_name(xp, idx)
+    expand_T	*xp;
+    int		idx;
+{
+    sign_T	*sp;
+    int		current_idx;
+
+    switch (expand_what)
+    {
+    case EXP_SUBCMD:
+	return (char_u *)cmds[idx];
+    case EXP_DEFINE:
+	{
+	    char *define_arg[] =
+	    {
+		"icon=", "linehl=", "text=", "texthl=", NULL
+	    };
+	    return (char_u *)define_arg[idx];
+	}
+    case EXP_PLACE:
+	{
+	    char *place_arg[] =
+	    {
+		"line=", "name=", "file=", "buffer=", NULL
+	    };
+	    return (char_u *)place_arg[idx];
+	}
+    case EXP_UNPLACE:
+	{
+	    char *unplace_arg[] = { "file=", "buffer=", NULL };
+	    return (char_u *)unplace_arg[idx];
+	}
+    case EXP_SIGN_NAMES:
+	/* Complete with name of signs already defined */
+	current_idx = 0;
+	for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	    if (current_idx++ == idx)
+		return sp->sn_name;
+	return NULL;
+    default:
+	return NULL;
+    }
+}
+
+/*
+ * Handle command line completion for :sign command.
+ */
+    void
+set_context_in_sign_cmd(xp, arg)
+    expand_T	*xp;
+    char_u	*arg;
+{
+    char_u	*p;
+    char_u	*end_subcmd;
+    char_u	*last;
+    int		cmd_idx;
+    char_u	*begin_subcmd_args;
+
+    /* Default: expand subcommands. */
+    xp->xp_context = EXPAND_SIGN;
+    expand_what = EXP_SUBCMD;
+    xp->xp_pattern = arg;
+
+    end_subcmd = skiptowhite(arg);
+    if (*end_subcmd == NUL)
+	/* expand subcmd name
+	 * :sign {subcmd}<CTRL-D>*/
+	return;
+
+    cmd_idx = sign_cmd_idx(arg, end_subcmd);
+
+    /* :sign {subcmd} {subcmd_args}
+     *                |
+     *                begin_subcmd_args */
+    begin_subcmd_args = skipwhite(end_subcmd);
+    p = skiptowhite(begin_subcmd_args);
+    if (*p == NUL)
+    {
+	/*
+	 * Expand first argument of subcmd when possible.
+	 * For ":jump {id}" and ":unplace {id}", we could
+	 * possibly expand the ids of all signs already placed.
+	 */
+	xp->xp_pattern = begin_subcmd_args;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_LIST:
+	    case SIGNCMD_UNDEFINE:
+		/* :sign list <CTRL-D>
+		 * :sign undefine <CTRL-D> */
+		expand_what = EXP_SIGN_NAMES;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+	return;
+    }
+
+    /* expand last argument of subcmd */
+
+    /* :sign define {name} {args}...
+     *              |
+     *              p */
+
+    /* Loop until reaching last argument. */
+    do
+    {
+	p = skipwhite(p);
+	last = p;
+	p = skiptowhite(p);
+    } while (*p != NUL);
+
+    p = vim_strchr(last, '=');
+
+    /* :sign define {name} {args}... {last}=
+     *                               |     |
+     *                            last     p */
+    if (p == NUL)
+    {
+	/* Expand last argument name (before equal sign). */
+	xp->xp_pattern = last;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_DEFINE:
+		expand_what = EXP_DEFINE;
+		break;
+	    case SIGNCMD_PLACE:
+		expand_what = EXP_PLACE;
+		break;
+	    case SIGNCMD_JUMP:
+	    case SIGNCMD_UNPLACE:
+		expand_what = EXP_UNPLACE;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+    else
+    {
+	/* Expand last argument value (after equal sign). */
+	xp->xp_pattern = p + 1;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_DEFINE:
+		if (STRNCMP(last, "texthl", p - last) == 0 ||
+		    STRNCMP(last, "linehl", p - last) == 0)
+		    xp->xp_context = EXPAND_HIGHLIGHT;
+		else if (STRNCMP(last, "icon", p - last) == 0)
+		    xp->xp_context = EXPAND_FILES;
+		else
+		    xp->xp_context = EXPAND_NOTHING;
+		break;
+	    case SIGNCMD_PLACE:
+		if (STRNCMP(last, "name", p - last) == 0)
+		    expand_what = EXP_SIGN_NAMES;
+		else
+		    xp->xp_context = EXPAND_NOTHING;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+}
+#endif
 #endif
 
 #if defined(FEAT_GUI) || defined(FEAT_CLIENTSERVER) || defined(PROTO)
diff -Naur vim72.orig/src/ex_cmds.h vim72/src/ex_cmds.h
--- vim72.orig/src/ex_cmds.h	2008-06-21 11:47:57.000000000 -0700
+++ vim72/src/ex_cmds.h	2009-06-05 14:16:09.000000000 -0700
@@ -278,7 +278,7 @@
 EX(CMD_crewind,		"crewind",	ex_cc,
 			RANGE|NOTADR|COUNT|TRLBAR|BANG),
 EX(CMD_cscope,		"cscope",	do_cscope,
-			EXTRA|NOTRLCOM|SBOXOK|XFILE),
+			EXTRA|NOTRLCOM|XFILE),
 EX(CMD_cstag,		"cstag",	do_cstag,
 			BANG|TRLBAR|WORD1),
 EX(CMD_cunmap,		"cunmap",	ex_unmap,
@@ -506,7 +506,7 @@
 EX(CMD_lclose,		"lclose",	ex_cclose,
 			RANGE|NOTADR|COUNT|TRLBAR),
 EX(CMD_lcscope,		"lcscope",	do_cscope,
-			EXTRA|NOTRLCOM|SBOXOK|XFILE),
+			EXTRA|NOTRLCOM|XFILE),
 EX(CMD_left,		"left",		ex_align,
 			TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|MODIFY),
 EX(CMD_leftabove,	"leftabove",	ex_wrongmodifier,
@@ -635,6 +635,8 @@
 			RANGE|NOTADR|ZEROR|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_noremap,		"noremap",	ex_map,
 			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
+EX(CMD_noautocmd,	"noautocmd",	ex_wrongmodifier,
+			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_nohlsearch,	"nohlsearch",	ex_nohlsearch,
 			TRLBAR|SBOXOK|CMDWIN),
 EX(CMD_noreabbrev,	"noreabbrev",	ex_abbreviate,
@@ -651,6 +653,8 @@
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_open,		"open",		ex_open,
 			RANGE|EXTRA),
+EX(CMD_oldfiles,	"oldfiles",	ex_oldfiles,
+			BANG|TRLBAR|SBOXOK|CMDWIN),
 EX(CMD_omap,		"omap",		ex_map,
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_omapclear,	"omapclear",	ex_mapclear,
@@ -802,7 +806,7 @@
 EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
 			WORD1|TRLBAR|CMDWIN),
 EX(CMD_scscope,		"scscope",	do_scscope,
-			EXTRA|NOTRLCOM|SBOXOK),
+			EXTRA|NOTRLCOM),
 EX(CMD_set,		"set",		ex_set,
 			TRLBAR|EXTRA|CMDWIN|SBOXOK),
 EX(CMD_setfiletype,	"setfiletype",	ex_setfiletype,
diff -Naur vim72.orig/src/ex_docmd.c vim72/src/ex_docmd.c
--- vim72.orig/src/ex_docmd.c	2008-07-26 04:51:05.000000000 -0700
+++ vim72/src/ex_docmd.c	2009-06-05 14:25:02.000000000 -0700
@@ -364,6 +364,7 @@
 # define ex_function		ex_ni
 # define ex_delfunction		ex_ni
 # define ex_return		ex_ni
+# define ex_oldfiles		ex_ni
 #endif
 static char_u	*arg_all __ARGS((void));
 #ifdef FEAT_SESSION
@@ -1577,11 +1578,10 @@
  * If "fgetline" is get_loop_line(), return TRUE if the getline it uses equals
  * "func".  * Otherwise return TRUE when "fgetline" equals "func".
  */
-/*ARGSUSED*/
     int
 getline_equal(fgetline, cookie, func)
     char_u	*(*fgetline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for fgetline() */
+    void	*cookie UNUSED;		/* argument for fgetline() */
     char_u	*(*func) __ARGS((int, void *, int));
 {
 #ifdef FEAT_EVAL
@@ -1609,10 +1609,9 @@
  * If "fgetline" is get_loop_line(), return the cookie used by the original
  * getline function.  Otherwise return "cookie".
  */
-/*ARGSUSED*/
     void *
 getline_cookie(fgetline, cookie)
-    char_u	*(*fgetline) __ARGS((int, void *, int));
+    char_u	*(*fgetline) __ARGS((int, void *, int)) UNUSED;
     void	*cookie;		/* argument for fgetline() */
 {
 # ifdef FEAT_EVAL
@@ -1770,7 +1769,7 @@
 			}
 			if (checkforcmd(&ea.cmd, "browse", 3))
 			{
-#ifdef FEAT_BROWSE
+#ifdef FEAT_BROWSE_CMD
 			    cmdmod.browse = TRUE;
 #endif
 			    continue;
@@ -2698,6 +2697,11 @@
 	/* Restore msg_scroll, it's set by file I/O commands, even when no
 	 * message is actually displayed. */
 	msg_scroll = save_msg_scroll;
+
+	/* "silent reg" or "silent echo x" inside "redir" leaves msg_col
+	 * somewhere in the line.  Put it back in the first column. */
+	if (redirecting())
+	    msg_col = 0;
     }
 
 #ifdef HAVE_SANDBOX
@@ -2731,7 +2735,7 @@
     int		i;
 
     for (i = 0; cmd[i] != NUL; ++i)
-	if (cmd[i] != (*pp)[i])
+	if (((char_u *)cmd)[i] != (*pp)[i])
 	    break;
     if (i >= len && !isalpha((*pp)[i]))
     {
@@ -2748,11 +2752,10 @@
  * "full" is set to TRUE if the whole command name matched.
  * Returns NULL for an ambiguous user command.
  */
-/*ARGSUSED*/
     static char_u *
 find_command(eap, full)
     exarg_T	*eap;
-    int		*full;
+    int		*full UNUSED;
 {
     int		len;
     char_u	*p;
@@ -2797,7 +2800,7 @@
 	    /* Check for ":dl", ":dell", etc. to ":deletel": that's
 	     * :delete with the 'l' flag.  Same for 'p'. */
 	    for (i = 0; i < len; ++i)
-		if (eap->cmd[i] != "delete"[i])
+		if (eap->cmd[i] != ((char_u *)"delete")[i])
 		    break;
 	    if (i == len - 1)
 	    {
@@ -2978,6 +2981,7 @@
     {"keepmarks", 3, FALSE},
     {"leftabove", 5, FALSE},
     {"lockmarks", 3, FALSE},
+    {"noautocmd", 3, FALSE},
     {"rightbelow", 6, FALSE},
     {"sandbox", 3, FALSE},
     {"silent", 3, FALSE},
@@ -3000,7 +3004,7 @@
 
     if (VIM_ISDIGIT(*cmd))
 	p = skipwhite(skipdigits(cmd));
-    for (i = 0; i < sizeof(cmdmods) / sizeof(struct cmdmod); ++i)
+    for (i = 0; i < (int)(sizeof(cmdmods) / sizeof(struct cmdmod)); ++i)
     {
 	for (j = 0; p[j] != NUL; ++j)
 	    if (p[j] != cmdmods[i].name[j])
@@ -3028,7 +3032,7 @@
     char_u	*p;
 
     /* Check command modifiers. */
-    for (i = 0; i < sizeof(cmdmods) / sizeof(struct cmdmod); ++i)
+    for (i = 0; i < (int)(sizeof(cmdmods) / sizeof(struct cmdmod)); ++i)
     {
 	for (j = 0; name[j] != NUL; ++j)
 	    if (name[j] != cmdmods[i].name[j])
@@ -3608,6 +3612,7 @@
 	    return set_context_in_autocmd(xp, arg, FALSE);
 
 	case CMD_doautocmd:
+	case CMD_doautoall:
 	    return set_context_in_autocmd(xp, arg, TRUE);
 #endif
 	case CMD_set:
@@ -3680,6 +3685,18 @@
 	case CMD_highlight:
 	    set_context_in_highlight_cmd(xp, arg);
 	    break;
+#ifdef FEAT_CSCOPE
+	case CMD_cscope:
+	case CMD_lcscope:
+	case CMD_scscope:
+	    set_context_in_cscope_cmd(xp, arg, ea.cmdidx);
+	    break;
+#endif
+#ifdef FEAT_SIGNS
+	case CMD_sign:
+	    set_context_in_sign_cmd(xp, arg);
+	    break;
+#endif
 #ifdef FEAT_LISTCMDS
 	case CMD_bdelete:
 	case CMD_bwipeout:
@@ -3803,7 +3820,7 @@
     char_u	*cmd;
     int		*ctx;	/* pointer to xp_context or NULL */
 {
-    int		delim;
+    unsigned	delim;
 
     while (vim_strchr((char_u *)" \t0123456789.$%'/?-+,;", *cmd) != NULL)
     {
@@ -5033,10 +5050,9 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of command names.
  */
-/*ARGSUSED*/
     char_u *
 get_command_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx >= (int)CMD_SIZE)
@@ -5121,7 +5137,11 @@
 	    }
 
 	    vim_free(cmd->uc_rep);
-	    cmd->uc_rep = 0;
+	    cmd->uc_rep = NULL;
+#if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
+	    vim_free(cmd->uc_compl_arg);
+	    cmd->uc_compl_arg = NULL;
+#endif
 	    break;
 	}
 
@@ -5180,6 +5200,9 @@
     {EXPAND_AUGROUP, "augroup"},
     {EXPAND_BUFFERS, "buffer"},
     {EXPAND_COMMANDS, "command"},
+#if defined(FEAT_CSCOPE)
+    {EXPAND_CSCOPE, "cscope"},
+#endif
 #if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
     {EXPAND_USER_DEFINED, "custom"},
     {EXPAND_USER_LIST, "customlist"},
@@ -5196,6 +5219,9 @@
     {EXPAND_MENUS, "menu"},
     {EXPAND_SETTINGS, "option"},
     {EXPAND_SHELLCMD, "shellcmd"},
+#if defined(FEAT_SIGNS)
+    {EXPAND_SIGN, "sign"},
+#endif
     {EXPAND_TAGS, "tag"},
     {EXPAND_TAGS_LISTFILES, "tag_listfiles"},
     {EXPAND_USER_VARS, "var"},
@@ -5479,6 +5505,9 @@
     return OK;
 }
 
+/*
+ * ":command ..."
+ */
     static void
 ex_command(eap)
     exarg_T   *eap;
@@ -5540,10 +5569,9 @@
  * ":comclear"
  * Clear all user commands, global and for current buffer.
  */
-/*ARGSUSED*/
     void
 ex_comclear(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     uc_clear(&ucmds);
     uc_clear(&curbuf->b_ucmds);
@@ -5910,7 +5938,8 @@
     char_u	*q;
 
     char_u	*start;
-    char_u	*end;
+    char_u	*end = NULL;
+    char_u	*ksp;
     size_t	len, totlen;
 
     size_t	split_len = 0;
@@ -5927,16 +5956,51 @@
 
     /*
      * Replace <> in the command by the arguments.
+     * First round: "buf" is NULL, compute length, allocate "buf".
+     * Second round: copy result into "buf".
      */
     buf = NULL;
     for (;;)
     {
-	p = cmd->uc_rep;
-	q = buf;
+	p = cmd->uc_rep;    /* source */
+	q = buf;	    /* destination */
 	totlen = 0;
-	while ((start = vim_strchr(p, '<')) != NULL
-	       && (end = vim_strchr(start + 1, '>')) != NULL)
+
+	for (;;)
 	{
+	    start = vim_strchr(p, '<');
+	    if (start != NULL)
+		end = vim_strchr(start + 1, '>');
+	    if (buf != NULL)
+	    {
+		ksp = vim_strchr(p, K_SPECIAL);
+		if (ksp != NULL && (start == NULL || ksp < start || end == NULL)
+			&& ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)
+# ifdef FEAT_GUI
+			    || (ksp[1] == KS_EXTRA && ksp[2] == (int)KE_CSI)
+# endif
+			    ))
+		{
+		    /* K_SPECIAL han been put in the buffer as K_SPECIAL
+		     * KS_SPECIAL KE_FILLER, like for mappings, but
+		     * do_cmdline() doesn't handle that, so convert it back.
+		     * Also change K_SPECIAL KS_EXTRA KE_CSI into CSI. */
+		    len = ksp - p;
+		    if (len > 0)
+		    {
+			mch_memmove(q, p, len);
+			q += len;
+		    }
+		    *q++ = ksp[1] == KS_SPECIAL ? K_SPECIAL : CSI;
+		    p = ksp + 3;
+		    continue;
+		}
+	    }
+
+	    /* break if there no <item> is found */
+	    if (start == NULL || end == NULL)
+		break;
+
 	    /* Include the '>' */
 	    ++end;
 
@@ -6003,10 +6067,9 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of user command names.
  */
-/*ARGSUSED*/
     char_u *
 get_user_commands(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx < curbuf->b_ucmds.ga_len)
@@ -6021,17 +6084,16 @@
  * Function given to ExpandGeneric() to obtain the list of user command
  * attributes.
  */
-/*ARGSUSED*/
     char_u *
 get_user_cmd_flags(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static char *user_cmd_flags[] =
 	{"bang", "bar", "buffer", "complete", "count",
 	    "nargs", "range", "register"};
 
-    if (idx >= sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0]))
+    if (idx >= (int)(sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0])))
 	return NULL;
     return (char_u *)user_cmd_flags[idx];
 }
@@ -6039,15 +6101,14 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of values for -nargs.
  */
-/*ARGSUSED*/
     char_u *
 get_user_cmd_nargs(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
 
-    if (idx >= sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0]))
+    if (idx >= (int)(sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0])))
 	return NULL;
     return (char_u *)user_cmd_nargs[idx];
 }
@@ -6055,10 +6116,9 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of values for -complete.
  */
-/*ARGSUSED*/
     char_u *
 get_user_cmd_complete(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     return (char_u *)command_complete[idx].name;
@@ -6236,10 +6296,9 @@
 /*
  * ":cquit".
  */
-/*ARGSUSED*/
     static void
 ex_cquit(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     getout(1);	/* this does not always pass on the exit code to the Manx
 		   compiler. why? */
@@ -6681,10 +6740,9 @@
 /*
  * ":shell".
  */
-/*ARGSUSED*/
     static void
 ex_shell(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     do_shell(NULL, 0);
 }
@@ -6988,10 +7046,9 @@
 /*
  * ":preserve".
  */
-/*ARGSUSED*/
     static void
 ex_preserve(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     curbuf->b_flags |= BF_PRESERVED;
     ml_preserve(curbuf, TRUE);
@@ -7223,10 +7280,9 @@
 /*
  * :tabs command: List tabs and their contents.
  */
-/*ARGSUSED*/
     static void
 ex_tabs(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     tabpage_T	*tp;
     win_T	*wp;
@@ -7413,7 +7469,6 @@
 /*
  * ":edit <file>" command and alikes.
  */
-/*ARGSUSED*/
     void
 do_exedit(eap, old_curwin)
     exarg_T	*eap;
@@ -7624,10 +7679,9 @@
 }
 #endif
 
-/*ARGSUSED*/
     static void
 ex_swapname(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
 	MSG(_("No swap file"));
@@ -7640,10 +7694,9 @@
  * offset.
  * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
  */
-/*ARGSUSED*/
     static void
 ex_syncbind(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_SCROLLBIND
     win_T	*wp;
@@ -7803,6 +7856,9 @@
 {
     vim_free(prev_dir);
     prev_dir = NULL;
+
+    vim_free(globaldir);
+    globaldir = NULL;
 }
 #endif
 
@@ -7825,6 +7881,10 @@
     else
 #endif
     {
+#ifdef FEAT_AUTOCMD
+	if (allbuf_locked())
+	    return;
+#endif
 	if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged()
 							     && !eap->forceit)
 	{
@@ -7906,10 +7966,9 @@
 /*
  * ":pwd".
  */
-/*ARGSUSED*/
     static void
 ex_pwd(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     if (mch_dirname(NameBuff, MAXPATHL) == OK)
     {
@@ -8340,10 +8399,9 @@
 /*
  * ":undo".
  */
-/*ARGSUSED*/
     static void
 ex_undo(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     if (eap->addr_count == 1)	    /* :undo 123 */
 	undo_time(eap->line2, FALSE, TRUE);
@@ -8354,10 +8412,9 @@
 /*
  * ":redo".
  */
-/*ARGSUSED*/
     static void
 ex_redo(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     u_redo(1);
 }
@@ -8365,7 +8422,6 @@
 /*
  * ":earlier" and ":later".
  */
-/*ARGSUSED*/
     static void
 ex_later(eap)
     exarg_T	*eap;
@@ -8550,10 +8606,9 @@
 /*
  * ":redrawstatus": force redraw of status line(s)
  */
-/*ARGSUSED*/
     static void
 ex_redrawstatus(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #if defined(FEAT_WINDOWS)
     int		r = RedrawingDisabled;
@@ -8749,8 +8804,8 @@
 		else if (*dirnow != NUL
 			&& (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
 		{
-		    (void)mch_chdir((char *)globaldir);
-		    shorten_fnames(TRUE);
+		    if (mch_chdir((char *)globaldir) == 0)
+			shorten_fnames(TRUE);
 		}
 
 		failed |= (makeopens(fd, dirnow) == FAIL);
@@ -8814,11 +8869,10 @@
 
 #if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \
 	|| defined(PROTO)
-/*ARGSUSED*/
     int
 vim_mkdir_emsg(name, prot)
     char_u	*name;
-    int		prot;
+    int		prot UNUSED;
 {
     if (vim_mkdir(name, prot) != 0)
     {
@@ -9089,10 +9143,9 @@
 /*
  * ":stopinsert"
  */
-/*ARGSUSED*/
     static void
 ex_stopinsert(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     restart_edit = 0;
     stop_insert_mode = TRUE;
@@ -9366,9 +9419,8 @@
 # define SPEC_CLIENT 9
 #endif
     };
-#define SPEC_COUNT  (sizeof(spec_str) / sizeof(char *))
 
-    for (i = 0; i < SPEC_COUNT; ++i)
+    for (i = 0; i < (int)(sizeof(spec_str) / sizeof(char *)); ++i)
     {
 	len = (int)STRLEN(spec_str[i]);
 	if (STRNCMP(src, spec_str[i], len) == 0)
@@ -9506,24 +9558,50 @@
 		    break;
 		}
 		s = src + 1;
+		if (*s == '<')		/* "#<99" uses v:oldfiles */
+		    ++s;
 		i = (int)getdigits(&s);
 		*usedlen = (int)(s - src); /* length of what we expand */
 
-		buf = buflist_findnr(i);
-		if (buf == NULL)
+		if (src[1] == '<')
 		{
-		    *errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
+		    if (*usedlen < 2)
+		    {
+			/* Should we give an error message for #<text? */
+			*usedlen = 1;
+			return NULL;
+		    }
+#ifdef FEAT_EVAL
+		    result = list_find_str(get_vim_var_list(VV_OLDFILES),
+								     (long)i);
+		    if (result == NULL)
+		    {
+			*errormsg = (char_u *)"";
+			return NULL;
+		    }
+#else
+		    *errormsg = (char_u *)_("E809: #< is not available without the +eval feature");
 		    return NULL;
+#endif
 		}
-		if (lnump != NULL)
-		    *lnump = ECMD_LAST;
-		if (buf->b_fname == NULL)
+		else
 		{
-		    result = (char_u *)"";
-		    valid = 0;	    /* Must have ":p:h" to be valid */
+		    buf = buflist_findnr(i);
+		    if (buf == NULL)
+		    {
+			*errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
+			return NULL;
+		    }
+		    if (lnump != NULL)
+			*lnump = ECMD_LAST;
+		    if (buf->b_fname == NULL)
+		    {
+			result = (char_u *)"";
+			valid = 0;	    /* Must have ":p:h" to be valid */
+		    }
+		    else
+			result = buf->b_fname;
 		}
-		else
-		    result = buf->b_fname;
 		break;
 
 #ifdef FEAT_SEARCHPATH
@@ -9541,6 +9619,15 @@
 #ifdef FEAT_AUTOCMD
 	case SPEC_AFILE:	/* file name for autocommand */
 		result = autocmd_fname;
+		if (result != NULL && !autocmd_fname_full)
+		{
+		    /* Still need to turn the fname into a full path.  It is
+		     * postponed to avoid a delay when <afile> is not used. */
+		    autocmd_fname_full = TRUE;
+		    result = FullName_save(autocmd_fname, FALSE);
+		    vim_free(autocmd_fname);
+		    autocmd_fname = result;
+		}
 		if (result == NULL)
 		{
 		    *errormsg = (char_u *)_("E495: no autocommand file name to substitute for \"<afile>\"");
@@ -9684,7 +9771,7 @@
 	}
 
 	/* allocate memory */
-	retval = alloc(len + 1);
+	retval = alloc((unsigned)len + 1);
 	if (retval == NULL)
 	    break;
     }
@@ -10067,7 +10154,7 @@
      */
     if (put_line(fd, "let s:sx = expand(\"<sfile>:p:r\").\"x.vim\"") == FAIL
 	    || put_line(fd, "if file_readable(s:sx)") == FAIL
-	    || put_line(fd, "  exe \"source \" . s:sx") == FAIL
+	    || put_line(fd, "  exe \"source \" . fnameescape(s:sx)") == FAIL
 	    || put_line(fd, "endif") == FAIL)
 	return FAIL;
 
@@ -10689,7 +10776,8 @@
 	p_viminfo = (char_u *)"'100";
     if (eap->cmdidx == CMD_rviminfo)
     {
-	if (read_viminfo(eap->arg, TRUE, TRUE, eap->forceit) == FAIL)
+	if (read_viminfo(eap->arg, VIF_WANT_INFO | VIF_WANT_MARKS
+				  | (eap->forceit ? VIF_FORCEIT : 0)) == FAIL)
 	    EMSG(_("E195: Cannot open viminfo file for reading"));
     }
     else
@@ -10850,10 +10938,9 @@
 }
 #endif
 
-/*ARGSUSED*/
     static void
 ex_digraphs(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_DIGRAPHS
     if (*eap->arg != NUL)
@@ -10887,10 +10974,9 @@
 /*
  * ":nohlsearch"
  */
-/*ARGSUSED*/
     static void
 ex_nohlsearch(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     no_hlsearch = TRUE;
     redraw_all_later(SOME_VALID);
@@ -10969,10 +11055,9 @@
 /*
  * ":X": Get crypt key
  */
-/*ARGSUSED*/
     static void
 ex_X(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     (void)get_crypt_key(TRUE, TRUE);
 }
diff -Naur vim72.orig/src/ex_eval.c vim72/src/ex_eval.c
--- vim72.orig/src/ex_eval.c	2007-11-24 07:34:09.000000000 -0800
+++ vim72/src/ex_eval.c	2009-06-05 14:25:02.000000000 -0700
@@ -60,7 +60,9 @@
 #else
 /* Values used for the Vim release. */
 # define THROW_ON_ERROR		TRUE
+# define THROW_ON_ERROR_TRUE
 # define THROW_ON_INTERRUPT	TRUE
+# define THROW_ON_INTERRUPT_TRUE
 #endif
 
 static void	catch_exception __ARGS((except_T *excp));
@@ -1320,16 +1322,20 @@
      * and reset the did_emsg or got_int flag, so this won't happen again at
      * the next surrounding try conditional.
      */
+#ifndef THROW_ON_ERROR_TRUE
     if (did_emsg && !THROW_ON_ERROR)
     {
 	inactivate_try = TRUE;
 	did_emsg = FALSE;
     }
+#endif
+#ifndef THROW_ON_INTERRUPT_TRUE
     if (got_int && !THROW_ON_INTERRUPT)
     {
 	inactivate_try = TRUE;
 	got_int = FALSE;
     }
+#endif
     idx = cleanup_conditionals(cstack, 0, inactivate_try);
     if (idx >= 0)
     {
@@ -2254,10 +2260,9 @@
 /*
  * ":endfunction" when not after a ":function"
  */
-/*ARGSUSED*/
     void
 ex_endfunction(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     EMSG(_("E193: :endfunction not inside a function"));
 }
diff -Naur vim72.orig/src/ex_getln.c vim72/src/ex_getln.c
--- vim72.orig/src/ex_getln.c	2008-08-08 02:31:33.000000000 -0700
+++ vim72/src/ex_getln.c	2009-06-05 14:25:02.000000000 -0700
@@ -31,6 +31,8 @@
     int		cmdattr;	/* attributes for prompt */
     int		overstrike;	/* Typing mode on the command line.  Shared by
 				   getcmdline() and put_on_cmdline(). */
+    expand_T	*xpc;		/* struct being used for expansion, xp_pattern
+				   may point into cmdbuff */
     int		xp_context;	/* type of expansion */
 # ifdef FEAT_EVAL
     char_u	*xp_arg;	/* user-defined expansion arg */
@@ -38,7 +40,11 @@
 # endif
 };
 
-static struct cmdline_info ccline;	/* current cmdline_info */
+/* The current cmdline_info.  It is initialized in getcmdline() and after that
+ * used by other functions.  When invoking getcmdline() recursively it needs
+ * to be saved with save_cmdline() and restored with restore_cmdline().
+ * TODO: make it local to getcmdline() and pass it around. */
+static struct cmdline_info ccline;
 
 static int	cmd_showtail;		/* Only show path tail in lists ? */
 
@@ -134,11 +140,10 @@
  * Return pointer to allocated string if there is a commandline, NULL
  * otherwise.
  */
-/*ARGSUSED*/
     char_u *
 getcmdline(firstc, count, indent)
     int		firstc;
-    long	count;		/* only used for incremental search */
+    long	count UNUSED;	/* only used for incremental search */
     int		indent;		/* indent for inside conditionals */
 {
     int		c;
@@ -238,6 +243,7 @@
     }
 
     ExpandInit(&xpc);
+    ccline.xpc = &xpc;
 
 #ifdef FEAT_RIGHTLEFT
     if (curwin->w_p_rl && *curwin->w_p_rlc == 's'
@@ -318,7 +324,7 @@
 #endif
 
 #ifdef FEAT_DIGRAPHS
-    do_digraph(-1);		/* init digraph typahead */
+    do_digraph(-1);		/* init digraph typeahead */
 #endif
 
     /*
@@ -408,9 +414,10 @@
 #endif
 
 	/*
-	 * <S-Tab> works like CTRL-P (unless 'wc' is <S-Tab>).
+	 * When there are matching completions to select <S-Tab> works like
+	 * CTRL-P (unless 'wc' is <S-Tab>).
 	 */
-	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles != -1)
+	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)
 	    c = Ctrl_P;
 
 #ifdef FEAT_WILDMENU
@@ -1513,6 +1520,7 @@
 		    int		old_firstc;
 
 		    vim_free(ccline.cmdbuff);
+		    xpc.xp_context = EXPAND_NOTHING;
 		    if (hiscnt == hislen)
 			p = lookfor;	/* back to the old one */
 		    else
@@ -1839,6 +1847,7 @@
 #endif
 
     ExpandCleanup(&xpc);
+    ccline.xpc = NULL;
 
 #ifdef FEAT_SEARCH_EXTRA
     if (did_incsearch)
@@ -1990,8 +1999,8 @@
 
 #if defined(FEAT_AUTOCMD) || defined(PROTO)
 /*
- * Check if "curbuf_lock" is set and return TRUE when it is and give an error
- * message.
+ * Check if "curbuf_lock" or "allbuf_lock" is set and return TRUE when it is
+ * and give an error message.
  */
     int
 curbuf_locked()
@@ -2001,6 +2010,21 @@
 	EMSG(_("E788: Not allowed to edit another buffer now"));
 	return TRUE;
     }
+    return allbuf_locked();
+}
+
+/*
+ * Check if "allbuf_lock" is set and return TRUE when it is and give an error
+ * message.
+ */
+    int
+allbuf_locked()
+{
+    if (allbuf_lock > 0)
+    {
+	EMSG(_("E811: Not allowed to change buffer information now"));
+	return TRUE;
+    }
     return FALSE;
 }
 #endif
@@ -2088,11 +2112,10 @@
 /*
  * Get an Ex command line for the ":" command.
  */
-/* ARGSUSED */
     char_u *
-getexline(c, dummy, indent)
+getexline(c, cookie, indent)
     int		c;		/* normally ':', NUL for ":append" */
-    void	*dummy;		/* cookie not used */
+    void	*cookie UNUSED;
     int		indent;		/* indent for inside conditionals */
 {
     /* When executing a register, remove ':' that's in front of each line. */
@@ -2107,12 +2130,11 @@
  * mappings or abbreviations.
  * Returns a string in allocated memory or NULL.
  */
-/* ARGSUSED */
     char_u *
-getexmodeline(promptc, dummy, indent)
+getexmodeline(promptc, cookie, indent)
     int		promptc;	/* normally ':', NUL for ":append" and '?' for
 				   :s prompt */
-    void	*dummy;		/* cookie not used */
+    void	*cookie UNUSED;
     int		indent;		/* indent for inside conditionals */
 {
     garray_T	line_ga;
@@ -2508,6 +2530,20 @@
     }
     mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen + 1);
     vim_free(p);
+
+    if (ccline.xpc != NULL
+	    && ccline.xpc->xp_pattern != NULL
+	    && ccline.xpc->xp_context != EXPAND_NOTHING
+	    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)
+    {
+	int i = (int)(ccline.xpc->xp_pattern - p);
+
+	/* If xp_pattern points inside the old cmdbuff it needs to be adjusted
+	 * to point into the newly allocated memory. */
+	if (i >= 0 && i <= ccline.cmdlen)
+	    ccline.xpc->xp_pattern = ccline.cmdbuff + i;
+    }
+
     return OK;
 }
 
@@ -2875,6 +2911,7 @@
     prev_ccline = ccline;
     ccline.cmdbuff = NULL;
     ccline.cmdprompt = NULL;
+    ccline.xpc = NULL;
 }
 
 /*
@@ -3582,6 +3619,7 @@
 ExpandInit(xp)
     expand_T	*xp;
 {
+    xp->xp_pattern = NULL;
     xp->xp_backslash = XP_BS_NONE;
 #ifndef BACKSLASH_IN_FILENAME
     xp->xp_shell = FALSE;
@@ -3791,11 +3829,10 @@
  * Returns EXPAND_NOTHING when the character that triggered expansion should
  * be inserted like a normal character.
  */
-/*ARGSUSED*/
     static int
 showmatches(xp, wildmenu)
     expand_T	*xp;
-    int		wildmenu;
+    int		wildmenu UNUSED;
 {
 #define L_SHOWFILE(m) (showtail ? sm_gettail(files_found[m]) : files_found[m])
     int		num_files;
@@ -4477,6 +4514,12 @@
 	    {EXPAND_EVENTS, get_event_name, TRUE},
 	    {EXPAND_AUGROUP, get_augroup_name, TRUE},
 #endif
+#ifdef FEAT_CSCOPE
+	    {EXPAND_CSCOPE, get_cscope_name, TRUE},
+#endif
+#ifdef FEAT_SIGNS
+	    {EXPAND_SIGN, get_sign_name, TRUE},
+#endif
 #if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
 	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
 	    {EXPAND_LANGUAGE, get_lang_arg, TRUE},
@@ -4490,7 +4533,7 @@
 	 * right function to do the expansion.
 	 */
 	ret = FAIL;
-	for (i = 0; i < sizeof(tab) / sizeof(struct expgen); ++i)
+	for (i = 0; i < (int)(sizeof(tab) / sizeof(struct expgen)); ++i)
 	    if (xp->xp_context == tab[i].context)
 	    {
 		if (tab[i].ic)
@@ -4871,7 +4914,7 @@
     if (s == NULL)
 	return FAIL;
     sprintf((char *)s, "%s/%s*.vim", dirname, pat);
-    all = globpath(p_rtp, s);
+    all = globpath(p_rtp, s, 0);
     vim_free(s);
     if (all == NULL)
 	return FAIL;
@@ -4912,9 +4955,10 @@
  * newlines.  Returns NULL for an error or no matches.
  */
     char_u *
-globpath(path, file)
+globpath(path, file, expand_options)
     char_u	*path;
     char_u	*file;
+    int		expand_options;
 {
     expand_T	xpc;
     char_u	*buf;
@@ -4943,10 +4987,10 @@
 	{
 	    add_pathsep(buf);
 	    STRCAT(buf, file);
-	    if (ExpandFromContext(&xpc, buf, &num_p, &p, WILD_SILENT) != FAIL
-								 && num_p > 0)
+	    if (ExpandFromContext(&xpc, buf, &num_p, &p,
+			     WILD_SILENT|expand_options) != FAIL && num_p > 0)
 	    {
-		ExpandEscape(&xpc, buf, num_p, p, WILD_SILENT);
+		ExpandEscape(&xpc, buf, num_p, p, WILD_SILENT|expand_options);
 		for (len = 0, i = 0; i < num_p; ++i)
 		    len += (int)STRLEN(p[i]) + 1;
 
@@ -5641,7 +5685,7 @@
 	histype1 = get_histtype(arg);
 	if (histype1 == -1)
 	{
-	    if (STRICMP(arg, "all") == 0)
+	    if (STRNICMP(arg, "all", STRLEN(arg)) == 0)
 	    {
 		histype1 = 0;
 		histype2 = HIST_COUNT-1;
@@ -6020,9 +6064,7 @@
 # endif
 	return K_IGNORE;
     }
-    cmdwin_type = ccline.cmdfirstc;
-    if (cmdwin_type == NUL)
-	cmdwin_type = '-';
+    cmdwin_type = get_cmdline_type();
 
     /* Create the command-line buffer empty. */
     (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE);
@@ -6030,6 +6072,9 @@
     set_option_value((char_u *)"bt", 0L, (char_u *)"nofile", OPT_LOCAL);
     set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
     curbuf->b_p_ma = TRUE;
+#ifdef FEAT_FOLDING
+    curwin->w_p_fen = FALSE;
+#endif
 # ifdef FEAT_RIGHTLEFT
     curwin->w_p_rl = cmdmsg_rl;
     cmdmsg_rl = FALSE;
@@ -6046,7 +6091,7 @@
     /* Showing the prompt may have set need_wait_return, reset it. */
     need_wait_return = FALSE;
 
-    histtype = hist_char2type(ccline.cmdfirstc);
+    histtype = hist_char2type(cmdwin_type);
     if (histtype == HIST_CMD || histtype == HIST_DEBUG)
     {
 	if (p_wc == TAB)
diff -Naur vim72.orig/src/farsi.c vim72/src/farsi.c
--- vim72.orig/src/farsi.c	2007-12-31 08:28:10.000000000 -0800
+++ vim72/src/farsi.c	2009-06-05 14:25:02.000000000 -0700
@@ -103,7 +103,8 @@
 	case F_HE:
 		tempc = _HE;
 
-		if (p_ri && (curwin->w_cursor.col+1 < STRLEN(ml_get_curline())))
+		if (p_ri && (curwin->w_cursor.col + 1
+					 < (colnr_T)STRLEN(ml_get_curline())))
 		{
 		    inc_cursor();
 
@@ -344,7 +345,7 @@
     if (curwin->w_p_rl && p_ri)
 	return;
 
-    if ( (curwin->w_cursor.col < STRLEN(ml_get_curline())))
+    if ((curwin->w_cursor.col < (colnr_T)STRLEN(ml_get_curline())))
     {
 	if ((p_ri && curwin->w_cursor.col) || !p_ri)
 	{
@@ -565,7 +566,7 @@
 
     tempc = gchar_cursor();
 
-    if (curwin->w_cursor.col+1 < STRLEN(ml_get_curline()))
+    if (curwin->w_cursor.col + 1 < (colnr_T)STRLEN(ml_get_curline()))
     {
 	inc_cursor();
 
@@ -594,8 +595,8 @@
 {
     int	tempc;
 
-    if (!curwin->w_cursor.col &&
-	(curwin->w_cursor.col+1 == STRLEN(ml_get_curline())))
+    if (curwin->w_cursor.col != 0 &&
+	(curwin->w_cursor.col + 1 == (colnr_T)STRLEN(ml_get_curline())))
 	return;
 
     if (!curwin->w_cursor.col && p_ri)
@@ -663,8 +664,8 @@
 {
     int	tempc;
 
-    if (!curwin->w_cursor.col &&
-	(curwin->w_cursor.col+1 == STRLEN(ml_get_curline())))
+    if (curwin->w_cursor.col != 0 &&
+	(curwin->w_cursor.col + 1 == (colnr_T)STRLEN(ml_get_curline())))
 	return;
 
     if (!curwin->w_cursor.col && p_ri)
diff -Naur vim72.orig/src/feature.h vim72/src/feature.h
--- vim72.orig/src/feature.h	2008-08-06 04:00:39.000000000 -0700
+++ vim72/src/feature.h	2009-06-05 14:16:09.000000000 -0700
@@ -767,9 +767,13 @@
 
 /*
  * +browse		":browse" command.
+ *			or just the ":browse" command modifier
  */
-#if defined(FEAT_NORMAL) && (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC))
-# define FEAT_BROWSE
+#if defined(FEAT_NORMAL)
+# define FEAT_BROWSE_CMD
+# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
+#  define FEAT_BROWSE
+# endif
 #endif
 
 /*
diff -Naur vim72.orig/src/fileio.c vim72/src/fileio.c
--- vim72.orig/src/fileio.c	2008-08-06 04:01:03.000000000 -0700
+++ vim72/src/fileio.c	2009-06-05 14:25:02.000000000 -0700
@@ -69,7 +69,7 @@
 static int au_find_group __ARGS((char_u *name));
 
 # define AUGROUP_DEFAULT    -1	    /* default autocmd group */
-# define AUGROUP_ERROR	    -2	    /* errornouse autocmd group */
+# define AUGROUP_ERROR	    -2	    /* erroneous autocmd group */
 # define AUGROUP_ALL	    -3	    /* all autocmd groups */
 #endif
 
@@ -144,7 +144,9 @@
 # endif
 #endif
 static int move_lines __ARGS((buf_T *frombuf, buf_T *tobuf));
-
+#ifdef FEAT_AUTOCMD
+static char *e_auchangedbuf = N_("E812: Autocommands changed buffer or buffer name");
+#endif
 
     void
 filemess(buf, name, s, attr)
@@ -295,6 +297,19 @@
     int		conv_restlen = 0;	/* nr of bytes in conv_rest[] */
 #endif
 
+#ifdef FEAT_AUTOCMD
+    /* Remember the initial values of curbuf, curbuf->b_ffname and
+     * curbuf->b_fname to detect whether they are altered as a result of
+     * executing nasty autocommands.  Also check if "fname" and "sfname"
+     * point to one of these values. */
+    buf_T   *old_curbuf = curbuf;
+    char_u  *old_b_ffname = curbuf->b_ffname;
+    char_u  *old_b_fname = curbuf->b_fname;
+    int     using_b_ffname = (fname == curbuf->b_ffname)
+					      || (sfname == curbuf->b_ffname);
+    int     using_b_fname = (fname == curbuf->b_fname)
+					       || (sfname == curbuf->b_fname);
+#endif
     write_no_eol_lnum = 0;	/* in case it was set by the previous read */
 
     /*
@@ -589,7 +604,21 @@
 #ifdef FEAT_QUICKFIX
 		    if (!bt_dontwrite(curbuf))
 #endif
+		    {
 			check_need_swap(newfile);
+#ifdef FEAT_AUTOCMD
+			/* SwapExists autocommand may mess things up */
+			if (curbuf != old_curbuf
+				|| (using_b_ffname
+					&& (old_b_ffname != curbuf->b_ffname))
+				|| (using_b_fname
+					 && (old_b_fname != curbuf->b_fname)))
+			{
+			    EMSG(_(e_auchangedbuf));
+			    return FAIL;
+			}
+#endif
+		    }
 		    if (dir_of_file_exists(fname))
 			filemess(curbuf, sfname, (char_u *)_("[New File]"), 0);
 		    else
@@ -668,6 +697,17 @@
 #endif
     {
 	check_need_swap(newfile);
+#ifdef FEAT_AUTOCMD
+	if (!read_stdin && (curbuf != old_curbuf
+		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
+		|| (using_b_fname && (old_b_fname != curbuf->b_fname))))
+	{
+	    EMSG(_(e_auchangedbuf));
+	    if (!read_buffer)
+		close(fd);
+	    return FAIL;
+	}
+#endif
 #ifdef UNIX
 	/* Set swap file protection bits after creating it. */
 	if (swap_mode > 0 && curbuf->b_ml.ml_mfp->mf_fname != NULL)
@@ -698,7 +738,6 @@
     {
 	int	m = msg_scroll;
 	int	n = msg_scrolled;
-	buf_T	*old_curbuf = curbuf;
 
 	/*
 	 * The file must be closed again, the autocommands may want to change
@@ -740,8 +779,13 @@
 	/*
 	 * Don't allow the autocommands to change the current buffer.
 	 * Try to re-open the file.
+	 *
+	 * Don't allow the autocommands to change the buffer name either
+	 * (cd for example) if it invalidates fname or sfname.
 	 */
 	if (!read_stdin && (curbuf != old_curbuf
+		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
+		|| (using_b_fname && (old_b_fname != curbuf->b_fname))
 		|| (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) < 0))
 	{
 	    --no_wait_return;
@@ -932,7 +976,10 @@
     else
     {
 	if (eap != NULL && eap->force_ff != 0)
+	{
 	    fileformat = get_fileformat_force(curbuf, eap);
+	    try_unix = try_dos = try_mac = FALSE;
+	}
 	else if (curbuf->b_p_bin)
 	    fileformat = EOL_UNIX;		/* binary: use Unix format */
 	else if (*p_ffs == NUL)
@@ -2211,7 +2258,7 @@
     {
 	/* Use stderr for stdin, makes shell commands work. */
 	close(0);
-	dup(2);
+	ignored = dup(2);
     }
 #endif
 
@@ -2341,11 +2388,6 @@
 		STRCAT(IObuff, _("[CR missing]"));
 		c = TRUE;
 	    }
-	    if (ff_error == EOL_MAC)
-	    {
-		STRCAT(IObuff, _("[NL found]"));
-		c = TRUE;
-	    }
 	    if (split)
 	    {
 		STRCAT(IObuff, _("[long lines split]"));
@@ -2711,7 +2753,7 @@
 {
     if (!curbuf->b_marks_read && get_viminfo_parameter('\'') > 0
 						  && curbuf->b_ffname != NULL)
-	read_viminfo(NULL, FALSE, TRUE, FALSE);
+	read_viminfo(NULL, VIF_WANT_MARKS);
 
     /* Always set b_marks_read; needed when 'viminfo' is changed to include
      * the ' parameter after opening a buffer. */
@@ -3451,12 +3493,12 @@
 		{
 # ifdef UNIX
 #  ifdef HAVE_FCHOWN
-		    fchown(fd, st_old.st_uid, st_old.st_gid);
+		    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);
 #  endif
 		    if (mch_stat((char *)IObuff, &st) < 0
 			    || st.st_uid != st_old.st_uid
 			    || st.st_gid != st_old.st_gid
-			    || st.st_mode != perm)
+			    || (long)st.st_mode != perm)
 			backup_copy = TRUE;
 # endif
 		    /* Close the file before removing it, on MS-Windows we
@@ -4367,14 +4409,14 @@
 		|| st.st_uid != st_old.st_uid
 		|| st.st_gid != st_old.st_gid)
 	{
-	    fchown(fd, st_old.st_uid, st_old.st_gid);
+	    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);
 	    if (perm >= 0)	/* set permission again, may have changed */
 		(void)mch_setperm(wfname, perm);
 	}
 # endif
 	buf_setino(buf);
     }
-    else if (buf->b_dev < 0)
+    else if (!buf->b_dev_valid)
 	/* Set the inode when creating a new file. */
 	buf_setino(buf);
 #endif
@@ -5246,13 +5288,16 @@
 	    /* Convert with iconv(). */
 	    if (ip->bw_restlen > 0)
 	    {
+		char *fp;
+
 		/* Need to concatenate the remainder of the previous call and
 		 * the bytes of the current call.  Use the end of the
 		 * conversion buffer for this. */
 		fromlen = len + ip->bw_restlen;
-		from = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;
-		mch_memmove((void *)from, ip->bw_rest, (size_t)ip->bw_restlen);
-		mch_memmove((void *)(from + ip->bw_restlen), buf, (size_t)len);
+		fp = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;
+		mch_memmove(fp, ip->bw_rest, (size_t)ip->bw_restlen);
+		mch_memmove(fp + ip->bw_restlen, buf, (size_t)len);
+		from = fp;
 		tolen = ip->bw_conv_buflen - fromlen;
 	    }
 	    else
@@ -5550,9 +5595,10 @@
 	    name = "ucs-4le";	/* FF FE 00 00 */
 	    len = 4;
 	}
-	else if (flags == FIO_ALL || flags == (FIO_UCS2 | FIO_ENDIAN_L))
+	else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))
 	    name = "ucs-2le";	/* FF FE */
-	else if (flags == (FIO_UTF16 | FIO_ENDIAN_L))
+	else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))
+	    /* utf-16le is preferred, it also works for ucs-2le text */
 	    name = "utf-16le";	/* FF FE */
     }
     else if (p[0] == 0xfe && p[1] == 0xff
@@ -5917,7 +5963,7 @@
 	else if (*ext == '.')
 #endif
 	{
-	    if (s - ptr > (size_t)8)
+	    if ((size_t)(s - ptr) > (size_t)8)
 	    {
 		s = ptr + 8;
 		*s = '\0';
@@ -6031,9 +6077,9 @@
 	{
 	    tbuf[FGETS_SIZE - 2] = NUL;
 #ifdef USE_CR
-	    fgets_cr((char *)tbuf, FGETS_SIZE, fp);
+	    ignoredp = fgets_cr((char *)tbuf, FGETS_SIZE, fp);
 #else
-	    fgets((char *)tbuf, FGETS_SIZE, fp);
+	    ignoredp = fgets((char *)tbuf, FGETS_SIZE, fp);
 #endif
 	} while (tbuf[FGETS_SIZE - 2] != NUL && tbuf[FGETS_SIZE - 2] != '\n');
     }
@@ -6107,12 +6153,24 @@
 #ifdef HAVE_ACL
     vim_acl_T	acl;		/* ACL from original file */
 #endif
+#if defined(UNIX) || defined(CASE_INSENSITIVE_FILENAME)
+    int		use_tmp_file = FALSE;
+#endif
 
     /*
-     * When the names are identical, there is nothing to do.
+     * When the names are identical, there is nothing to do.  When they refer
+     * to the same file (ignoring case and slash/backslash differences) but
+     * the file name differs we need to go through a temp file.
      */
     if (fnamecmp(from, to) == 0)
-	return 0;
+    {
+#ifdef CASE_INSENSITIVE_FILENAME
+	if (STRCMP(gettail(from), gettail(to)) != 0)
+	    use_tmp_file = TRUE;
+	else
+#endif
+	    return 0;
+    }
 
     /*
      * Fail if the "from" file doesn't exist.  Avoids that "to" is deleted.
@@ -6120,6 +6178,55 @@
     if (mch_stat((char *)from, &st) < 0)
 	return -1;
 
+#ifdef UNIX
+    {
+	struct stat	st_to;
+
+	/* It's possible for the source and destination to be the same file.
+	 * This happens when "from" and "to" differ in case and are on a FAT32
+	 * filesystem.  In that case go through a temp file name. */
+	if (mch_stat((char *)to, &st_to) >= 0
+		&& st.st_dev == st_to.st_dev
+		&& st.st_ino == st_to.st_ino)
+	    use_tmp_file = TRUE;
+    }
+#endif
+
+#if defined(UNIX) || defined(CASE_INSENSITIVE_FILENAME)
+    if (use_tmp_file)
+    {
+	char	tempname[MAXPATHL + 1];
+
+	/*
+	 * Find a name that doesn't exist and is in the same directory.
+	 * Rename "from" to "tempname" and then rename "tempname" to "to".
+	 */
+	if (STRLEN(from) >= MAXPATHL - 5)
+	    return -1;
+	STRCPY(tempname, from);
+	for (n = 123; n < 99999; ++n)
+	{
+	    sprintf((char *)gettail((char_u *)tempname), "%d", n);
+	    if (mch_stat(tempname, &st) < 0)
+	    {
+		if (mch_rename((char *)from, tempname) == 0)
+		{
+		    if (mch_rename(tempname, (char *)to) == 0)
+			return 0;
+		    /* Strange, the second step failed.  Try moving the
+		     * file back and return failure. */
+		    mch_rename(tempname, (char *)from);
+		    return -1;
+		}
+		/* If it fails for one temp name it will most likely fail
+		 * for any temp name, give up. */
+		return -1;
+	    }
+	}
+	return -1;
+    }
+#endif
+
     /*
      * Delete the "to" file, this is required on some systems to make the
      * mch_rename() work, on other systems it makes sure that we don't have
@@ -6260,7 +6367,7 @@
 
     if (!stuff_empty() || global_busy || !typebuf_typed()
 #ifdef FEAT_AUTOCMD
-			|| autocmd_busy || curbuf_lock > 0
+			|| autocmd_busy || curbuf_lock > 0 || allbuf_lock > 0
 #endif
 					)
 	need_check_timestamps = TRUE;		/* check later */
@@ -6353,11 +6460,10 @@
  * return 2 if a message has been displayed.
  * return 0 otherwise.
  */
-/*ARGSUSED*/
     int
 buf_check_timestamp(buf, focus)
     buf_T	*buf;
-    int		focus;		/* called for GUI focus event */
+    int		focus UNUSED;	/* called for GUI focus event */
 {
     struct stat	st;
     int		stat_res;
@@ -6462,8 +6568,10 @@
 	    set_vim_var_string(VV_FCS_REASON, (char_u *)reason, -1);
 	    set_vim_var_string(VV_FCS_CHOICE, (char_u *)"", -1);
 # endif
+	    ++allbuf_lock;
 	    n = apply_autocmds(EVENT_FILECHANGEDSHELL,
 				      buf->b_fname, buf->b_fname, FALSE, buf);
+	    --allbuf_lock;
 	    busy = FALSE;
 	    if (n)
 	    {
@@ -6538,6 +6646,11 @@
 	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
 							+ STRLEN(mesg2) + 2));
 	    sprintf((char *)tbuf, mesg, path);
+#ifdef FEAT_EVAL
+	    /* Set warningmsg here, before the unimportant and output-specific
+	     * mesg2 has been appended. */
+	    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);
+#endif
 #if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)
 	    if (can_reload)
 	    {
@@ -6732,10 +6845,11 @@
 #endif
 #ifdef FEAT_FOLDING
 	{
-	    win_T *wp;
+	    win_T	*wp;
+	    tabpage_T	*tp;
 
 	    /* Update folds unless they are defined manually. */
-	    FOR_ALL_WINDOWS(wp)
+	    FOR_ALL_TAB_WINDOWS(tp, wp)
 		if (wp->w_buffer == curwin->w_buffer
 			&& !foldmethodIsManual(wp))
 		    foldUpdateAll(wp);
@@ -6753,12 +6867,11 @@
     /* Careful: autocommands may have made "buf" invalid! */
 }
 
-/*ARGSUSED*/
     void
 buf_store_time(buf, st, fname)
     buf_T	*buf;
     struct stat	*st;
-    char_u	*fname;
+    char_u	*fname UNUSED;
 {
     buf->b_mtime = (long)st->st_mtime;
     buf->b_orig_size = (size_t)st->st_size;
@@ -6821,10 +6934,9 @@
  * The returned pointer is to allocated memory.
  * The returned pointer is NULL if no valid name was found.
  */
-/*ARGSUSED*/
     char_u  *
 vim_tempname(extra_char)
-    int	    extra_char;	    /* character to use in the name instead of '?' */
+    int	    extra_char UNUSED;  /* char to use in the name instead of '?' */
 {
 #ifdef USE_TMPNAM
     char_u	itmp[L_tmpnam];	/* use tmpnam() */
@@ -6853,7 +6965,7 @@
 	/*
 	 * Try the entries in TEMPDIRNAMES to create the temp directory.
 	 */
-	for (i = 0; i < sizeof(tempdirs) / sizeof(char *); ++i)
+	for (i = 0; i < (int)(sizeof(tempdirs) / sizeof(char *)); ++i)
 	{
 	    /* expand $TMP, leave room for "/v1100000/999999999" */
 	    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);
@@ -8523,6 +8635,7 @@
     char_u	*save_sourcing_name;
     linenr_T	save_sourcing_lnum;
     char_u	*save_autocmd_fname;
+    int		save_autocmd_fname_full;
     int		save_autocmd_bufnr;
     char_u	*save_autocmd_match;
     int		save_autocmd_busy;
@@ -8601,6 +8714,7 @@
      * Save the autocmd_* variables and info about the current buffer.
      */
     save_autocmd_fname = autocmd_fname;
+    save_autocmd_fname_full = autocmd_fname_full;
     save_autocmd_bufnr = autocmd_bufnr;
     save_autocmd_match = autocmd_match;
     save_autocmd_busy = autocmd_busy;
@@ -8618,14 +8732,15 @@
 	if (fname != NULL && *fname != NUL)
 	    autocmd_fname = fname;
 	else if (buf != NULL)
-	    autocmd_fname = buf->b_fname;
+	    autocmd_fname = buf->b_ffname;
 	else
 	    autocmd_fname = NULL;
     }
     else
 	autocmd_fname = fname_io;
     if (autocmd_fname != NULL)
-	autocmd_fname = FullName_save(autocmd_fname, FALSE);
+	autocmd_fname = vim_strsave(autocmd_fname);
+    autocmd_fname_full = FALSE; /* call FullName_save() later */
 
     /*
      * Set the buffer number to be used for <abuf>.
@@ -8667,9 +8782,11 @@
     else
     {
 	sfname = vim_strsave(fname);
-	/* Don't try expanding FileType, Syntax, WindowID or QuickFixCmd* */
+	/* Don't try expanding FileType, Syntax, FuncUndefined, WindowID or
+	 * QuickFixCmd* */
 	if (event == EVENT_FILETYPE
 		|| event == EVENT_SYNTAX
+		|| event == EVENT_FUNCUNDEFINED
 		|| event == EVENT_REMOTEREPLY
 		|| event == EVENT_SPELLFILEMISSING
 		|| event == EVENT_QUICKFIXCMDPRE
@@ -8810,6 +8927,7 @@
     sourcing_lnum = save_sourcing_lnum;
     vim_free(autocmd_fname);
     autocmd_fname = save_autocmd_fname;
+    autocmd_fname_full = save_autocmd_fname_full;
     autocmd_bufnr = save_autocmd_bufnr;
     autocmd_match = save_autocmd_match;
 #ifdef FEAT_EVAL
@@ -8918,7 +9036,7 @@
     {
 	apc->curpat = NULL;
 
-	/* only use a pattern when it has not been removed, has commands and
+	/* Only use a pattern when it has not been removed, has commands and
 	 * the group matches. For buffer-local autocommands only check the
 	 * buffer number. */
 	if (ap->pat != NULL && ap->cmds != NULL
@@ -8967,12 +9085,11 @@
  * Called by do_cmdline() to get the next line for ":if".
  * Returns allocated string, or NULL for end of autocommands.
  */
-/* ARGSUSED */
     static char_u *
 getnextac(c, cookie, indent)
-    int	    c;		    /* not used */
+    int	    c UNUSED;
     void    *cookie;
-    int	    indent;	    /* not used */
+    int	    indent UNUSED;
 {
     AutoPatCmd	    *acp = (AutoPatCmd *)cookie;
     char_u	    *retval;
@@ -9083,10 +9200,9 @@
  * Function given to ExpandGeneric() to obtain the list of autocommand group
  * names.
  */
-/*ARGSUSED*/
     char_u *
 get_augroup_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx == augroups.ga_len)		/* add "END" add the end */
@@ -9104,7 +9220,7 @@
 set_context_in_autocmd(xp, arg, doautocmd)
     expand_T	*xp;
     char_u	*arg;
-    int		doautocmd;	/* TRUE for :doautocmd, FALSE for :autocmd */
+    int		doautocmd;	/* TRUE for :doauto*, FALSE for :autocmd */
 {
     char_u	*p;
     int		group;
@@ -9152,10 +9268,9 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of event names.
  */
-/*ARGSUSED*/
     char_u *
 get_event_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx < augroups.ga_len)		/* First list group names, if wanted */
@@ -9467,13 +9582,12 @@
  *
  * Returns NULL when out of memory.
  */
-/*ARGSUSED*/
     char_u *
 file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)
     char_u	*pat;
     char_u	*pat_end;	/* first char after pattern or NULL */
     char	*allow_dirs;	/* Result passed back out in here */
-    int		no_bslash;	/* Don't use a backward slash as pathsep */
+    int		no_bslash UNUSED; /* Don't use a backward slash as pathsep */
 {
     int		size;
     char_u	*endp;
diff -Naur vim72.orig/src/fold.c vim72/src/fold.c
--- vim72.orig/src/fold.c	2008-08-06 04:01:12.000000000 -0700
+++ vim72/src/fold.c	2009-06-05 14:19:21.000000000 -0700
@@ -48,7 +48,7 @@
 static int foldFind __ARGS((garray_T *gap, linenr_T lnum, fold_T **fpp));
 static int foldLevelWin __ARGS((win_T *wp, linenr_T lnum));
 static void checkupdate __ARGS((win_T *wp));
-static void setFoldRepeat __ARGS((linenr_T lnum, long count, int open));
+static void setFoldRepeat __ARGS((linenr_T lnum, long count, int do_open));
 static linenr_T setManualFold __ARGS((linenr_T lnum, int opening, int recurse, int *donep));
 static linenr_T setManualFoldWin __ARGS((win_T *wp, linenr_T lnum, int opening, int recurse, int *donep));
 static void foldOpenNested __ARGS((fold_T *fpr));
@@ -740,7 +740,7 @@
     garray_T	*found_ga;
     fold_T	*found_fp = NULL;
     linenr_T	found_off = 0;
-    int		use_level = FALSE;
+    int		use_level;
     int		maybe_small = FALSE;
     int		level = 0;
     linenr_T	lnum = start;
@@ -757,6 +757,7 @@
 	gap = &curwin->w_folds;
 	found_ga = NULL;
 	lnum_off = 0;
+	use_level = FALSE;
 	for (;;)
 	{
 	    if (!foldFind(gap, lnum - lnum_off, &fp))
@@ -783,20 +784,21 @@
 	else
 	{
 	    lnum = found_fp->fd_top + found_fp->fd_len + found_off;
-	    did_one = TRUE;
 
 	    if (foldmethodIsManual(curwin))
 		deleteFoldEntry(found_ga,
 		    (int)(found_fp - (fold_T *)found_ga->ga_data), recursive);
 	    else
 	    {
-		if (found_fp->fd_top + found_off < first_lnum)
-		    first_lnum = found_fp->fd_top;
-		if (lnum > last_lnum)
+		if (first_lnum > found_fp->fd_top + found_off)
+		    first_lnum = found_fp->fd_top + found_off;
+		if (last_lnum < lnum)
 		    last_lnum = lnum;
-		parseMarker(curwin);
+		if (!did_one)
+		    parseMarker(curwin);
 		deleteFoldMarkers(found_fp, recursive, found_off);
 	    }
+	    did_one = TRUE;
 
 	    /* redraw window */
 	    changed_window_setting();
@@ -811,6 +813,10 @@
 	    redraw_curbuf_later(INVERTED);
 #endif
     }
+    else
+	/* Deleting markers may make cursor column invalid. */
+	check_cursor_col();
+
     if (last_lnum > 0)
 	changed_lines(first_lnum, (colnr_T)0, last_lnum, 0L);
 }
@@ -1241,10 +1247,10 @@
  * Repeat "count" times.
  */
     static void
-setFoldRepeat(lnum, count, open)
+setFoldRepeat(lnum, count, do_open)
     linenr_T	lnum;
     long	count;
-    int		open;
+    int		do_open;
 {
     int		done;
     long	n;
@@ -1252,7 +1258,7 @@
     for (n = 0; n < count; ++n)
     {
 	done = DONE_NOTHING;
-	(void)setManualFold(lnum, open, FALSE, &done);
+	(void)setManualFold(lnum, do_open, FALSE, &done);
 	if (!(done & DONE_ACTION))
 	{
 	    /* Only give an error message when no fold could be opened. */
diff -Naur vim72.orig/src/getchar.c vim72/src/getchar.c
--- vim72.orig/src/getchar.c	2008-07-22 09:57:48.000000000 -0700
+++ vim72/src/getchar.c	2009-06-05 14:22:17.000000000 -0700
@@ -3816,7 +3816,11 @@
     int len = 1;
 
     if (msg_didout || msg_silent != 0)
+    {
 	msg_putchar('\n');
+	if (got_int)	    /* 'q' typed at MORE prompt */
+	    return;
+    }
     if ((mp->m_mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)
 	msg_putchar('!');			/* :map! */
     else if (mp->m_mode & INSERT)
@@ -4702,7 +4706,7 @@
 			return FAIL;
 		    if (mp->m_noremap != REMAP_YES && fprintf(fd, "nore") < 0)
 			return FAIL;
-		    if (fprintf(fd, cmd) < 0)
+		    if (fputs(cmd, fd) < 0)
 			return FAIL;
 		    if (buf != NULL && fputs(" <buffer>", fd) < 0)
 			return FAIL;
@@ -4801,7 +4805,7 @@
 	    }
 	    if (IS_SPECIAL(c) || modifiers)	/* special key */
 	    {
-		if (fprintf(fd, (char *)get_special_key_name(c, modifiers)) < 0)
+		if (fputs((char *)get_special_key_name(c, modifiers), fd) < 0)
 		    return FAIL;
 		continue;
 	    }
diff -Naur vim72.orig/src/globals.h vim72/src/globals.h
--- vim72.orig/src/globals.h	2008-07-26 04:53:29.000000000 -0700
+++ vim72/src/globals.h	2009-06-05 14:24:27.000000000 -0700
@@ -482,8 +482,10 @@
 /*
  * While executing external commands or in Ex mode, should not insert GUI
  * events in the input buffer: Set hold_gui_events to non-zero.
+ *
+ * volatile because it is used in signal handler sig_sysmouse().
  */
-EXTERN int	hold_gui_events INIT(= 0);
+EXTERN volatile int hold_gui_events INIT(= 0);
 
 /*
  * When resizing the shell is postponed, remember the new size, and call
@@ -522,7 +524,7 @@
 EXTERN win_T	*prevwin INIT(= NULL);	/* previous window */
 # define W_NEXT(wp) ((wp)->w_next)
 # define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)
-#define FOR_ALL_TAB_WINDOWS(tp, wp) \
+# define FOR_ALL_TAB_WINDOWS(tp, wp) \
     for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next) \
 	for ((wp) = ((tp) == curtab) \
 		? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)
@@ -597,7 +599,8 @@
 EXTERN int	really_exiting INIT(= FALSE);
 				/* TRUE when we are sure to exit, e.g., after
 				 * a deadly signal */
-EXTERN int	full_screen INIT(= FALSE);
+/* volatile because it is used in signal handler deathtrap(). */
+EXTERN volatile int full_screen INIT(= FALSE);
 				/* TRUE when doing full-screen output
 				 * otherwise only writing some messages */
 
@@ -616,6 +619,11 @@
 EXTERN int	curbuf_lock INIT(= 0);
 				/* non-zero when the current buffer can't be
 				 * changed.  Used for FileChangedRO. */
+EXTERN int	allbuf_lock INIT(= 0);
+				/* non-zero when no buffer name can be
+				 * changed, no buffer can be deleted and
+				 * current directory can't be changed.
+				 * Used for SwapExists et al. */
 #endif
 #ifdef FEAT_EVAL
 # define HAVE_SANDBOX
@@ -710,7 +718,7 @@
 
 EXTERN pos_T	saved_cursor		/* w_cursor before formatting text. */
 # ifdef DO_INIT
-	= INIT_POS_T
+	= INIT_POS_T(0, 0, 0)
 # endif
 	;
 
@@ -739,10 +747,12 @@
  */
 EXTERN JMP_BUF lc_jump_env;	/* argument to SETJMP() */
 # ifdef SIGHASARG
-EXTERN int lc_signal;		/* catched signal number, 0 when no was signal
-				   catched; used for mch_libcall() */
+/* volatile because it is used in signal handlers. */
+EXTERN volatile int lc_signal;	/* caught signal number, 0 when no was signal
+				   caught; used for mch_libcall() */
 # endif
-EXTERN int lc_active INIT(= FALSE); /* TRUE when lc_jump_env is valid. */
+/* volatile because it is used in signal handler deathtrap(). */
+EXTERN volatile int lc_active INIT(= FALSE); /* TRUE when lc_jump_env is valid. */
 #endif
 
 #if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT)
@@ -986,7 +996,8 @@
 EXTERN FILE	*scriptout  INIT(= NULL);   /* stream to write script to */
 EXTERN int	read_cmd_fd INIT(= 0);	    /* fd to read commands from */
 
-EXTERN int	got_int INIT(= FALSE);	    /* set to TRUE when interrupt
+/* volatile because it is used in signal handler catch_sigint(). */
+EXTERN volatile int got_int INIT(= FALSE);    /* set to TRUE when interrupt
 						signal occurred */
 #ifdef USE_TERM_CONSOLE
 EXTERN int	term_console INIT(= FALSE); /* set to TRUE when console used */
@@ -1022,12 +1033,13 @@
 #endif
 #ifdef FEAT_AUTOCMD
 EXTERN char_u	*autocmd_fname INIT(= NULL); /* fname for <afile> on cmdline */
+EXTERN int	autocmd_fname_full;	     /* autocmd_fname is full path */
 EXTERN int	autocmd_bufnr INIT(= 0);     /* fnum for <abuf> on cmdline */
 EXTERN char_u	*autocmd_match INIT(= NULL); /* name for <amatch> on cmdline */
 EXTERN int	did_cursorhold INIT(= FALSE); /* set when CursorHold t'gerd */
 EXTERN pos_T	last_cursormoved	    /* for CursorMoved event */
 # ifdef DO_INIT
-			= INIT_POS_T
+			= INIT_POS_T(0, 0, 0)
 # endif
 			;
 #endif
@@ -1339,7 +1351,6 @@
 
 #ifdef FEAT_NETBEANS_INTG
 EXTERN char *netbeansArg INIT(= NULL);	/* the -nb[:host:port:passwd] arg */
-EXTERN int netbeansCloseFile INIT(= 0);	/* send killed if != 0 */
 EXTERN int netbeansFireChanges INIT(= 1); /* send buffer changes if != 0 */
 EXTERN int netbeansForcedQuit INIT(= 0);/* don't write modified files */
 EXTERN int netbeansReadFile INIT(= 1);	/* OK to read from disk if != 0 */
@@ -1548,6 +1559,14 @@
 EXTERN time_t starttime;
 
 /*
+ * Some compilers warn for not using a return value, but in some situations we
+ * can't do anything useful with the value.  Assign to this variable to avoid
+ * the warning.
+ */
+EXTERN int ignored;
+EXTERN char *ignoredp;
+
+/*
  * Optional Farsi support.  Include it here, so EXTERN and INIT are defined.
  */
 #ifdef FEAT_FKMAP
diff -Naur vim72.orig/src/gui_at_fs.c vim72/src/gui_at_fs.c
--- vim72.orig/src/gui_at_fs.c	2006-05-12 02:26:24.000000000 -0700
+++ vim72/src/gui_at_fs.c	2009-06-05 14:25:31.000000000 -0700
@@ -829,7 +829,7 @@
     text.format = FMT8BIT;
 
 #ifdef XtNinternational
-    if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
+    if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
     {
 	XawTextReplace(selFileField, (XawTextPosition)0,
 				    (XawTextPosition)WcsLen((wchar_t *)&SFtextBuffer[0]), &text);
@@ -851,17 +851,15 @@
 #endif
 }
 
-/* ARGSUSED */
     static void
 SFbuttonPressList(w, n, event)
-    Widget		w;
-    int			n;
-    XButtonPressedEvent	*event;
+    Widget		w UNUSED;
+    int			n UNUSED;
+    XButtonPressedEvent	*event UNUSED;
 {
     SFbuttonPressed = 1;
 }
 
-/* ARGSUSED */
     static void
 SFbuttonReleaseList(w, n, event)
     Widget		 w;
@@ -989,11 +987,10 @@
     return result;
 }
 
-/* ARGSUSED */
     static void
 SFdirModTimer(cl, id)
-    XtPointer		cl;
-    XtIntervalId	*id;
+    XtPointer		cl UNUSED;
+    XtIntervalId	*id UNUSED;
 {
     static int		n = -1;
     static int		f = 0;
@@ -1596,11 +1593,10 @@
 
 static void SFscrollTimer __ARGS((XtPointer p, XtIntervalId *id));
 
-/* ARGSUSED */
     static void
 SFscrollTimer(p, id)
     XtPointer		p;
-    XtIntervalId	*id;
+    XtIntervalId	*id UNUSED;
 {
     SFDir	*dir;
     int		save;
@@ -1695,10 +1691,9 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFenterList(w, n, event)
-    Widget		w;
+    Widget		w UNUSED;
     int			n;
     XEnterWindowEvent	*event;
 {
@@ -1719,12 +1714,11 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFleaveList(w, n, event)
-    Widget	w;
+    Widget	w UNUSED;
     int		n;
-    XEvent	*event;
+    XEvent	*event UNUSED;
 {
     if (SFcurrentInvert[n] != -1)
     {
@@ -1733,10 +1727,9 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFmotionList(w, n, event)
-    Widget		w;
+    Widget		w UNUSED;
     int			n;
     XMotionEvent	*event;
 {
@@ -1754,7 +1747,6 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFvFloatSliderMovedCallback(w, n, fnew)
     Widget	w;
@@ -1767,10 +1759,9 @@
     SFvSliderMovedCallback(w, (int)(long)n, nw);
 }
 
-/* ARGSUSED */
     static void
 SFvSliderMovedCallback(w, n, nw)
-    Widget	w;
+    Widget	w UNUSED;
     int		n;
     int		nw;
 {
@@ -1853,10 +1844,9 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFvAreaSelectedCallback(w, n, pnew)
-    Widget		w;
+    Widget	w;
     XtPointer	n;
     XtPointer	pnew;
 {
@@ -1914,10 +1904,9 @@
     SFvSliderMovedCallback(w, (int)(long)n, nw);
 }
 
-/* ARGSUSED */
     static void
 SFhSliderMovedCallback(w, n, nw)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	n;
     XtPointer	nw;
 {
@@ -1933,10 +1922,9 @@
     SFdrawList((int)(long)n, SF_DO_NOT_SCROLL);
 }
 
-/* ARGSUSED */
     static void
 SFhAreaSelectedCallback(w, n, pnew)
-    Widget		w;
+    Widget	w;
     XtPointer	n;
     XtPointer	pnew;
 {
@@ -1994,11 +1982,10 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFpathSliderMovedCallback(w, client_data, nw)
-    Widget		w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XtPointer	nw;
 {
     SFDir		*dir;
@@ -2031,11 +2018,10 @@
     XawTextSetInsertionPoint(selFileField, pos);
 }
 
-/* ARGSUSED */
     static void
 SFpathAreaSelectedCallback(w, client_data, pnew)
     Widget	w;
-    XtPointer	client_data;
+    XtPointer	client_data UNUSED;
     XtPointer	pnew;
 {
     int		nw = (int)(long)pnew;
@@ -2206,13 +2192,12 @@
 
 static void SFexposeList __ARGS((Widget w, XtPointer n, XEvent *event, Boolean *cont));
 
-/* ARGSUSED */
     static void
 SFexposeList(w, n, event, cont)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	n;
     XEvent	*event;
-    Boolean	*cont;
+    Boolean	*cont UNUSED;
 {
     if ((event->type == NoExpose) || event->xexpose.count)
 	return;
@@ -2222,13 +2207,12 @@
 
 static void SFmodVerifyCallback __ARGS((Widget w, XtPointer client_data, XEvent *event, Boolean *cont));
 
-/* ARGSUSED */
     static void
 SFmodVerifyCallback(w, client_data, event, cont)
-    Widget		w;
-    XtPointer		client_data;
+    Widget		w UNUSED;
+    XtPointer		client_data UNUSED;
     XEvent		*event;
-    Boolean		*cont;
+    Boolean		*cont UNUSED;
 {
     char	buf[2];
 
@@ -2241,11 +2225,11 @@
 
 static void SFokCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
 
-/* ARGSUSED */
     static void
 SFokCallback(w, cl, cd)
-    Widget	w;
-    XtPointer	cl, cd;
+    Widget	w UNUSED;
+    XtPointer	cl UNUSED;
+    XtPointer	cd UNUSED;
 {
     SFstatus = SEL_FILE_OK;
 }
@@ -2258,11 +2242,11 @@
 
 static void SFcancelCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
 
-/* ARGSUSED */
     static void
 SFcancelCallback(w, cl, cd)
-    Widget	w;
-    XtPointer	cl, cd;
+    Widget	w UNUSED;
+    XtPointer	cl UNUSED;
+    XtPointer	cd UNUSED;
 {
     SFstatus = SEL_FILE_CANCEL;
 }
@@ -2275,16 +2259,15 @@
 
 static void SFdismissAction __ARGS((Widget w, XEvent *event, String *params, Cardinal *num_params));
 
-/* ARGSUSED */
     static void
 SFdismissAction(w, event, params, num_params)
-    Widget	w;
-    XEvent *event;
-    String *params;
-    Cardinal *num_params;
+    Widget	w UNUSED;
+    XEvent	*event;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
-    if (event->type == ClientMessage &&
-	    event->xclient.data.l[0] != SFwmDeleteWindow)
+    if (event->type == ClientMessage
+	    && (Atom)event->xclient.data.l[0] != SFwmDeleteWindow)
 	return;
 
     SFstatus = SEL_FILE_CANCEL;
@@ -2703,7 +2686,7 @@
 SFtextChanged()
 {
 #if defined(FEAT_XFONTSET) && defined(XtNinternational)
-    if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
+    if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
     {
 	wchar_t *wcbuf=(wchar_t *)SFtextBuffer;
 
@@ -2749,7 +2732,7 @@
 #if defined(FEAT_XFONTSET) && defined(XtNinternational)
     char *buf;
 
-    if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
+    if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
     {
 	wchar_t *wcbuf;
 	int mbslength;
diff -Naur vim72.orig/src/gui_athena.c vim72/src/gui_athena.c
--- vim72.orig/src/gui_athena.c	2008-06-21 12:38:58.000000000 -0700
+++ vim72/src/gui_athena.c	2009-06-05 14:25:31.000000000 -0700
@@ -86,10 +86,9 @@
  * Scrollbar callback (XtNjumpProc) for when the scrollbar is dragged with the
  * left or middle mouse button.
  */
-/* ARGSUSED */
     static void
 gui_athena_scroll_cb_jump(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data, call_data;
 {
     scrollbar_T *sb, *sb_info;
@@ -122,10 +121,9 @@
  * Scrollbar callback (XtNscrollProc) for paging up or down with the left or
  * right mouse buttons.
  */
-/* ARGSUSED */
     static void
 gui_athena_scroll_cb_scroll(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data, call_data;
 {
     scrollbar_T *sb, *sb_info;
@@ -492,7 +490,7 @@
     if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
     {
 	if (menu->iconidx >= 0 && menu->iconidx
-		   < (sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
+	      < (int)(sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
 	    xpm = built_in_pixmaps[menu->iconidx];
 	else
 	    xpm = tb_blank_xpm;
@@ -763,7 +761,7 @@
     XtGetValues(XtParent(widget), args, n);
 
     retval = num_children;
-    for (i = 0; i < num_children; ++i)
+    for (i = 0; i < (int)num_children; ++i)
     {
 	Widget	current = children[i];
 	vimmenu_T	*menu = NULL;
@@ -780,11 +778,10 @@
     return retval;
 }
 
-/* ARGSUSED */
     void
 gui_mch_add_menu(menu, idx)
     vimmenu_T	*menu;
-    int		idx;
+    int		idx UNUSED;
 {
     char_u	*pullright_name;
     Dimension	height, space, border;
@@ -869,7 +866,7 @@
 	    XtVaGetValues(parent->submenu_id, XtNchildren, &children,
 					      XtNnumChildren, &num_children,
 					      NULL);
-	    for (i = 0; i < num_children; ++i)
+	    for (i = 0; i < (int)num_children; ++i)
 	    {
 		XtVaSetValues(children[i],
 			      XtNrightMargin, puller_width,
@@ -913,7 +910,7 @@
     XtVaGetValues(id, XtNchildren, &children,
 		      XtNnumChildren, &num_children,
 		      NULL);
-    for (i = 0; i < num_children; ++i)
+    for (i = 0; i < (int)num_children; ++i)
     {
 	if (children[i] == ignore)
 	    continue;
@@ -1175,11 +1172,10 @@
     return pname;
 }
 
-/* ARGSUSED */
     void
 gui_mch_add_menu_item(menu, idx)
     vimmenu_T	*menu;
-    int		idx;
+    int		idx UNUSED;
 {
     vimmenu_T	*parent = menu->parent;
 
@@ -1444,7 +1440,7 @@
 		XtNchildren,	    &children,
 		XtNnumChildren,	    &numChildren,
 		NULL);
-	for (i = 0; i < numChildren; i++)
+	for (i = 0; i < (int)numChildren; i++)
 	{
 	    whgt = 0;
 
@@ -1473,10 +1469,9 @@
 #endif
 
 
-/* ARGSUSED */
     void
 gui_mch_toggle_tearoffs(enable)
-    int		enable;
+    int		enable UNUSED;
 {
     /* no tearoff menus */
 }
@@ -1537,7 +1532,7 @@
 	    else
 		get_left_margin = True;
 
-	    for (i = 0; i < num_children; ++i)
+	    for (i = 0; i < (int)num_children; ++i)
 	    {
 		if (children[i] == menu->id)
 		    continue;
@@ -1645,11 +1640,10 @@
     }
 }
 
-/*ARGSUSED*/
     static void
 gui_athena_menu_timeout(client_data, id)
     XtPointer	    client_data;
-    XtIntervalId    *id;
+    XtIntervalId    *id UNUSED;
 {
     Widget  w = (Widget)client_data;
     Widget  popup;
@@ -1678,12 +1672,11 @@
  *
  * This is called when XtPopup() is called.
  */
-/*ARGSUSED*/
     static void
 gui_athena_popup_callback(w, client_data, call_data)
     Widget	w;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     /* Assumption: XtIsSubclass(XtParent(w),simpleMenuWidgetClass) */
     vimmenu_T	*menu = (vimmenu_T *)client_data;
@@ -1711,7 +1704,6 @@
 		     NULL);
 }
 
-/* ARGSUSED */
     static void
 gui_athena_popdown_submenus_action(w, event, args, nargs)
     Widget	w;
@@ -1756,7 +1748,6 @@
     return False;
 }
 
-/* ARGSUSED */
     static void
 gui_athena_delayed_arm_action(w, event, args, nargs)
     Widget	w;
@@ -1837,7 +1828,6 @@
      * (XtIsSubclass(popup,simpleMenuWidgetClass) == True) */
 }
 
-/* ARGSUSED */
     void
 gui_mch_show_popupmenu(menu)
     vimmenu_T *menu;
@@ -2046,15 +2036,14 @@
  * Put up a file requester.
  * Returns the selected name in allocated memory, or NULL for Cancel.
  */
-/* ARGSUSED */
     char_u *
 gui_mch_browse(saving, title, dflt, ext, initdir, filter)
-    int		saving;		/* select file to write */
-    char_u	*title;		/* not used (title for the window) */
-    char_u	*dflt;		/* not used (default name) */
-    char_u	*ext;		/* not used (extension added) */
+    int		saving UNUSED;	/* select file to write */
+    char_u	*title;		/* title for the window */
+    char_u	*dflt;		/* default name */
+    char_u	*ext UNUSED;	/* extension added */
     char_u	*initdir;	/* initial directory, NULL for current dir */
-    char_u	*filter;	/* not used (file name filter) */
+    char_u	*filter UNUSED;	/* file name filter */
 {
     Position x, y;
     char_u	dirbuf[MAXPATHL];
@@ -2100,13 +2089,12 @@
  * Callback function for the textfield.  When CR is hit this works like
  * hitting the "OK" button, ESC like "Cancel".
  */
-/* ARGSUSED */
     static void
 keyhit_callback(w, client_data, event, cont)
-    Widget		w;
-    XtPointer		client_data;
+    Widget		w UNUSED;
+    XtPointer		client_data UNUSED;
     XEvent		*event;
-    Boolean		*cont;
+    Boolean		*cont UNUSED;
 {
     char	buf[2];
 
@@ -2119,12 +2107,11 @@
     }
 }
 
-/* ARGSUSED */
     static void
 butproc(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     dialogStatus = (int)(long)client_data + 1;
 }
@@ -2132,27 +2119,25 @@
 /*
  * Function called when dialog window closed.
  */
-/*ARGSUSED*/
     static void
 dialog_wm_handler(w, client_data, event, dum)
-    Widget	w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     if (event->type == ClientMessage
-	    && ((XClientMessageEvent *)event)->data.l[0] == dialogatom)
+	    && (Atom)((XClientMessageEvent *)event)->data.l[0] == dialogatom)
 	dialogStatus = 0;
 }
 
-/* ARGSUSED */
     int
 gui_mch_dialog(type, title, message, buttons, dfltbutton, textfield)
-    int		type;
+    int		type UNUSED;
     char_u	*title;
     char_u	*message;
     char_u	*buttons;
-    int		dfltbutton;
+    int		dfltbutton UNUSED;
     char_u	*textfield;
 {
     char_u		*buts;
diff -Naur vim72.orig/src/gui_at_sb.c vim72/src/gui_at_sb.c
--- vim72.orig/src/gui_at_sb.c	2004-06-07 07:32:25.000000000 -0700
+++ vim72/src/gui_at_sb.c	2009-06-05 14:25:31.000000000 -0700
@@ -198,10 +198,13 @@
     /* extension	*/  NULL
   },
   { /* simple fields */
-    /* change_sensitive	*/  XtInheritChangeSensitive
+    /* change_sensitive	*/  XtInheritChangeSensitive,
+#ifndef OLDXAW
+    /* extension */	    NULL
+#endif
   },
   { /* scrollbar fields */
-    /* ignore	    */	0
+    /* empty	    */	    0
   }
 };
 
@@ -241,7 +244,8 @@
 
     if (bottom <= 0 || bottom <= top)
 	return;
-    if ((sw = sbw->scrollbar.shadow_width) < 0)
+    sw = sbw->scrollbar.shadow_width;
+    if (sw < 0)
 	sw = 0;
     margin = MARGIN (sbw);
     floor = sbw->scrollbar.length - margin + 2;
@@ -516,13 +520,12 @@
     }
 }
 
-/* ARGSUSED */
     static void
 Initialize(request, new, args, num_args)
-    Widget	request;	/* what the client asked for */
+    Widget	request UNUSED;	/* what the client asked for */
     Widget	new;		/* what we're going to give him */
-    ArgList	args;
-    Cardinal	*num_args;
+    ArgList	args UNUSED;
+    Cardinal	*num_args UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) new;
 
@@ -556,14 +559,13 @@
 	(w, valueMask, attributes);
 }
 
-/* ARGSUSED */
     static Boolean
 SetValues(current, request, desired, args, num_args)
-    Widget  current,	    /* what I am */
-	    request,	    /* what he wants me to be */
-	    desired;	    /* what I will become */
-    ArgList args;
-    Cardinal *num_args;
+    Widget  current;	    /* what I am */
+    Widget  request UNUSED; /* what he wants me to be */
+    Widget  desired;	    /* what I will become */
+    ArgList args UNUSED;
+    Cardinal *num_args UNUSED;
 {
     ScrollbarWidget	sbw = (ScrollbarWidget) current;
     ScrollbarWidget	dsbw = (ScrollbarWidget) desired;
@@ -609,7 +611,6 @@
 }
 
 
-/* ARGSUSED */
     static void
 Redisplay(w, event, region)
     Widget w;
@@ -789,11 +790,10 @@
     }
 }
 
-/* ARGSUSED */
     static void
 RepeatNotify(client_data, idp)
     XtPointer client_data;
-    XtIntervalId *idp;
+    XtIntervalId *idp UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) client_data;
     int		    call_data;
@@ -839,46 +839,42 @@
     return (num < small) ? small : ((num > big) ? big : num);
 }
 
-/* ARGSUSED */
     static void
 ScrollOneLineUp(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, -ONE_LINE_DATA);
 }
 
-/* ARGSUSED */
     static void
 ScrollOneLineDown(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, ONE_LINE_DATA);
 }
 
-/* ARGSUSED */
     static void
 ScrollPageDown(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, ONE_PAGE_DATA);
 }
 
-/* ARGSUSED */
     static void
 ScrollPageUp(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, -ONE_PAGE_DATA);
 }
@@ -901,13 +897,12 @@
     XtCallCallbacks(w, XtNscrollProc, (XtPointer)call_data);
 }
 
-/* ARGSUSED */
     static void
 NotifyScroll(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) w;
     Position	    x, y, loc;
@@ -991,13 +986,12 @@
 					   delay, RepeatNotify, (XtPointer)w);
 }
 
-/* ARGSUSED */
     static void
 EndScroll(w, event, params, num_params)
     Widget w;
-    XEvent *event;	/* unused */
-    String *params;	/* unused */
-    Cardinal *num_params;   /* unused */
+    XEvent *event UNUSED;
+    String *params UNUSED;
+    Cardinal *num_params UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) w;
 
@@ -1023,13 +1017,12 @@
     return PICKLENGTH(sbw, x / width, y / height);
 }
 
-/* ARGSUSED */
     static void
 MoveThumb(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;	/* unused */
-    Cardinal	*num_params;	/* unused */
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollbarWidget	sbw = (ScrollbarWidget)w;
     Position		x, y;
@@ -1069,15 +1062,20 @@
 }
 
 
-/* ARGSUSED */
     static void
 NotifyThumb(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;	/* unused */
-    Cardinal	*num_params;	/* unused */
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget)w;
+    /* Use a union to avoid a warning for the weird conversion from float to
+     * XtPointer.  Comes from Xaw/Scrollbar.c. */
+    union {
+	XtPointer xtp;
+	float xtf;
+    } xtpf;
 
     if (LookAhead(w, event))
 	return;
@@ -1085,11 +1083,11 @@
     /* thumbProc is not pretty, but is necessary for backwards
        compatibility on those architectures for which it work{s,ed};
        the intent is to pass a (truncated) float by value. */
-    XtCallCallbacks(w, XtNthumbProc, *(XtPointer*)&sbw->scrollbar.top);
+    xtpf.xtf = sbw->scrollbar.top;
+    XtCallCallbacks(w, XtNthumbProc, xtpf.xtp);
     XtCallCallbacks(w, XtNjumpProc, (XtPointer)&sbw->scrollbar.top);
 }
 
-/* ARGSUSED */
     static void
 AllocTopShadowGC(w)
     Widget w;
@@ -1103,7 +1101,6 @@
     sbw->scrollbar.top_shadow_GC = XtGetGC(w, valuemask, &myXGCV);
 }
 
-/* ARGSUSED */
     static void
 AllocBotShadowGC(w)
     Widget w;
@@ -1117,11 +1114,10 @@
     sbw->scrollbar.bot_shadow_GC = XtGetGC(w, valuemask, &myXGCV);
 }
 
-/* ARGSUSED */
     static void
 _Xaw3dDrawShadows(gw, event, region, out)
     Widget  gw;
-    XEvent  *event;
+    XEvent  *event UNUSED;
     Region  region;
     int	    out;
 {
diff -Naur vim72.orig/src/gui_beval.c vim72/src/gui_beval.c
--- vim72.orig/src/gui_beval.c	2007-05-07 12:33:41.000000000 -0700
+++ vim72/src/gui_beval.c	2009-06-05 14:25:31.000000000 -0700
@@ -15,11 +15,10 @@
 /*
  * Common code, invoked when the mouse is resting for a moment.
  */
-/*ARGSUSED*/
     void
 general_beval_cb(beval, state)
     BalloonEval *beval;
-    int state;
+    int		state UNUSED;
 {
     win_T	*wp;
     int		col;
@@ -551,9 +550,8 @@
     return FALSE; /* continue emission */
 }
 
-/*ARGSUSED*/
     static gint
-mainwin_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)
+mainwin_event_cb(GtkWidget *widget UNUSED, GdkEvent *event, gpointer data)
 {
     BalloonEval *beval = (BalloonEval *)data;
 
@@ -663,9 +661,10 @@
     return FALSE; /* don't call me again */
 }
 
-/*ARGSUSED2*/
     static gint
-balloon_expose_event_cb(GtkWidget *widget, GdkEventExpose *event, gpointer data)
+balloon_expose_event_cb(GtkWidget *widget,
+			GdkEventExpose *event,
+			gpointer data UNUSED)
 {
     gtk_paint_flat_box(widget->style, widget->window,
 		       GTK_STATE_NORMAL, GTK_SHADOW_OUT,
@@ -676,7 +675,6 @@
 }
 
 # ifndef HAVE_GTK2
-/*ARGSUSED2*/
     static void
 balloon_draw_cb(GtkWidget *widget, GdkRectangle *area, gpointer data)
 {
@@ -726,13 +724,12 @@
 /*
  * The X event handler. All it does is call the real event handler.
  */
-/*ARGSUSED*/
     static void
 pointerEventEH(w, client_data, event, unused)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
     XEvent	*event;
-    Boolean	*unused;
+    Boolean	*unused UNUSED;
 {
     BalloonEval *beval = (BalloonEval *)client_data;
     pointerEvent(beval, event);
@@ -877,11 +874,10 @@
     }
 }
 
-/*ARGSUSED*/
     static void
 timerRoutine(dx, id)
     XtPointer	    dx;
-    XtIntervalId    *id;
+    XtIntervalId    *id UNUSED;
 {
     BalloonEval *beval = (BalloonEval *)dx;
 
@@ -1291,6 +1287,23 @@
 		XtNy, ty,
 		NULL);
 #endif
+	/* Set tooltip colors */
+	{
+	    Arg args[2];
+
+#ifdef FEAT_GUI_MOTIF
+	    args[0].name = XmNbackground;
+	    args[0].value = gui.tooltip_bg_pixel;
+	    args[1].name = XmNforeground;
+	    args[1].value = gui.tooltip_fg_pixel;
+#else /* Athena */
+	    args[0].name = XtNbackground;
+	    args[0].value = gui.tooltip_bg_pixel;
+	    args[1].name = XtNforeground;
+	    args[1].value = gui.tooltip_fg_pixel;
+#endif
+	    XtSetValues(beval->balloonLabel, &args[0], XtNumber(args));
+	}
 
 	XtPopup(beval->balloonShell, XtGrabNone);
 
diff -Naur vim72.orig/src/gui.c vim72/src/gui.c
--- vim72.orig/src/gui.c	2008-07-27 12:32:14.000000000 -0700
+++ vim72/src/gui.c	2009-06-05 14:25:31.000000000 -0700
@@ -139,7 +139,7 @@
 		/* The read returns when the child closes the pipe (or when
 		 * the child dies for some reason). */
 		close(pipefd[1]);
-		(void)read(pipefd[0], &dummy, (size_t)1);
+		ignored = (int)read(pipefd[0], &dummy, (size_t)1);
 		close(pipefd[0]);
 	    }
 
@@ -678,11 +678,10 @@
  * Return OK when able to set the font.  When it failed FAIL is returned and
  * the fonts are unchanged.
  */
-/*ARGSUSED*/
     int
 gui_init_font(font_list, fontset)
     char_u	*font_list;
-    int		fontset;
+    int		fontset UNUSED;
 {
 #define FONTLEN 320
     char_u	font_name[FONTLEN];
@@ -1138,10 +1137,9 @@
  * Position the various GUI components (text area, menu).  The vertical
  * scrollbars are NOT handled here.  See gui_update_scrollbars().
  */
-/*ARGSUSED*/
     static void
 gui_position_components(total_width)
-    int	    total_width;
+    int	    total_width UNUSED;
 {
     int	    text_area_x;
     int	    text_area_y;
@@ -1374,10 +1372,9 @@
  * If "fit_to_display" is TRUE then the size may be reduced to fit the window
  * on the screen.
  */
-/*ARGSUSED*/
     void
 gui_set_shellsize(mustset, fit_to_display, direction)
-    int		mustset;		/* set by the user */
+    int		mustset UNUSED;		/* set by the user */
     int		fit_to_display;
     int		direction;		/* RESIZE_HOR, RESIZE_VER */
 {
@@ -3120,10 +3117,9 @@
  * If "oldval" is not NULL, "oldval" is the previous value, the new value is
  * in p_go.
  */
-/*ARGSUSED*/
     void
 gui_init_which_components(oldval)
-    char_u	*oldval;
+    char_u	*oldval UNUSED;
 {
 #ifdef FEAT_MENU
     static int	prev_menu_is_active = -1;
@@ -3241,7 +3237,7 @@
 	    i = Rows;
 	    gui_update_tabline();
 	    Rows = i;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_tabline)
 		fix_size = TRUE;
 	    if (!gui_use_tabline())
@@ -3275,9 +3271,9 @@
 		if (gui.which_scrollbars[i] != prev_which_scrollbars[i])
 		{
 		    if (i == SBAR_BOTTOM)
-			need_set_size = RESIZE_VERT;
+			need_set_size |= RESIZE_VERT;
 		    else
-			need_set_size = RESIZE_HOR;
+			need_set_size |= RESIZE_HOR;
 		    if (gui.which_scrollbars[i])
 			fix_size = TRUE;
 		}
@@ -3297,7 +3293,7 @@
 	    gui_mch_enable_menu(gui.menu_is_active);
 	    Rows = i;
 	    prev_menu_is_active = gui.menu_is_active;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (gui.menu_is_active)
 		fix_size = TRUE;
 	}
@@ -3308,7 +3304,7 @@
 	{
 	    gui_mch_show_toolbar(using_toolbar);
 	    prev_toolbar = using_toolbar;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_toolbar)
 		fix_size = TRUE;
 	}
@@ -3318,7 +3314,7 @@
 	{
 	    gui_mch_enable_footer(using_footer);
 	    prev_footer = using_footer;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_footer)
 		fix_size = TRUE;
 	}
@@ -3330,10 +3326,11 @@
 	    prev_tearoff = using_tearoff;
 	}
 #endif
-	if (need_set_size)
+	if (need_set_size != 0)
 	{
 #ifdef FEAT_GUI_GTK
-	    long    c = Columns;
+	    long    prev_Columns = Columns;
+	    long    prev_Rows = Rows;
 #endif
 	    /* Adjust the size of the window to make the text area keep the
 	     * same size and to avoid that part of our window is off-screen
@@ -3349,11 +3346,14 @@
 	     * If you remove this, please test this command for resizing
 	     * effects (with optional left scrollbar): ":vsp|q|vsp|q|vsp|q".
 	     * Don't do this while starting up though.
-	     * And don't change Rows, it may have be reduced intentionally
-	     * when adding menu/toolbar/tabline. */
-	    if (!gui.starting)
+	     * Don't change Rows when adding menu/toolbar/tabline.
+	     * Don't change Columns when adding vertical toolbar. */
+	    if (!gui.starting && need_set_size != (RESIZE_VERT | RESIZE_HOR))
 		(void)char_avail();
-	    Columns = c;
+	    if ((need_set_size & RESIZE_VERT) == 0)
+		Rows = prev_Rows;
+	    if ((need_set_size & RESIZE_HOR) == 0)
+		Columns = prev_Columns;
 #endif
 	}
 #ifdef FEAT_WINDOWS
@@ -4407,7 +4407,7 @@
     if (curwin->w_p_wrap)
 	return FALSE;
 
-    if (curwin->w_leftcol == scrollbar_value)
+    if ((long_u)curwin->w_leftcol == scrollbar_value)
 	return FALSE;
 
     curwin->w_leftcol = (colnr_T)scrollbar_value;
@@ -4420,7 +4420,7 @@
 	    && longest_lnum < curwin->w_botline
 	    && !virtual_active())
     {
-	if (scrollbar_value > scroll_line_len(curwin->w_cursor.lnum))
+	if (scrollbar_value > (long_u)scroll_line_len(curwin->w_cursor.lnum))
 	{
 	    curwin->w_cursor.lnum = longest_lnum;
 	    curwin->w_cursor.col = 0;
@@ -4666,11 +4666,10 @@
 /*
  * Find window where the mouse pointer "y" coordinate is in.
  */
-/*ARGSUSED*/
     static win_T *
 xy2win(x, y)
-    int		x;
-    int		y;
+    int		x UNUSED;
+    int		y UNUSED;
 {
 #ifdef FEAT_WINDOWS
     int		row;
@@ -5120,11 +5119,10 @@
  * of dropped files, they will be freed in this function, and caller can't use
  * fnames after call this function.
  */
-/*ARGSUSED*/
     void
 gui_handle_drop(x, y, modifiers, fnames, count)
-    int		x;
-    int		y;
+    int		x UNUSED;
+    int		y UNUSED;
     int_u	modifiers;
     char_u	**fnames;
     int		count;
diff -Naur vim72.orig/src/gui_gtk.c vim72/src/gui_gtk.c
--- vim72.orig/src/gui_gtk.c	2008-07-31 12:48:20.000000000 -0700
+++ vim72/src/gui_gtk.c	2009-06-05 14:25:19.000000000 -0700
@@ -285,14 +285,14 @@
     return image;
 }
 
-/*ARGSUSED*/
     static gint
-toolbar_button_focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
-{
-    /* When we're in a GtkPlug, we don't have window focus events, only widget focus.
-     * To emulate stand-alone gvim, if a button gets focus (e.g., <Tab> into GtkPlug)
-     * immediately pass it to mainwin.
-     */
+toolbar_button_focus_in_event(GtkWidget *widget UNUSED,
+			      GdkEventFocus *event UNUSED,
+			      gpointer data UNUSED)
+{
+    /* When we're in a GtkPlug, we don't have window focus events, only widget
+     * focus.  To emulate stand-alone gvim, if a button gets focus (e.g.,
+     * <Tab> into GtkPlug) immediately pass it to mainwin. */
     if (gtk_socket_id != 0)
 	gtk_widget_grab_focus(gui.drawarea);
 
@@ -585,9 +585,8 @@
     gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
 }
 
-/*ARGSUSED*/
     static void
-menu_item_activate(GtkWidget *widget, gpointer data)
+menu_item_activate(GtkWidget *widget UNUSED, gpointer data)
 {
     gui_menu_cb((vimmenu_T *)data);
 
@@ -1202,9 +1201,8 @@
 #endif
 
 #ifndef USE_FILE_CHOOSER
-/*ARGSUSED*/
     static void
-browse_ok_cb(GtkWidget *widget, gpointer cbdata)
+browse_ok_cb(GtkWidget *widget UNUSED, gpointer cbdata)
 {
     gui_T *vw = (gui_T *)cbdata;
 
@@ -1218,9 +1216,8 @@
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static void
-browse_cancel_cb(GtkWidget *widget, gpointer cbdata)
+browse_cancel_cb(GtkWidget *widget UNUSED, gpointer cbdata)
 {
     gui_T *vw = (gui_T *)cbdata;
 
@@ -1234,9 +1231,8 @@
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static gboolean
-browse_destroy_cb(GtkWidget * widget)
+browse_destroy_cb(GtkWidget *widget UNUSED)
 {
     if (gui.browse_fname != NULL)
     {
@@ -1262,14 +1258,13 @@
  * initdir			initial directory, NULL for current dir
  * filter			not used (file name filter)
  */
-/*ARGSUSED*/
     char_u *
-gui_mch_browse(int saving,
+gui_mch_browse(int saving UNUSED,
 	       char_u *title,
 	       char_u *dflt,
-	       char_u *ext,
+	       char_u *ext UNUSED,
 	       char_u *initdir,
-	       char_u *filter)
+	       char_u *filter UNUSED)
 {
 #ifdef USE_FILE_CHOOSER
     GtkWidget		*fc;
@@ -1377,7 +1372,6 @@
  * dflt				default name
  * initdir			initial directory, NULL for current dir
  */
-/*ARGSUSED*/
     char_u *
 gui_mch_browsedir(
 	       char_u *title,
@@ -1460,7 +1454,6 @@
 }
 
 # ifdef FEAT_GUI_GNOME
-/* ARGSUSED */
     static int
 gui_gnome_dialog( int	type,
 		char_u	*title,
@@ -1611,7 +1604,6 @@
     GtkWidget	*dialog;
 } CancelData;
 
-/* ARGSUSED */
     static void
 dlg_button_clicked(GtkWidget * widget, ButtonData *data)
 {
@@ -1622,7 +1614,6 @@
 /*
  * This makes the Escape key equivalent to the cancel button.
  */
-/*ARGSUSED*/
     static int
 dlg_key_press_event(GtkWidget *widget, GdkEventKey *event, CancelData *data)
 {
@@ -1655,7 +1646,6 @@
 	gtk_main_quit();
 }
 
-/* ARGSUSED */
     int
 gui_mch_dialog(	int	type,		/* type of dialog */
 		char_u	*title,		/* title of dialog */
@@ -2215,7 +2205,6 @@
     GtkDialog	*dialog;	    /* Widget of the dialog */
 } DialogInfo;
 
-/*ARGSUSED2*/
     static gboolean
 dialog_key_press_event_cb(GtkWidget *widget, GdkEventKey *event, gpointer data)
 {
@@ -2398,14 +2387,13 @@
  * Note: The push_in output argument seems to affect scrolling of huge
  * menus that don't fit on the screen.	Leave it at the default for now.
  */
-/*ARGSUSED0*/
     static void
-popup_menu_position_func(GtkMenu *menu,
+popup_menu_position_func(GtkMenu *menu UNUSED,
 			 gint *x, gint *y,
 # ifdef HAVE_GTK2
-			 gboolean *push_in,
+			 gboolean *push_in UNUSED,
 # endif
-			 gpointer user_data)
+			 gpointer user_data UNUSED)
 {
     gdk_window_get_origin(gui.drawarea->window, x, y);
 
@@ -2464,13 +2452,12 @@
     GtkWidget *all;	/* 'Replace All' action button */
 } SharedFindReplace;
 
-static SharedFindReplace find_widgets = { NULL, };
-static SharedFindReplace repl_widgets = { NULL, };
+static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
+static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
 
-/* ARGSUSED */
     static int
 find_key_press_event(
-		GtkWidget	*widget,
+		GtkWidget	*widget UNUSED,
 		GdkEventKey	*event,
 		SharedFindReplace *frdp)
 {
@@ -2962,9 +2949,8 @@
 /*
  * Callback for actions of the find and replace dialogs
  */
-/*ARGSUSED*/
     static void
-find_replace_cb(GtkWidget *widget, gpointer data)
+find_replace_cb(GtkWidget *widget UNUSED, gpointer data)
 {
     int			flags;
     char_u		*find_text;
@@ -3010,9 +2996,8 @@
 }
 
 /* our usual callback function */
-/*ARGSUSED*/
     static void
-entry_activate_cb(GtkWidget *widget, gpointer data)
+entry_activate_cb(GtkWidget *widget UNUSED, gpointer data)
 {
     gtk_widget_grab_focus(GTK_WIDGET(data));
 }
@@ -3055,10 +3040,9 @@
 /*
  * ":helpfind"
  */
-/*ARGSUSED*/
     void
 ex_helpfind(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     /* This will fail when menus are not loaded.  Well, it's only for
      * backwards compatibility anyway. */
diff -Naur vim72.orig/src/gui_gtk_f.c vim72/src/gui_gtk_f.c
--- vim72.orig/src/gui_gtk_f.c	2007-05-07 12:38:02.000000000 -0700
+++ vim72/src/gui_gtk_f.c	2009-06-05 14:25:22.000000000 -0700
@@ -227,14 +227,14 @@
 
     if (!form_type)
     {
-	GtkTypeInfo form_info =
-	{
-	    "GtkForm",
-	    sizeof(GtkForm),
-	    sizeof(GtkFormClass),
-	    (GtkClassInitFunc) gtk_form_class_init,
-	    (GtkObjectInitFunc) gtk_form_init
-	};
+	GtkTypeInfo form_info;
+
+	vim_memset(&form_info, 0, sizeof(form_info));
+	form_info.type_name = "GtkForm";
+	form_info.object_size = sizeof(GtkForm);
+	form_info.class_size = sizeof(GtkFormClass);
+	form_info.class_init_func = (GtkClassInitFunc)gtk_form_class_init;
+	form_info.object_init_func = (GtkObjectInitFunc)gtk_form_init;
 
 	form_type = gtk_type_unique(GTK_TYPE_CONTAINER, &form_info);
     }
@@ -611,10 +611,9 @@
     }
 }
 
-/*ARGSUSED1*/
     static void
 gtk_form_forall(GtkContainer	*container,
-		gboolean	include_internals,
+		gboolean	include_internals UNUSED,
 		GtkCallback	callback,
 		gpointer	callback_data)
 {
@@ -786,9 +785,8 @@
  * them or discards them, depending on whether we are obscured
  * or not.
  */
-/*ARGSUSED1*/
     static GdkFilterReturn
-gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event UNUSED, gpointer data)
 {
     XEvent *xevent;
     GtkForm *form;
@@ -821,9 +819,10 @@
  * there is no corresponding event in GTK, so we have
  * to get the events from a filter
  */
-/*ARGSUSED1*/
     static GdkFilterReturn
-gtk_form_main_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+gtk_form_main_filter(GdkXEvent *gdk_xevent,
+		     GdkEvent *event UNUSED,
+		     gpointer data)
 {
     XEvent *xevent;
     GtkForm *form;
@@ -911,9 +910,8 @@
 #endif
 }
 
-/*ARGSUSED0*/
     static void
-gtk_form_child_map(GtkWidget *widget, gpointer user_data)
+gtk_form_child_map(GtkWidget *widget UNUSED, gpointer user_data)
 {
     GtkFormChild *child;
 
@@ -923,9 +921,8 @@
     gdk_window_show(child->window);
 }
 
-/*ARGSUSED0*/
     static void
-gtk_form_child_unmap(GtkWidget *widget, gpointer user_data)
+gtk_form_child_unmap(GtkWidget *widget UNUSED, gpointer user_data)
 {
     GtkFormChild *child;
 
diff -Naur vim72.orig/src/gui_gtk_x11.c vim72/src/gui_gtk_x11.c
--- vim72.orig/src/gui_gtk_x11.c	2008-07-04 03:46:24.000000000 -0700
+++ vim72/src/gui_gtk_x11.c	2009-06-05 14:26:08.000000000 -0700
@@ -412,6 +412,7 @@
 #endif
 #if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
 static const char *restart_command = NULL;
+static       char *abs_restart_command = NULL;
 #endif
 static int found_iconic_arg = FALSE;
 
@@ -449,8 +450,10 @@
 	char_u buf[MAXPATHL];
 
 	if (mch_FullName((char_u *)argv[0], buf, (int)sizeof(buf), TRUE) == OK)
-	    /* Tiny leak; doesn't matter, and usually we don't even get here */
-	    restart_command = (char *)vim_strsave(buf);
+	{
+	    abs_restart_command = (char *)vim_strsave(buf);
+	    restart_command = abs_restart_command;
+	}
     }
 #endif
 
@@ -611,6 +614,9 @@
 gui_mch_free_all()
 {
     vim_free(gui_argv);
+#if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
+    vim_free(abs_restart_command);
+#endif
 }
 #endif
 
@@ -619,9 +625,10 @@
  * Doesn't seem possible, since check_copy_area() relies on
  * this information.  --danielk
  */
-/*ARGSUSED*/
     static gint
-visibility_event(GtkWidget *widget, GdkEventVisibility *event, gpointer data)
+visibility_event(GtkWidget *widget UNUSED,
+		 GdkEventVisibility *event,
+		 gpointer data UNUSED)
 {
     gui.visibility = event->state;
     /*
@@ -638,9 +645,10 @@
 /*
  * Redraw the corresponding portions of the screen.
  */
-/*ARGSUSED*/
     static gint
-expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer data)
+expose_event(GtkWidget *widget UNUSED,
+	     GdkEventExpose *event,
+	     gpointer data UNUSED)
 {
     /* Skip this when the GUI isn't set up yet, will redraw later. */
     if (gui.starting)
@@ -668,9 +676,10 @@
 /*
  * Handle changes to the "Comm" property
  */
-/*ARGSUSED2*/
     static gint
-property_event(GtkWidget *widget, GdkEventProperty *event, gpointer data)
+property_event(GtkWidget *widget,
+	       GdkEventProperty *event,
+	       gpointer data UNUSED)
 {
     if (event->type == GDK_PROPERTY_NOTIFY
 	    && event->state == (int)GDK_PROPERTY_NEW_VALUE
@@ -740,9 +749,8 @@
     blink_state = BLINK_NONE;
 }
 
-/*ARGSUSED*/
     static gint
-blink_cb(gpointer data)
+blink_cb(gpointer data UNUSED)
 {
     if (blink_state == BLINK_ON)
     {
@@ -781,9 +789,10 @@
     }
 }
 
-/*ARGSUSED*/
     static gint
-enter_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
+enter_notify_event(GtkWidget *widget UNUSED,
+		   GdkEventCrossing *event UNUSED,
+		   gpointer data UNUSED)
 {
     if (blink_state == BLINK_NONE)
 	gui_mch_start_blink();
@@ -795,9 +804,10 @@
     return FALSE;
 }
 
-/*ARGSUSED*/
     static gint
-leave_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
+leave_notify_event(GtkWidget *widget UNUSED,
+		   GdkEventCrossing *event UNUSED,
+		   gpointer data UNUSED)
 {
     if (blink_state != BLINK_NONE)
 	gui_mch_stop_blink();
@@ -805,9 +815,10 @@
     return FALSE;
 }
 
-/*ARGSUSED*/
     static gint
-focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
+focus_in_event(GtkWidget *widget,
+	       GdkEventFocus *event UNUSED,
+	       gpointer data UNUSED)
 {
     gui_focus_change(TRUE);
 
@@ -826,9 +837,10 @@
     return TRUE;
 }
 
-/*ARGSUSED*/
     static gint
-focus_out_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
+focus_out_event(GtkWidget *widget UNUSED,
+	        GdkEventFocus *event UNUSED,
+		gpointer data UNUSED)
 {
     gui_focus_change(FALSE);
 
@@ -956,9 +968,10 @@
 /*
  * Main keyboard handler:
  */
-/*ARGSUSED*/
     static gint
-key_press_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
+key_press_event(GtkWidget *widget UNUSED,
+		GdkEventKey *event,
+		gpointer data UNUSED)
 {
 #ifdef HAVE_GTK2
     /* 256 bytes is way over the top, but for safety let's reduce it only
@@ -1225,9 +1238,10 @@
 }
 
 #if defined(FEAT_XIM) && defined(HAVE_GTK2)
-/*ARGSUSED0*/
     static gboolean
-key_release_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
+key_release_event(GtkWidget *widget UNUSED,
+		  GdkEventKey *event,
+		  gpointer data UNUSED)
 {
     /*
      * GTK+ 2 input methods may do fancy stuff on key release events too.
@@ -1243,11 +1257,10 @@
  * Selection handlers:
  */
 
-/*ARGSUSED*/
     static gint
-selection_clear_event(GtkWidget		*widget,
+selection_clear_event(GtkWidget		*widget UNUSED,
 		      GdkEventSelection	*event,
-		      gpointer		user_data)
+		      gpointer		user_data UNUSED)
 {
     if (event->selection == clip_plus.gtk_sel_atom)
 	clip_lose_selection(&clip_plus);
@@ -1265,12 +1278,11 @@
 #define RS_FAIL	2	/* selection_received_cb() called and failed */
 static int received_selection = RS_NONE;
 
-/*ARGSUSED*/
     static void
-selection_received_cb(GtkWidget		*widget,
+selection_received_cb(GtkWidget		*widget UNUSED,
 		      GtkSelectionData	*data,
-		      guint		time_,
-		      gpointer		user_data)
+		      guint		time_ UNUSED,
+		      gpointer		user_data UNUSED)
 {
     VimClipboard    *cbd;
     char_u	    *text;
@@ -1414,13 +1426,12 @@
  * Prepare our selection data for passing it to the external selection
  * client.
  */
-/*ARGSUSED*/
     static void
-selection_get_cb(GtkWidget	    *widget,
+selection_get_cb(GtkWidget	    *widget UNUSED,
 		 GtkSelectionData   *selection_data,
 		 guint		    info,
-		 guint		    time_,
-		 gpointer	    user_data)
+		 guint		    time_ UNUSED,
+		 gpointer	    user_data UNUSED)
 {
     char_u	    *string;
     char_u	    *tmpbuf;
@@ -1678,7 +1689,7 @@
 
 	offshoot = dx > dy ? dx : dy;
 
-	/* Make a linearly declaying timer delay with a threshold of 5 at a
+	/* Make a linearly decaying timer delay with a threshold of 5 at a
 	 * distance of 127 pixels from the main window.
 	 *
 	 * One could think endlessly about the most ergonomic variant here.
@@ -1707,9 +1718,8 @@
 /*
  * Timer used to recognize multiple clicks of the mouse button.
  */
-/*ARGSUSED0*/
     static gint
-motion_repeat_timer_cb(gpointer data)
+motion_repeat_timer_cb(gpointer data UNUSED)
 {
     int		    x;
     int		    y;
@@ -1749,9 +1759,10 @@
     return FALSE;
 }
 
-/*ARGSUSED2*/
     static gint
-motion_notify_event(GtkWidget *widget, GdkEventMotion *event, gpointer data)
+motion_notify_event(GtkWidget *widget,
+		    GdkEventMotion *event,
+		    gpointer data UNUSED)
 {
     if (event->is_hint)
     {
@@ -1777,9 +1788,10 @@
  * by our own timeout mechanism instead of the one provided by GTK+ itself.
  * This is due to the way the generic VIM code is recognizing multiple clicks.
  */
-/*ARGSUSED2*/
     static gint
-button_press_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
+button_press_event(GtkWidget *widget,
+		   GdkEventButton *event,
+		   gpointer data UNUSED)
 {
     int button;
     int repeated_click = FALSE;
@@ -1855,9 +1867,10 @@
  * GTK+ 2 doesn't handle mouse buttons 4, 5, 6 and 7 the same way as GTK+ 1.
  * Instead, it abstracts scrolling via the new GdkEventScroll.
  */
-/*ARGSUSED2*/
     static gboolean
-scroll_event(GtkWidget *widget, GdkEventScroll *event, gpointer data)
+scroll_event(GtkWidget *widget,
+	     GdkEventScroll *event,
+	     gpointer data UNUSED)
 {
     int	    button;
     int_u   vim_modifiers;
@@ -1896,9 +1909,10 @@
 #endif /* HAVE_GTK2 */
 
 
-/*ARGSUSED*/
     static gint
-button_release_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
+button_release_event(GtkWidget *widget UNUSED,
+		     GdkEventButton *event,
+		     gpointer data UNUSED)
 {
     int x, y;
     int_u vim_modifiers;
@@ -2100,7 +2114,6 @@
 /*
  * DND receiver.
  */
-/*ARGSUSED2*/
     static void
 drag_data_received_cb(GtkWidget		*widget,
 		      GdkDragContext	*context,
@@ -2109,7 +2122,7 @@
 		      GtkSelectionData	*data,
 		      guint		info,
 		      guint		time_,
-		      gpointer		user_data)
+		      gpointer		user_data UNUSED)
 {
     GdkModifierType state;
 
@@ -2143,7 +2156,6 @@
  * be abandoned and pop up a dialog asking the user for confirmation if
  * necessary.
  */
-/*ARGSUSED0*/
     static void
 sm_client_check_changed_any(GnomeClient	    *client,
 			    gint	    key,
@@ -2251,7 +2263,6 @@
  * for confirmation if necessary.  Save the current editing session and tell
  * the session manager how to restart Vim.
  */
-/*ARGSUSED1*/
     static gboolean
 sm_client_save_yourself(GnomeClient	    *client,
 			gint		    phase,
@@ -2339,7 +2350,6 @@
  * here since "save_yourself" has been emitted before (unless serious trouble
  * is happening).
  */
-/*ARGSUSED0*/
     static void
 sm_client_die(GnomeClient *client, gpointer data)
 {
@@ -2379,10 +2389,9 @@
 /*
  * GTK tells us that XSMP needs attention
  */
-/*ARGSUSED*/
     static gboolean
 local_xsmp_handle_requests(source, condition, data)
-    GIOChannel		*source;
+    GIOChannel		*source UNUSED;
     GIOCondition	condition;
     gpointer		data;
 {
@@ -2480,16 +2489,18 @@
  * WM_SAVE_YOURSELF hack it actually stores the session...  And yes,
  * it should work with KDE as well.
  */
-/*ARGSUSED1*/
     static GdkFilterReturn
-global_event_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
+global_event_filter(GdkXEvent *xev,
+		    GdkEvent *event UNUSED,
+		    gpointer data UNUSED)
 {
     XEvent *xevent = (XEvent *)xev;
 
     if (xevent != NULL
 	    && xevent->type == ClientMessage
 	    && xevent->xclient.message_type == GET_X_ATOM(wm_protocols_atom)
-	    && xevent->xclient.data.l[0] == GET_X_ATOM(save_yourself_atom))
+	    && (long_u)xevent->xclient.data.l[0]
+					    == GET_X_ATOM(save_yourself_atom))
     {
 	out_flush();
 	ml_sync_all(FALSE, FALSE); /* preserve all swap files */
@@ -2512,7 +2523,6 @@
 /*
  * GDK handler for X ClientMessage events.
  */
-/*ARGSUSED2*/
     static GdkFilterReturn
 gdk_wm_protocols_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
 {
@@ -2558,9 +2568,8 @@
 /*
  * Setup the window icon & xcmdsrv comm after the main window has been realized.
  */
-/*ARGSUSED*/
     static void
-mainwin_realize(GtkWidget *widget, gpointer data)
+mainwin_realize(GtkWidget *widget UNUSED, gpointer data UNUSED)
 {
 /* If you get an error message here, you still need to unpack the runtime
  * archive! */
@@ -2712,11 +2721,10 @@
 }
 
 #ifdef HAVE_GTK_MULTIHEAD
-/*ARGSUSED1*/
     static void
 mainwin_screen_changed_cb(GtkWidget  *widget,
-			  GdkScreen  *previous_screen,
-			  gpointer   data)
+			  GdkScreen  *previous_screen UNUSED,
+			  gpointer   data UNUSED)
 {
     if (!gtk_widget_has_screen(widget))
 	return;
@@ -2757,9 +2765,8 @@
  * Don't try to set any VIM scrollbar sizes anywhere here. I'm relying on the
  * fact that the main VIM engine doesn't take them into account anywhere.
  */
-/*ARGSUSED1*/
     static void
-drawarea_realize_cb(GtkWidget *widget, gpointer data)
+drawarea_realize_cb(GtkWidget *widget, gpointer data UNUSED)
 {
     GtkWidget *sbar;
 
@@ -2789,9 +2796,8 @@
 /*
  * Properly clean up on shutdown.
  */
-/*ARGSUSED0*/
     static void
-drawarea_unrealize_cb(GtkWidget *widget, gpointer data)
+drawarea_unrealize_cb(GtkWidget *widget UNUSED, gpointer data UNUSED)
 {
     /* Don't write messages to the GUI anymore */
     full_screen = FALSE;
@@ -2827,11 +2833,10 @@
 #endif
 }
 
-/*ARGSUSED0*/
     static void
-drawarea_style_set_cb(GtkWidget	*widget,
-		      GtkStyle	*previous_style,
-		      gpointer	data)
+drawarea_style_set_cb(GtkWidget	*widget UNUSED,
+		      GtkStyle	*previous_style UNUSED,
+		      gpointer	data UNUSED)
 {
     gui_mch_new_colors();
 }
@@ -2840,9 +2845,10 @@
  * Callback routine for the "delete_event" signal on the toplevel window.
  * Tries to vim gracefully, or refuses to exit with changed buffers.
  */
-/*ARGSUSED*/
     static gint
-delete_event_cb(GtkWidget *widget, GdkEventAny *event, gpointer data)
+delete_event_cb(GtkWidget *widget UNUSED,
+		GdkEventAny *event UNUSED,
+		gpointer data UNUSED)
 {
     gui_shell_closed();
     return TRUE;
@@ -2964,7 +2970,7 @@
 
     /* At start-up, don't try to set the hints until the initial
      * values have been used (those that dictate our initial size)
-     * Let forced (i.e., correct) values thruogh always.
+     * Let forced (i.e., correct) values through always.
      */
     if (!(force_width && force_height)  &&  init_window_hints_state > 0)
     {
@@ -3142,9 +3148,8 @@
 /*
  * Handle selecting an item in the tab line popup menu.
  */
-/*ARGSUSED*/
     static void
-tabline_menu_handler(GtkMenuItem *item, gpointer user_data)
+tabline_menu_handler(GtkMenuItem *item UNUSED, gpointer user_data)
 {
     /* Add the string cmd into input buffer */
     send_tabline_menu_event(clicked_page, (int)(long)user_data);
@@ -3244,13 +3249,12 @@
 /*
  * Handle selecting one of the tabs.
  */
-/*ARGSUSED*/
     static void
 on_select_tab(
-	GtkNotebook	*notebook,
-	GtkNotebookPage *page,
+	GtkNotebook	*notebook UNUSED,
+	GtkNotebookPage *page UNUSED,
 	gint		idx,
-	gpointer	data)
+	gpointer	data UNUSED)
 {
     if (!ignore_tabline_evt)
     {
@@ -3784,7 +3788,7 @@
 #endif
 
     if (gtk_socket_id != 0)
-	/* make sure keybord input can go to the drawarea */
+	/* make sure keyboard input can go to the drawarea */
 	GTK_WIDGET_SET_FLAGS(gui.drawarea, GTK_CAN_FOCUS);
 
     /*
@@ -3922,10 +3926,10 @@
 /*
  * This signal informs us about the need to rearrange our sub-widgets.
  */
-/*ARGSUSED*/
     static gint
-form_configure_event(GtkWidget *widget, GdkEventConfigure *event,
-		     gpointer data)
+form_configure_event(GtkWidget *widget UNUSED,
+		     GdkEventConfigure *event,
+		     gpointer data UNUSED)
 {
     int usable_height = event->height;
 
@@ -3948,9 +3952,8 @@
  * We can't do much more here than to trying to preserve what had been done,
  * since the window is already inevitably going away.
  */
-/*ARGSUSED0*/
     static void
-mainwin_destroy_cb(GtkObject *object, gpointer data)
+mainwin_destroy_cb(GtkObject *object UNUSED, gpointer data UNUSED)
 {
     /* Don't write messages to the GUI anymore */
     full_screen = FALSE;
@@ -3980,9 +3983,8 @@
  * scrollbar init.), actually do the standard hinst and stop the timer.
  * We'll not let the default hints be set while this timer's active.
  */
-/*ARGSUSED*/
     static gboolean
-check_startup_plug_hints(gpointer data)
+check_startup_plug_hints(gpointer data UNUSED)
 {
     if (init_window_hints_state == 1)
     {
@@ -4055,7 +4057,7 @@
 	    Columns = w;
 	if (mask & HeightValue)
 	{
-	    if (p_window > h - 1 || !option_was_set((char_u *)"window"))
+	    if (p_window > (long)h - 1 || !option_was_set((char_u *)"window"))
 		p_window = h - 1;
 	    Rows = h;
 	}
@@ -4070,14 +4072,14 @@
 
 	if (mask & (XValue | YValue))
 	{
-	    int w, h;
-	    gui_mch_get_screen_dimensions(&w, &h);
-	    h += p_ghr + get_menu_tool_height();
-	    w += get_menu_tool_width();
+	    int ww, hh;
+	    gui_mch_get_screen_dimensions(&ww, &hh);
+	    hh += p_ghr + get_menu_tool_height();
+	    ww += get_menu_tool_width();
 	    if (mask & XNegative)
-		x += w - pixel_width;
+		x += ww - pixel_width;
 	    if (mask & YNegative)
-		y += h - pixel_height;
+		y += hh - pixel_height;
 #ifdef HAVE_GTK2
 	    gtk_window_move(GTK_WINDOW(gui.mainwin), x, y);
 #else
@@ -4229,9 +4231,8 @@
 }
 
 
-/*ARGSUSED0*/
     void
-gui_mch_exit(int rc)
+gui_mch_exit(int rc UNUSED)
 {
     if (gui.mainwin != NULL)
 	gtk_widget_destroy(gui.mainwin);
@@ -4286,7 +4287,6 @@
  * report the new size through form_configure_event().  That caused the window
  * layout to be messed up.
  */
-/*ARGSUSED0*/
     static gboolean
 force_shell_resize_idle(gpointer data)
 {
@@ -4314,12 +4314,11 @@
 /*
  * Set the windows size.
  */
-/*ARGSUSED2*/
     void
 gui_mch_set_shellsize(int width, int height,
-		      int min_width,  int min_height,
-		      int base_width, int base_height,
-		      int direction)
+		      int min_width UNUSED,  int min_height UNUSED,
+		      int base_width UNUSED, int base_height UNUSED,
+		      int direction UNUSED)
 {
 #ifndef HAVE_GTK2
     /* Hack: When the form already is at the desired size, the window might
@@ -4413,9 +4412,8 @@
 }
 
 #if defined(FEAT_TITLE) || defined(PROTO)
-/*ARGSUSED*/
     void
-gui_mch_settitle(char_u *title, char_u *icon)
+gui_mch_settitle(char_u *title, char_u *icon UNUSED)
 {
 # ifdef HAVE_GTK2
     if (title != NULL && output_conv.vc_type != CONV_NONE)
@@ -4493,7 +4491,6 @@
  * Get a font structure for highlighting.
  * "cbdata" is a pointer to the global gui structure.
  */
-/*ARGSUSED*/
     static void
 font_sel_ok(GtkWidget *wgt, gpointer cbdata)
 {
@@ -4509,7 +4506,6 @@
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static void
 font_sel_cancel(GtkWidget *wgt, gpointer cbdata)
 {
@@ -4520,7 +4516,6 @@
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static void
 font_sel_destroy(GtkWidget *wgt, gpointer cbdata)
 {
@@ -4620,7 +4615,6 @@
 /*
  * Try to load the requested fontset.
  */
-/*ARGSUSED2*/
     GuiFontset
 gui_mch_get_fontset(char_u *name, int report_error, int fixed_width)
 {
@@ -4863,7 +4857,7 @@
     styled_font[1] = &gui.ital_font;
     styled_font[2] = &gui.boldital_font;
 
-    /* First free whatever was freviously there. */
+    /* First free whatever was previously there. */
     for (i = 0; i < 3; ++i)
 	if (*styled_font[i])
 	{
@@ -5012,9 +5006,8 @@
  * Initialize Vim to use the font or fontset with the given name.
  * Return FAIL if the font could not be loaded, OK otherwise.
  */
-/*ARGSUSED1*/
     int
-gui_mch_init_font(char_u *font_name, int fontset)
+gui_mch_init_font(char_u *font_name, int fontset UNUSED)
 {
 #ifdef HAVE_GTK2
     PangoFontDescription    *font_desc;
@@ -5326,9 +5319,8 @@
 /*
  * Return the name of font "font" in allocated memory.
  */
-/*ARGSUSED*/
     char_u *
-gui_mch_get_fontname(GuiFont font, char_u *name)
+gui_mch_get_fontname(GuiFont font, char_u *name UNUSED)
 {
 # ifdef HAVE_GTK2
     if (font != NOFONT)
@@ -5732,7 +5724,7 @@
 {
     int			i;
     int			offset;
-    const static int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
+    static const int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
     int			y = FILL_Y(row + 1) - 1;
 
     /* Undercurl: draw curl at the bottom of the character cell. */
@@ -6402,7 +6394,6 @@
 /*
  * Callback function, used when data is available on the SNiFF connection.
  */
-/* ARGSUSED */
     static void
 sniff_request_cb(
     gpointer	data,
@@ -6711,9 +6702,8 @@
 /*
  * Disown the selection.
  */
-/*ARGSUSED*/
     void
-clip_mch_lose_selection(VimClipboard *cbd)
+clip_mch_lose_selection(VimClipboard *cbd UNUSED)
 {
     /* WEIRD: when using NULL to actually disown the selection, we lose the
      * selection the first time we own it. */
@@ -6741,9 +6731,8 @@
  * Send the current selection to the clipboard.  Do nothing for X because we
  * will fill in the selection only when requested by another app.
  */
-/*ARGSUSED*/
     void
-clip_mch_set_selection(VimClipboard *cbd)
+clip_mch_set_selection(VimClipboard *cbd UNUSED)
 {
 }
 
@@ -6950,7 +6939,7 @@
 	    else
 		id &= ~1;	/* they are always even (why?) */
 	}
-	else if (shape < sizeof(mshape_ids) / sizeof(int))
+	else if (shape < (int)(sizeof(mshape_ids) / sizeof(int)))
 	    id = mshape_ids[shape];
 	else
 	    return;
diff -Naur vim72.orig/src/gui_motif.c vim72/src/gui_motif.c
--- vim72.orig/src/gui_motif.c	2008-06-07 06:06:33.000000000 -0700
+++ vim72/src/gui_motif.c	2009-06-05 14:25:31.000000000 -0700
@@ -117,10 +117,9 @@
  * Call-back routines.
  */
 
-/* ARGSUSED */
     static void
 scroll_cb(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data, call_data;
 {
     scrollbar_T *sb;
@@ -136,11 +135,11 @@
 }
 
 #ifdef FEAT_GUI_TABLINE
-/*ARGSUSED*/
     static void
 tabline_cb(w, client_data, call_data)
-    Widget	w;
-    XtPointer	client_data, call_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
+    XtPointer	call_data;
 {
     XmNotebookCallbackStruct *nptr;
 
@@ -149,11 +148,11 @@
 	send_tabline_event(nptr->page_number);
 }
 
-/*ARGSUSED*/
     static void
 tabline_button_cb(w, client_data, call_data)
     Widget	w;
-    XtPointer	client_data, call_data;
+    XtPointer	client_data UNUSED;
+    XtPointer	call_data UNUSED;
 {
     int		cmd, tab_idx;
 
@@ -166,11 +165,10 @@
 /*
  * Tabline single mouse click timeout handler
  */
-/*ARGSUSED*/
     static void
 motif_tabline_timer_cb (timed_out, interval_id)
     XtPointer		timed_out;
-    XtIntervalId	*interval_id;
+    XtIntervalId	*interval_id UNUSED;
 {
     *((int *)timed_out) = TRUE;
 }
@@ -203,13 +201,12 @@
     return FALSE;
 }
 
-/*ARGSUSED*/
     static void
 tabline_menu_cb(w, closure, e, continue_dispatch)
     Widget	w;
-    XtPointer	closure;
+    XtPointer	closure UNUSED;
     XEvent	*e;
-    Boolean	*continue_dispatch;
+    Boolean	*continue_dispatch UNUSED;
 {
     Widget			tab_w;
     XButtonPressedEvent		*event;
@@ -277,11 +274,10 @@
     XtManageChild(tabLine_menu);
 }
 
-/*ARGSUSED*/
     static void
 tabline_balloon_cb(beval, state)
     BalloonEval	*beval;
-    int		state;
+    int		state UNUSED;
 {
     int		nr;
     tabpage_T	*tp;
@@ -642,13 +638,12 @@
 #endif
 }
 
-/*ARGSUSED*/
     void
 gui_mch_set_text_area_pos(x, y, w, h)
-    int	    x;
-    int	    y;
-    int	    w;
-    int	    h;
+    int	    x UNUSED;
+    int	    y UNUSED;
+    int	    w UNUSED;
+    int	    h UNUSED;
 {
 #ifdef FEAT_TOOLBAR
     /* Give keyboard focus to the textArea instead of the toolbar. */
@@ -1261,7 +1256,7 @@
     if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
     {
 	if (menu->iconidx >= 0 && menu->iconidx
-		   < (sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
+	       < (int)(sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
 	    xpm = built_in_pixmaps[menu->iconidx];
 	else
 	    xpm = tb_blank_xpm;
@@ -1716,10 +1711,9 @@
     }
 }
 
-/* ARGSUSED */
     void
 gui_mch_show_popupmenu(menu)
-    vimmenu_T *menu;
+    vimmenu_T *menu UNUSED;
 {
 #ifdef MOTIF_POPUP
     XmMenuPosition(menu->submenu_id, gui_x11_get_last_mouse_event());
@@ -2046,9 +2040,8 @@
 /*
  * Callback routine for dialog mnemonic processing.
  */
-/*ARGSUSED*/
     static void
-mnemonic_event(Widget w, XtPointer call_data, XKeyEvent *event)
+mnemonic_event(Widget w, XtPointer call_data UNUSED, XKeyEvent *event)
 {
     do_mnemonic(w, event->keycode);
 }
@@ -2287,13 +2280,12 @@
  * Put up a file requester.
  * Returns the selected name in allocated memory, or NULL for Cancel.
  */
-/* ARGSUSED */
     char_u *
 gui_mch_browse(saving, title, dflt, ext, initdir, filter)
-    int		saving;		/* select file to write */
+    int		saving UNUSED;	/* select file to write */
     char_u	*title;		/* title for the window */
     char_u	*dflt;		/* default name */
-    char_u	*ext;		/* not used (extension added) */
+    char_u	*ext UNUSED;	/* not used (extension added) */
     char_u	*initdir;	/* initial directory, NULL for current dir */
     char_u	*filter;	/* file name filter */
 {
@@ -2413,12 +2405,11 @@
 /*
  * Process callback from Dialog cancel actions.
  */
-/* ARGSUSED */
     static void
 DialogCancelCB(w, client_data, call_data)
-    Widget	w;		/*  widget id		*/
-    XtPointer	client_data;	/*  data from application   */
-    XtPointer	call_data;	/*  data from widget class  */
+    Widget	w UNUSED;		/*  widget id		*/
+    XtPointer	client_data UNUSED;	/*  data from application   */
+    XtPointer	call_data UNUSED;	/*  data from widget class  */
 {
     if (browse_fname != NULL)
     {
@@ -2431,12 +2422,11 @@
 /*
  * Process callback from Dialog actions.
  */
-/* ARGSUSED */
     static void
 DialogAcceptCB(w, client_data, call_data)
-    Widget	w;		/*  widget id		*/
-    XtPointer	client_data;	/*  data from application   */
-    XtPointer	call_data;	/*  data from widget class  */
+    Widget	w UNUSED;		/*  widget id		*/
+    XtPointer	client_data UNUSED;	/*  data from application   */
+    XtPointer	call_data;		/*  data from widget class  */
 {
     XmFileSelectionBoxCallbackStruct *fcb;
 
@@ -2467,13 +2457,12 @@
  * Callback function for the textfield.  When CR is hit this works like
  * hitting the "OK" button, ESC like "Cancel".
  */
-/* ARGSUSED */
     static void
 keyhit_callback(w, client_data, event, cont)
     Widget		w;
-    XtPointer		client_data;
+    XtPointer		client_data UNUSED;
     XEvent		*event;
-    Boolean		*cont;
+    Boolean		*cont UNUSED;
 {
     char	buf[2];
     KeySym	key_sym;
@@ -2490,12 +2479,11 @@
 	XmTextFieldClearSelection(w, XtLastTimestampProcessed(gui.dpy));
 }
 
-/* ARGSUSED */
     static void
 butproc(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     dialogStatus = (int)(long)client_data + 1;
 }
@@ -2567,10 +2555,9 @@
 }
 #endif
 
-/* ARGSUSED */
     int
 gui_mch_dialog(type, title, message, button_names, dfltbutton, textfield)
-    int		type;
+    int		type UNUSED;
     char_u	*title;
     char_u	*message;
     char_u	*button_names;
@@ -3197,7 +3184,7 @@
 		XmNchildren, &children,
 		XmNnumChildren, &numChildren, NULL);
 	borders += tst + tmh;
-	for (i = 0; i < numChildren; i++)
+	for (i = 0; i < (int)numChildren; i++)
 	{
 	    whgt = 0;
 	    XtVaGetValues(children[i], XmNheight, &whgt, NULL);
@@ -3237,13 +3224,12 @@
  * I have to use footer help for backwards compatability.  Hopefully both will
  * get implemented and the user will have a choice.
  */
-/*ARGSUSED*/
     static void
 toolbarbutton_enter_cb(w, client_data, event, cont)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XEvent	*event;
-    Boolean	*cont;
+    XEvent	*event UNUSED;
+    Boolean	*cont UNUSED;
 {
     vimmenu_T	*menu = (vimmenu_T *) client_data;
 
@@ -3254,13 +3240,12 @@
     }
 }
 
-/*ARGSUSED*/
     static void
 toolbarbutton_leave_cb(w, client_data, event, cont)
-    Widget	w;
-    XtPointer	client_data;
-    XEvent	*event;
-    Boolean	*cont;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
+    XEvent	*event UNUSED;
+    Boolean	*cont UNUSED;
 {
     gui_mch_set_footer((char_u *) "");
 }
@@ -3492,10 +3477,9 @@
 /*
  * Set the fontlist for Widget "id" to use gui.menu_fontset or gui.menu_font.
  */
-/*ARGSUSED*/
     void
 gui_motif_menu_fontlist(id)
-    Widget  id;
+    Widget  id UNUSED;
 {
 #ifdef FEAT_MENU
 #ifdef FONTSET_ALWAYS
@@ -3566,8 +3550,8 @@
     Widget cancel;
 } SharedFindReplace;
 
-static SharedFindReplace find_widgets = { NULL };
-static SharedFindReplace repl_widgets = { NULL };
+static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
+static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
 
 static void find_replace_destroy_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
 static void find_replace_dismiss_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
@@ -3576,12 +3560,11 @@
 static void find_replace_keypress __ARGS((Widget w, SharedFindReplace * frdp, XKeyEvent * event));
 static void find_replace_dialog_create __ARGS((char_u *entry_text, int do_replace));
 
-/*ARGSUSED*/
     static void
 find_replace_destroy_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     SharedFindReplace *cd = (SharedFindReplace *)client_data;
 
@@ -3590,12 +3573,11 @@
 	cd->dialog = (Widget)0;
 }
 
-/*ARGSUSED*/
     static void
 find_replace_dismiss_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     SharedFindReplace *cd = (SharedFindReplace *)client_data;
 
@@ -3603,22 +3585,20 @@
 	XtUnmanageChild(cd->dialog);
 }
 
-/*ARGSUSED*/
     static void
 entry_activate_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     XmProcessTraversal((Widget)client_data, XmTRAVERSE_CURRENT);
 }
 
-/*ARGSUSED*/
     static void
 find_replace_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     long_u	flags = (long_u)client_data;
     char	*find_text, *repl_text;
@@ -3668,10 +3648,9 @@
 	XtFree(repl_text);
 }
 
-/*ARGSUSED*/
     static void
 find_replace_keypress(w, frdp, event)
-    Widget		w;
+    Widget		w UNUSED;
     SharedFindReplace	*frdp;
     XKeyEvent		*event;
 {
diff -Naur vim72.orig/src/gui_x11.c vim72/src/gui_x11.c
--- vim72.orig/src/gui_x11.c	2008-06-08 08:13:45.000000000 -0700
+++ vim72/src/gui_x11.c	2009-06-05 14:25:31.000000000 -0700
@@ -570,22 +570,20 @@
  * Call-back routines.
  */
 
-/* ARGSUSED */
     static void
 gui_x11_timer_cb(timed_out, interval_id)
     XtPointer	    timed_out;
-    XtIntervalId    *interval_id;
+    XtIntervalId    *interval_id UNUSED;
 {
     *((int *)timed_out) = TRUE;
 }
 
-/* ARGSUSED */
     static void
 gui_x11_visibility_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     if (event->type != VisibilityNotify)
 	return;
@@ -603,13 +601,12 @@
     gui_mch_update();
 }
 
-/* ARGSUSED */
     static void
 gui_x11_expose_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     XExposeEvent	*gevent;
     int			new_x;
@@ -680,13 +677,12 @@
 }
 #endif
 
-/* ARGSUSED */
     static void
 gui_x11_resize_window_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     static int lastWidth, lastHeight;
 
@@ -727,35 +723,32 @@
 #endif
 }
 
-/* ARGSUSED */
     static void
 gui_x11_focus_change_cb(w, data, event, dum)
-    Widget	w;
-    XtPointer	data;
+    Widget	w UNUSED;
+    XtPointer	data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     gui_focus_change(event->type == FocusIn);
 }
 
-/* ARGSUSED */
     static void
 gui_x11_enter_cb(w, data, event, dum)
-    Widget	w;
-    XtPointer	data;
-    XEvent	*event;
-    Boolean	*dum;
+    Widget	w UNUSED;
+    XtPointer	data UNUSED;
+    XEvent	*event UNUSED;
+    Boolean	*dum UNUSED;
 {
     gui_focus_change(TRUE);
 }
 
-/* ARGSUSED */
     static void
 gui_x11_leave_cb(w, data, event, dum)
-    Widget	w;
-    XtPointer	data;
-    XEvent	*event;
-    Boolean	*dum;
+    Widget	w UNUSED;
+    XtPointer	data UNUSED;
+    XEvent	*event UNUSED;
+    Boolean	*dum UNUSED;
 {
     gui_focus_change(FALSE);
 }
@@ -766,13 +759,12 @@
 # endif
 #endif
 
-/* ARGSUSED */
     void
 gui_x11_key_hit_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     XKeyPressedEvent	*ev_press;
 #ifdef FEAT_XIM
@@ -1078,13 +1070,12 @@
 #endif
 }
 
-/* ARGSUSED */
     static void
 gui_x11_mouse_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     static XtIntervalId timer = (XtIntervalId)0;
     static int	timed_out = TRUE;
@@ -1210,11 +1201,11 @@
     while (arg < *argc)
     {
 	/* Look for argv[arg] in cmdline_options[] table */
-	for (i = 0; i < XtNumber(cmdline_options); i++)
+	for (i = 0; i < (int)XtNumber(cmdline_options); i++)
 	    if (strcmp(argv[arg], cmdline_options[i].option) == 0)
 		break;
 
-	if (i < XtNumber(cmdline_options))
+	if (i < (int)XtNumber(cmdline_options))
 	{
 	    /* Remember finding "-rv" or "-reverse" */
 	    if (strcmp("-rv", argv[arg]) == 0
@@ -1319,12 +1310,11 @@
 
 static void local_xsmp_handle_requests __ARGS((XtPointer c, int *s, XtInputId *i));
 
-/*ARGSUSED*/
     static void
 local_xsmp_handle_requests(c, s, i)
-    XtPointer	c;
-    int		*s;
-    XtInputId	*i;
+    XtPointer	c UNUSED;
+    int		*s UNUSED;
+    XtInputId	*i UNUSED;
 {
     if (xsmp_handle_requests() == FAIL)
 	XtRemoveInput(_xsmp_xtinputid);
@@ -1438,7 +1428,7 @@
 	    Columns = w;
 	if (mask & HeightValue)
 	{
-	    if (p_window > h - 1 || !option_was_set((char_u *)"window"))
+	    if (p_window > (long)h - 1 || !option_was_set((char_u *)"window"))
 		p_window = h - 1;
 	    Rows = h;
 	}
@@ -1587,6 +1577,8 @@
     XtCloseDisplay(gui.dpy);
     gui.dpy = NULL;
     vimShell = (Widget)0;
+    vim_free(gui_argv);
+    gui_argv = NULL;
 }
 
 /*
@@ -1751,16 +1743,17 @@
 }
 #endif
 
-/*ARGSUSED*/
     void
 gui_mch_exit(rc)
-    int		rc;
+    int		rc UNUSED;
 {
 #if 0
     /* Lesstif gives an error message here, and so does Solaris.  The man page
      * says that this isn't needed when exiting, so just skip it. */
     XtCloseDisplay(gui.dpy);
 #endif
+    vim_free(gui_argv);
+    gui_argv = NULL;
 }
 
 /*
@@ -1795,7 +1788,6 @@
 	NULL);
 }
 
-/*ARGSUSED*/
     void
 gui_mch_set_shellsize(width, height, min_width, min_height,
 		    base_width, base_height, direction)
@@ -1805,7 +1797,7 @@
     int		min_height;
     int		base_width;
     int		base_height;
-    int		direction;
+    int		direction UNUSED;
 {
 #ifdef FEAT_XIM
     height += xim_get_status_area_height(),
@@ -1843,11 +1835,10 @@
  * If "fontset" is TRUE, load the "font_name" as a fontset.
  * Return FAIL if the font could not be loaded, OK otherwise.
  */
-/*ARGSUSED*/
     int
 gui_mch_init_font(font_name, do_fontset)
     char_u	*font_name;
-    int		do_fontset;
+    int		do_fontset UNUSED;
 {
     XFontStruct	*font = NULL;
 
@@ -2025,10 +2016,9 @@
  * Return the name of font "font" in allocated memory.
  * Don't know how to get the actual name, thus use the provided name.
  */
-/*ARGSUSED*/
     char_u *
 gui_mch_get_fontname(font, name)
-    GuiFont font;
+    GuiFont font UNUSED;
     char_u  *name;
 {
     if (name == NULL)
@@ -2450,7 +2440,7 @@
 	*colorPtr = colortable[closest];
     }
 
-    free(colortable);
+    vim_free(colortable);
     return OK;
 }
 
@@ -2517,7 +2507,7 @@
 {
     int			i;
     int			offset;
-    const static int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
+    static const int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
 
     XSetForeground(gui.dpy, gui.text_gc, prev_sp_color);
     for (i = FILL_X(col); i < FILL_X(col + cells); ++i)
@@ -2565,8 +2555,10 @@
 # ifdef FEAT_XFONTSET
 	    if (current_fontset != NULL)
 	    {
-		if (c >= 0x10000 && sizeof(wchar_t) <= 2)
+#  ifdef SMALL_WCHAR_T
+		if (c >= 0x10000)
 		    c = 0xbf;		/* show chars > 0xffff as ? */
+#  endif
 		((wchar_t *)buf)[wlen] = c;
 	    }
 	    else
@@ -3132,11 +3124,11 @@
     /* Nothing to do in X */
 }
 
-/* ARGSUSED */
     void
 gui_x11_menu_cb(w, client_data, call_data)
-    Widget	w;
-    XtPointer	client_data, call_data;
+    Widget	w UNUSED;
+    XtPointer	client_data;
+    XtPointer	call_data UNUSED;
 {
     gui_menu_cb((vimmenu_T *)client_data);
 }
@@ -3149,13 +3141,12 @@
  * Function called when window closed.	Works like ":qa".
  * Should put up a requester!
  */
-/*ARGSUSED*/
     static void
 gui_x11_wm_protocol_handler(w, client_data, event, dum)
-    Widget	w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     /*
      * Only deal with Client messages.
@@ -3168,7 +3159,7 @@
      * exit.  That can be cancelled though, thus Vim shouldn't exit here.
      * Just sync our swap files.
      */
-    if (((XClientMessageEvent *)event)->data.l[0] ==
+    if ((Atom)((XClientMessageEvent *)event)->data.l[0] ==
 						  wm_atoms[SAVE_YOURSELF_IDX])
     {
 	out_flush();
@@ -3181,7 +3172,7 @@
 	return;
     }
 
-    if (((XClientMessageEvent *)event)->data.l[0] !=
+    if ((Atom)((XClientMessageEvent *)event)->data.l[0] !=
 						  wm_atoms[DELETE_WINDOW_IDX])
 	return;
 
@@ -3192,13 +3183,12 @@
 /*
  * Function called when property changed. Check for incoming commands
  */
-/*ARGSUSED*/
     static void
 gui_x11_send_event_handler(w, client_data, event, dum)
-    Widget	w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     XPropertyEvent *e = (XPropertyEvent *) event;
 
@@ -3273,11 +3263,10 @@
     }
 }
 
-/* ARGSUSED */
     static void
 gui_x11_blink_cb(timed_out, interval_id)
-    XtPointer	    timed_out;
-    XtIntervalId    *interval_id;
+    XtPointer	    timed_out UNUSED;
+    XtIntervalId    *interval_id UNUSED;
 {
     if (blink_state == BLINK_ON)
     {
@@ -3439,47 +3428,37 @@
     char_u	    *signfile;
 {
     XpmAttributes   attrs;
-    XImage	    *sign;
+    XImage	    *sign = NULL;
     int		    status;
 
     /*
      * Setup the color substitution table.
      */
-    sign = NULL;
     if (signfile[0] != NUL && signfile[0] != '-')
     {
-	sign = (XImage *)alloc(sizeof(XImage));
-	if (sign != NULL)
+	XpmColorSymbol color[5] =
 	{
-	    XpmColorSymbol color[5] =
-	    {
-		{"none", NULL, 0},
-		{"iconColor1", NULL, 0},
-		{"bottomShadowColor", NULL, 0},
-		{"topShadowColor", NULL, 0},
-		{"selectColor", NULL, 0}
-	    };
-	    attrs.valuemask = XpmColorSymbols;
-	    attrs.numsymbols = 2;
-	    attrs.colorsymbols = color;
-	    attrs.colorsymbols[0].pixel = gui.back_pixel;
-	    attrs.colorsymbols[1].pixel = gui.norm_pixel;
-	    status = XpmReadFileToImage(gui.dpy, (char *)signfile,
+	    {"none", NULL, 0},
+	    {"iconColor1", NULL, 0},
+	    {"bottomShadowColor", NULL, 0},
+	    {"topShadowColor", NULL, 0},
+	    {"selectColor", NULL, 0}
+	};
+	attrs.valuemask = XpmColorSymbols;
+	attrs.numsymbols = 2;
+	attrs.colorsymbols = color;
+	attrs.colorsymbols[0].pixel = gui.back_pixel;
+	attrs.colorsymbols[1].pixel = gui.norm_pixel;
+	status = XpmReadFileToImage(gui.dpy, (char *)signfile,
 							 &sign, NULL, &attrs);
-
-	    if (status == 0)
-	    {
-		/* Sign width is fixed at two columns now.
-		if (sign->width > gui.sign_width)
-		    gui.sign_width = sign->width + 8; */
-	    }
-	    else
-	    {
-		vim_free(sign);
-		sign = NULL;
-		EMSG(_(e_signdata));
-	    }
+	if (status == 0)
+	{
+	    /* Sign width is fixed at two columns now.
+	    if (sign->width > gui.sign_width)
+	        gui.sign_width = sign->width + 8; */
 	}
+	else
+	    EMSG(_(e_signdata));
     }
 
     return (void *)sign;
@@ -3489,8 +3468,7 @@
 gui_mch_destroy_sign(sign)
     void *sign;
 {
-    XFree(((XImage *)sign)->data);
-    vim_free(sign);
+    XDestroyImage((XImage*)sign);
 }
 #endif
 
diff -Naur vim72.orig/src/gui_xmdlg.c vim72/src/gui_xmdlg.c
--- vim72.orig/src/gui_xmdlg.c	2008-06-21 09:05:32.000000000 -0700
+++ vim72/src/gui_xmdlg.c	2009-06-05 14:25:31.000000000 -0700
@@ -369,10 +369,10 @@
     char	buf[TEMP_BUF_SIZE];
     XmString	items[MAX_ENTRIES_IN_LIST];
     int		i;
-    int		index;
+    int		idx;
 
-    for (index = (int)ENCODING; index < (int)NONE; ++index)
-	count[index] = 0;
+    for (idx = (int)ENCODING; idx < (int)NONE; ++idx)
+	count[idx] = 0;
 
     /* First we insert the wild char into every single list. */
     if (fix != ENCODING)
@@ -448,7 +448,7 @@
 
 	    items[i] = XmStringCreateLocalized(list[ENCODING][i]);
 
-	    if (i < n_items)
+	    if (i < (int)n_items)
 	    {
 		/* recycle old button */
 		XtVaSetValues(children[i],
@@ -481,7 +481,7 @@
 
 	/* Destroy all the outstanding menu items.
 	 */
-	for (i = count[ENCODING]; i < n_items; ++i)
+	for (i = count[ENCODING]; i < (int)n_items; ++i)
 	{
 	    XtUnmanageChild(children[i]);
 	    XtDestroyWidget(children[i]);
@@ -503,14 +503,14 @@
     /*
      * Now loop trough the remaining lists and set them up.
      */
-    for (index = (int)NAME; index < (int)NONE; ++index)
+    for (idx = (int)NAME; idx < (int)NONE; ++idx)
     {
 	Widget w;
 
-	if (fix == (enum ListSpecifier)index)
+	if (fix == (enum ListSpecifier)idx)
 	    continue;
 
-	switch ((enum ListSpecifier)index)
+	switch ((enum ListSpecifier)idx)
 	{
 	    case NAME:
 		w = data->list[NAME];
@@ -525,28 +525,27 @@
 		w = (Widget)0;	/* for lint */
 	}
 
-	for (i = 0; i < count[index]; ++i)
+	for (i = 0; i < count[idx]; ++i)
 	{
-	    items[i] = XmStringCreateLocalized(list[index][i]);
-	    XtFree(list[index][i]);
+	    items[i] = XmStringCreateLocalized(list[idx][i]);
+	    XtFree(list[idx][i]);
 	}
 	XmListDeleteAllItems(w);
-	XmListAddItems(w, items, count[index], 1);
-	if (data->sel[index])
+	XmListAddItems(w, items, count[idx], 1);
+	if (data->sel[idx])
 	{
 	    XmStringFree(items[0]);
-	    items[0] = XmStringCreateLocalized(data->sel[index]);
+	    items[0] = XmStringCreateLocalized(data->sel[idx]);
 	    XmListSelectItem(w, items[0], False);
 	    XmListSetBottomItem(w, items[0]);
 	}
-	for (i = 0; i < count[index]; ++i)
+	for (i = 0; i < count[idx]; ++i)
 	    XmStringFree(items[i]);
     }
 }
 
-/*ARGSUSED*/
     static void
-stoggle_callback(Widget w,
+stoggle_callback(Widget w UNUSED,
 	SharedFontSelData *data,
 	XmToggleButtonCallbackStruct *call_data)
 {
@@ -695,25 +694,24 @@
 	int	    n;
 	XmString    str;
 	Arg	    args[4];
-	char	    *msg = _("no specific match");
+	char	    *nomatch_msg = _("no specific match");
 
 	n = 0;
-	str = XmStringCreateLocalized(msg);
+	str = XmStringCreateLocalized(nomatch_msg);
 	XtSetArg(args[n], XmNlabelString, str); ++n;
 	XtSetValues(data->sample, args, n);
 	apply_fontlist(data->sample);
-	XmTextSetString(data->name, msg);
+	XmTextSetString(data->name, nomatch_msg);
 	XmStringFree(str);
 
 	return False;
     }
 }
 
-/*ARGSUSED*/
     static void
 encoding_callback(Widget w,
 	SharedFontSelData *data,
-	XtPointer dummy)
+	XtPointer dummy UNUSED)
 {
     XmString str;
     XmListCallbackStruct fake_data;
@@ -752,11 +750,10 @@
     do_choice(w, data, call_data, SIZE);
 }
 
-/*ARGSUSED*/
     static void
-cancel_callback(Widget w,
+cancel_callback(Widget w UNUSED,
 	SharedFontSelData *data,
-	XmListCallbackStruct *call_data)
+	XmListCallbackStruct *call_data UNUSED)
 {
     if (data->sel[ENCODING])
     {
@@ -789,11 +786,10 @@
     data->exit = True;
 }
 
-/*ARGSUSED*/
     static void
-ok_callback(Widget w,
+ok_callback(Widget w UNUSED,
 	SharedFontSelData *data,
-	XmPushButtonCallbackStruct *call_data)
+	XmPushButtonCallbackStruct *call_data UNUSED)
 {
     char    *pattern;
     char    **name;
@@ -886,21 +882,21 @@
     {
 	int	i;
 	int	max;
-	int	index = 0;
+	int	idx = 0;
 	int	size;
-	char	str[128];
+	char	buf[128];
 
 	for (i = 0, max = 0; i < data->num; i++)
 	{
-	    get_part(fn(data, i), 7, str);
-	    size = atoi(str);
+	    get_part(fn(data, i), 7, buf);
+	    size = atoi(buf);
 	    if ((size > max) && (size < MAX_DISPLAY_SIZE))
 	    {
-		index = i;
+		idx = i;
 		max = size;
 	    }
 	}
-	strcpy(big_font, fn(data, index));
+	strcpy(big_font, fn(data, idx));
     }
     data->old = XLoadQueryFont(XtDisplay(parent), big_font);
     data->old_list = gui_motif_create_fontlist(data->old);
@@ -1217,28 +1213,28 @@
 
 	if (i != 0)
 	{
-	    char name[TEMP_BUF_SIZE];
-	    char style[TEMP_BUF_SIZE];
-	    char size[TEMP_BUF_SIZE];
-	    char encoding[TEMP_BUF_SIZE];
+	    char namebuf[TEMP_BUF_SIZE];
+	    char stylebuf[TEMP_BUF_SIZE];
+	    char sizebuf[TEMP_BUF_SIZE];
+	    char encodingbuf[TEMP_BUF_SIZE];
 	    char *found;
 
 	    found = names[0];
 
-	    name_part(found, name);
-	    style_part(found, style);
-	    size_part(found, size, data->in_pixels);
-	    encoding_part(found, encoding);
-
-	    if (strlen(name) > 0
-		    && strlen(style) > 0
-		    && strlen(size) > 0
-		    && strlen(encoding) > 0)
+	    name_part(found, namebuf);
+	    style_part(found, stylebuf);
+	    size_part(found, sizebuf, data->in_pixels);
+	    encoding_part(found, encodingbuf);
+
+	    if (strlen(namebuf) > 0
+		    && strlen(stylebuf) > 0
+		    && strlen(sizebuf) > 0
+		    && strlen(encodingbuf) > 0)
 	    {
-		data->sel[NAME] = XtNewString(name);
-		data->sel[STYLE] = XtNewString(style);
-		data->sel[SIZE] = XtNewString(size);
-		data->sel[ENCODING] = XtNewString(encoding);
+		data->sel[NAME] = XtNewString(namebuf);
+		data->sel[STYLE] = XtNewString(stylebuf);
+		data->sel[SIZE] = XtNewString(sizebuf);
+		data->sel[ENCODING] = XtNewString(encodingbuf);
 		data->font_name = XtNewString(names[0]);
 		display_sample(data);
 		XmTextSetString(data->name, data->font_name);
diff -Naur vim72.orig/src/gui_xmebw.c vim72/src/gui_xmebw.c
--- vim72.orig/src/gui_xmebw.c	2007-09-06 03:57:51.000000000 -0700
+++ vim72/src/gui_xmebw.c	2009-06-05 14:25:31.000000000 -0700
@@ -235,13 +235,12 @@
     return tmp;
 }
 
-/*ARGSUSED*/
     static int
 alloc_color(Display	*display,
 	Colormap	colormap,
 	char		*colorname,
 	XColor		*xcolor,
-	void		*closure)
+	void		*closure UNUSED)
 {
     int status;
 
@@ -595,9 +594,10 @@
 		       XtHeight(eb), eb->primitive.highlight_thickness);
 }
 
-/*ARGSUSED*/
     static void
-draw_pixmap(XmEnhancedButtonWidget eb, XEvent *event, Region region)
+draw_pixmap(XmEnhancedButtonWidget eb,
+	    XEvent *event UNUSED,
+	    Region region UNUSED)
 {
     Pixmap	pix;
     GC		gc = eb->label.normal_GC;
@@ -641,7 +641,7 @@
     height = eb->core.height - 2 * y;
     if (h < height)
 	height = h;
-    if (depth == eb->core.depth)
+    if (depth == (int)eb->core.depth)
 	XCopyArea(XtDisplay(eb), pix, XtWindow(eb), gc, 0, 0,
 		width, height, x, y);
     else if (depth == 1)
@@ -731,9 +731,11 @@
 	eb->label.normal_GC = tmp_gc;
 }
 
-/*ARGSUSED*/
     static void
-Enter(Widget wid, XEvent *event, String *params, Cardinal *num_params)
+Enter(Widget wid,
+      XEvent *event,
+      String *params UNUSED,
+      Cardinal *num_params UNUSED)
 {
     XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget) wid;
     XmPushButtonCallbackStruct call_value;
@@ -818,9 +820,11 @@
     }
 }
 
-/*ARGSUSED*/
     static void
-Leave(Widget wid, XEvent *event, String *params, Cardinal *num_params)
+Leave(Widget wid,
+      XEvent *event,
+      String *params UNUSED,
+      Cardinal *num_params UNUSED)
 {
     XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget)wid;
     XmPushButtonCallbackStruct call_value;
@@ -976,9 +980,8 @@
     }
 }
 
-/*ARGSUSED*/
     static void
-Initialize(Widget rq, Widget ebw, ArgList args, Cardinal *n)
+Initialize(Widget rq, Widget ebw, ArgList args UNUSED, Cardinal *n UNUSED)
 {
     XmEnhancedButtonWidget  request = (XmEnhancedButtonWidget)rq;
     XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget)ebw;
@@ -1056,9 +1059,12 @@
     free_pixmaps((XmEnhancedButtonWidget)w);
 }
 
-/*ARGSUSED*/
     static Boolean
-SetValues(Widget current, Widget request, Widget new, ArgList args, Cardinal *n)
+SetValues(Widget current,
+	  Widget request UNUSED,
+	  Widget new,
+	  ArgList args UNUSED,
+	  Cardinal *n UNUSED)
 {
     XmEnhancedButtonWidget  cur = (XmEnhancedButtonWidget) current;
     XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget) new;
@@ -1108,7 +1114,7 @@
 		if ((win_x < 0) || (win_y < 0))
 		    return False;
 
-		if ((win_x > r_width) || (win_y > r_height))
+		if ((win_x > (int)r_width) || (win_y > (int)r_height))
 		    return False;
 		draw_highlight(eb);
 		draw_shadows(eb);
@@ -1256,7 +1262,7 @@
     }
     else
     {
-	int adjust = 0;
+	adjust = 0;
 
 #if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	/*
@@ -1268,12 +1274,11 @@
 	{
 	    case XmEXTERNAL_HIGHLIGHT:
 		adjust = (eb->primitive.highlight_thickness -
-			(eb->pushbutton.default_button_shadow_thickness ?
-			 Xm3D_ENHANCE_PIXEL : 0));
+			 (eb->pushbutton.default_button_shadow_thickness
+			  ?  Xm3D_ENHANCE_PIXEL : 0));
 		break;
 
 	    case XmINTERNAL_HIGHLIGHT:
-		adjust = 0;
 		break;
 
 	    default:
diff -Naur vim72.orig/src/hardcopy.c vim72/src/hardcopy.c
--- vim72.orig/src/hardcopy.c	2008-01-11 12:46:20.000000000 -0800
+++ vim72/src/hardcopy.c	2009-06-05 14:25:02.000000000 -0700
@@ -442,12 +442,11 @@
 /*
  * Print the page header.
  */
-/*ARGSUSED*/
     static void
 prt_header(psettings, pagenum, lnum)
     prt_settings_T  *psettings;
     int		pagenum;
-    linenr_T	lnum;
+    linenr_T	lnum UNUSED;
 {
     int		width = psettings->chars_per_line;
     int		page_line;
@@ -1881,7 +1880,7 @@
 	return FALSE;
 
     /* Find type of DSC comment */
-    for (comment = 0; comment < NUM_ELEMENTS(prt_dsc_table); comment++)
+    for (comment = 0; comment < (int)NUM_ELEMENTS(prt_dsc_table); comment++)
 	if (prt_resfile_strncmp(0, prt_dsc_table[comment].string,
 					    prt_dsc_table[comment].len) == 0)
 	    break;
@@ -2454,12 +2453,11 @@
 }
 #endif
 
-/*ARGSUSED*/
     int
 mch_print_init(psettings, jobname, forceit)
     prt_settings_T *psettings;
     char_u	*jobname;
-    int		forceit;
+    int		forceit UNUSED;
 {
     int		i;
     char	*paper_name;
@@ -2514,7 +2512,7 @@
     if (!(props & ENC_8BIT) && ((*p_pmcs != NUL) || !(props & ENC_UNICODE)))
     {
 	p_mbenc_first = NULL;
-	for (cmap = 0; cmap < NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
+	for (cmap = 0; cmap < (int)NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
 	    if (prt_match_encoding((char *)p_encoding, &prt_ps_mbfonts[cmap],
 								    &p_mbenc))
 	    {
@@ -2642,7 +2640,7 @@
 	paper_name = "A4";
 	paper_strlen = 2;
     }
-    for (i = 0; i < PRT_MEDIASIZE_LEN; ++i)
+    for (i = 0; i < (int)PRT_MEDIASIZE_LEN; ++i)
 	if (STRLEN(prt_mediasize[i].name) == (unsigned)paper_strlen
 		&& STRNICMP(prt_mediasize[i].name, paper_name,
 							   paper_strlen) == 0)
@@ -3308,10 +3306,9 @@
     return !prt_file_error;
 }
 
-/*ARGSUSED*/
     int
 mch_print_begin_page(str)
-    char_u	*str;
+    char_u	*str UNUSED;
 {
     int		page_num[2];
 
@@ -3379,11 +3376,10 @@
 #endif
 }
 
-/*ARGSUSED*/
     int
 mch_print_text_out(p, len)
     char_u	*p;
-    int		len;
+    int		len UNUSED;
 {
     int		need_break;
     char_u	ch;
diff -Naur vim72.orig/src/if_cscope.c vim72/src/if_cscope.c
--- vim72.orig/src/if_cscope.c	2008-06-24 09:32:34.000000000 -0700
+++ vim72/src/if_cscope.c	2009-06-05 14:25:02.000000000 -0700
@@ -74,7 +74,7 @@
     { "add",	cs_add,
 		N_("Add a new database"),     "add file|dir [pre-path] [flags]", 0 },
     { "find",	cs_find,
-		N_("Query for a pattern"),    FIND_USAGE, 1 },
+		N_("Query for a pattern"),    "find c|d|e|f|g|i|s|t name", 1 },
     { "help",	cs_help,
 		N_("Show this message"),      "help", 0 },
     { "kill",	cs_kill,
@@ -83,7 +83,7 @@
 		N_("Reinit all connections"), "reset", 0 },
     { "show",	cs_show,
 		N_("Show connections"),       "show", 0 },
-    { NULL }
+    { NULL, NULL, NULL, NULL, 0 }
 };
 
     static void
@@ -93,12 +93,128 @@
     (void)EMSG2(_("E560: Usage: cs[cope] %s"), cs_cmds[(int)x].usage);
 }
 
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+
+static enum
+{
+    EXP_CSCOPE_SUBCMD,	/* expand ":cscope" sub-commands */
+    EXP_SCSCOPE_SUBCMD,	/* expand ":scscope" sub-commands */
+    EXP_CSCOPE_FIND,	/* expand ":cscope find" arguments */
+    EXP_CSCOPE_KILL	/* expand ":cscope kill" arguments */
+} expand_what;
+
+/*
+ * Function given to ExpandGeneric() to obtain the cscope command
+ * expansion.
+ */
+    char_u *
+get_cscope_name(xp, idx)
+    expand_T	*xp UNUSED;
+    int		idx;
+{
+    int		current_idx;
+    int		i;
+
+    switch (expand_what)
+    {
+    case EXP_CSCOPE_SUBCMD:
+	/* Complete with sub-commands of ":cscope":
+	 * add, find, help, kill, reset, show */
+	return (char_u *)cs_cmds[idx].name;
+    case EXP_SCSCOPE_SUBCMD:
+	/* Complete with sub-commands of ":scscope": same sub-commands as
+	 * ":cscope" but skip commands which don't support split windows */
+	for (i = 0, current_idx = 0; cs_cmds[i].name != NULL; i++)
+	    if (cs_cmds[i].cansplit)
+		if (current_idx++ == idx)
+		    break;
+	return (char_u *)cs_cmds[i].name;
+    case EXP_CSCOPE_FIND:
+	{
+	    const char *query_type[] =
+	    {
+		"c", "d", "e", "f", "g", "i", "s", "t", NULL
+	    };
+
+	    /* Complete with query type of ":cscope find {query_type}".
+	     * {query_type} can be letters (c, d, ... t) or numbers (0, 1,
+	     * ..., 8) but only complete with letters, since numbers are
+	     * redundant. */
+	    return (char_u *)query_type[idx];
+	}
+    case EXP_CSCOPE_KILL:
+	{
+	    static char_u	connection[2];
+
+	    /* ":cscope kill" accepts connection numbers or partial names of
+	     * the pathname of the cscope database as argument.  Only complete
+	     * with connection numbers. -1 can also be used to kill all
+	     * connections. */
+	    for (i = 0, current_idx = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+	    {
+		if (csinfo[i].fname == NULL)
+		    continue;
+		if (current_idx++ == idx)
+		{
+		    /* Connection number fits in one character since
+		     * CSCOPE_MAX_CONNECTIONS is < 10 */
+		    connection[0] = i + '0';
+		    connection[1] = NUL;
+		    return connection;
+		}
+	    }
+	    return (current_idx == idx && idx > 0) ? (char_u *)"-1" : NULL;
+	}
+    default:
+	return NULL;
+    }
+}
+
+/*
+ * Handle command line completion for :cscope command.
+ */
+    void
+set_context_in_cscope_cmd(xp, arg, cmdidx)
+    expand_T	*xp;
+    char_u	*arg;
+    cmdidx_T	cmdidx;
+{
+    char_u	*p;
+
+    /* Default: expand subcommands */
+    xp->xp_context = EXPAND_CSCOPE;
+    xp->xp_pattern = arg;
+    expand_what = (cmdidx == CMD_scscope)
+			? EXP_SCSCOPE_SUBCMD : EXP_CSCOPE_SUBCMD;
+
+    /* (part of) subcommand already typed */
+    if (*arg != NUL)
+    {
+	p = skiptowhite(arg);
+	if (*p != NUL)		    /* past first word */
+	{
+	    xp->xp_pattern = skipwhite(p);
+	    if (*skiptowhite(xp->xp_pattern) != NUL)
+		xp->xp_context = EXPAND_NOTHING;
+	    else if (STRNICMP(arg, "add", p - arg) == 0)
+		xp->xp_context = EXPAND_FILES;
+	    else if (STRNICMP(arg, "kill", p - arg) == 0)
+		expand_what = EXP_CSCOPE_KILL;
+	    else if (STRNICMP(arg, "find", p - arg) == 0)
+		expand_what = EXP_CSCOPE_FIND;
+	    else
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+}
+
+#endif /* FEAT_CMDL_COMPL */
+
 /*
  * PRIVATE: do_cscope_general
  *
- * find the command, print help if invalid, and the then call the
- * corresponding command function,
- * called from do_cscope and do_scscope
+ * Find the command, print help if invalid, and then call the corresponding
+ * command function.
  */
     static void
 do_cscope_general(eap, make_split)
@@ -379,10 +495,9 @@
  *
  * MAXPATHL 256
  */
-/* ARGSUSED */
     static int
 cs_add(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     char *fname, *ppath, *flags = NULL;
 
@@ -659,6 +774,7 @@
 {
     char *cmd;
     short search;
+    char *pat;
 
     switch (csoption[0])
     {
@@ -692,10 +808,17 @@
 	return NULL;
     }
 
-    if ((cmd = (char *)alloc((unsigned)(strlen(pattern) + 2))) == NULL)
+    /* Skip white space before the patter, except for text and pattern search,
+     * they may want to use the leading white space. */
+    pat = pattern;
+    if (search != 4 && search != 6)
+	while vim_iswhite(*pat)
+	    ++pat;
+
+    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
 	return NULL;
 
-    (void)sprintf(cmd, "%d%s", search, pattern);
+    (void)sprintf(cmd, "%d%s", search, pat);
 
     return cmd;
 } /* cs_create_cmd */
@@ -869,7 +992,7 @@
 	vim_free(ppath);
 
 #if defined(UNIX)
-	if (execl("/bin/sh", "sh", "-c", cmd, NULL) == -1)
+	if (execl("/bin/sh", "sh", "-c", cmd, (char *)NULL) == -1)
 	    PERROR(_("cs_create_connection exec failed"));
 
 	exit(127);
@@ -1167,20 +1290,36 @@
  *
  * print help
  */
-/* ARGSUSED */
     static int
 cs_help(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     cscmd_T *cmdp = cs_cmds;
 
     (void)MSG_PUTS(_("cscope commands:\n"));
     while (cmdp->name != NULL)
     {
-	(void)smsg((char_u *)_("%-5s: %-30s (Usage: %s)"),
-				      cmdp->name, _(cmdp->help), cmdp->usage);
+	char *help = _(cmdp->help);
+	int  space_cnt = 30 - vim_strsize((char_u *)help);
+
+	/* Use %*s rather than %30s to ensure proper alignment in utf-8 */
+	if (space_cnt < 0)
+	    space_cnt = 0;
+	(void)smsg((char_u *)_("%-5s: %s%*s (Usage: %s)"),
+				      cmdp->name,
+				      help, space_cnt, " ",
+				      cmdp->usage);
 	if (strcmp(cmdp->name, "find") == 0)
-	    MSG_PUTS(FIND_HELP);
+	    MSG_PUTS(_("\n"
+		       "       c: Find functions calling this function\n"
+		       "       d: Find functions called by this function\n"
+		       "       e: Find this egrep pattern\n"
+		       "       f: Find this file\n"
+		       "       g: Find this definition\n"
+		       "       i: Find files #including this file\n"
+		       "       s: Find this C symbol\n"
+		       "       t: Find assignments to\n"));
+
 	cmdp++;
     }
 
@@ -1257,13 +1396,12 @@
  *
  * insert a new cscope database filename into the filelist
  */
-/*ARGSUSED*/
     static int
 cs_insert_filelist(fname, ppath, flags, sb)
     char *fname;
     char *ppath;
     char *flags;
-    struct stat *sb;
+    struct stat *sb UNUSED;
 {
     short	i, j;
 #ifndef UNIX
@@ -1419,10 +1557,9 @@
  *
  * nuke em
  */
-/* ARGSUSED */
     static int
 cs_kill(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     char *stok;
     short i;
@@ -2099,7 +2236,6 @@
 /*
  * Used to catch and ignore SIGALRM below.
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sig_handler SIGDEFARG(sigarg)
 {
@@ -2239,10 +2375,9 @@
  *
  * calls cs_kill on all cscope connections then reinits
  */
-/* ARGSUSED */
     static int
 cs_reset(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     char	**dblist = NULL, **pplist = NULL, **fllist = NULL;
     int	i;
@@ -2355,10 +2490,9 @@
  *
  * show all cscope connections
  */
-/* ARGSUSED */
     static int
 cs_show(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     short i;
     if (cs_cnt_connections() == 0)
diff -Naur vim72.orig/src/if_cscope.h vim72/src/if_cscope.h
--- vim72.orig/src/if_cscope.h	2007-09-02 07:51:08.000000000 -0700
+++ vim72/src/if_cscope.h	2009-06-05 14:14:12.000000000 -0700
@@ -42,17 +42,6 @@
  * f 7name	Find this file
  * i 8name	Find files #including this file
  */
-#define	FIND_USAGE "find c|d|e|f|g|i|s|t name"
-#define FIND_HELP "\n\
-       c: Find functions calling this function\n\
-       d: Find functions called by this function\n\
-       e: Find this egrep pattern\n\
-       f: Find this file\n\
-       g: Find this definition\n\
-       i: Find files #including this file\n\
-       s: Find this C symbol\n\
-       t: Find assignments to\n"
-
 
 typedef struct {
     char *  name;
diff -Naur vim72.orig/src/if_mzsch.c vim72/src/if_mzsch.c
--- vim72.orig/src/if_mzsch.c	2007-07-01 09:44:49.000000000 -0700
+++ vim72/src/if_mzsch.c	2009-06-05 14:25:19.000000000 -0700
@@ -667,13 +667,11 @@
     static void CALLBACK
 timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
 # elif defined(FEAT_GUI_GTK)
-/*ARGSUSED*/
     static gint
-timer_proc(gpointer data)
+timer_proc(gpointer data UNUSED)
 # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
-/* ARGSUSED */
     static void
-timer_proc(XtPointer timed_out, XtIntervalId *interval_id)
+timer_proc(XtPointer timed_out UNUSED, XtIntervalId *interval_id UNUSED)
 # elif defined(FEAT_GUI_MAC)
     pascal void
 timer_proc(EventLoopTimerRef theTimer, void *userData)
diff -Naur vim72.orig/src/if_perl.xs vim72/src/if_perl.xs
--- vim72.orig/src/if_perl.xs	2008-07-17 13:55:09.000000000 -0700
+++ vim72/src/if_perl.xs	2009-06-05 14:18:24.000000000 -0700
@@ -136,6 +136,9 @@
 #  define Perl_newXS_flags dll_Perl_newXS_flags
 #endif
 # define Perl_sv_free dll_Perl_sv_free
+# if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
+#  define Perl_sv_free2 dll_Perl_sv_free2
+# endif
 # define Perl_sv_isa dll_Perl_sv_isa
 # define Perl_sv_magic dll_Perl_sv_magic
 # define Perl_sv_setiv dll_Perl_sv_setiv
@@ -163,7 +166,7 @@
 # define Perl_Isv_yes_ptr dll_Perl_Isv_yes_ptr
 # define boot_DynaLoader dll_boot_DynaLoader
 
-# define Perl_sys_init3 dll_Perl_sys_init3
+# define Perl_sys_init dll_Perl_sys_init
 # define Perl_sys_term dll_Perl_sys_term
 # define Perl_ISv_ptr dll_Perl_ISv_ptr
 # define Perl_Istack_max_ptr dll_Perl_Istack_max_ptr
@@ -268,7 +271,8 @@
 static void (*boot_DynaLoader)_((pTHX_ CV*));
 
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
-static void (*Perl_sys_init3)(int* argc, char*** argv, char*** env);
+static void (*Perl_sv_free2)(pTHX_ SV*);
+static void (*Perl_sys_init)(int* argc, char*** argv);
 static void (*Perl_sys_term)(void);
 static SV** (*Perl_ISv_ptr)(register PerlInterpreter*);
 static SV*** (*Perl_Istack_max_ptr)(register PerlInterpreter*);
@@ -367,7 +371,8 @@
     {"Perl_TXpv_ptr", (PERL_PROC*)&Perl_TXpv_ptr},
     {"Perl_Tna_ptr", (PERL_PROC*)&Perl_Tna_ptr},
 #else
-    {"Perl_sys_init3", (PERL_PROC*)&Perl_sys_init3},
+    {"Perl_sv_free2", (PERL_PROC*)&Perl_sv_free2},
+    {"Perl_sys_init", (PERL_PROC*)&Perl_sys_init},
     {"Perl_sys_term", (PERL_PROC*)&Perl_sys_term},
     {"Perl_ISv_ptr", (PERL_PROC*)&Perl_ISv_ptr},
     {"Perl_Istack_sp_ptr", (PERL_PROC*)&Perl_Istack_sp_ptr},
@@ -455,7 +460,7 @@
     static char *argv[] = { "", "-e", "" };
 
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
-    Perl_sys_init3(&argc, (char***)&argv, NULL);
+    Perl_sys_init(&argc, (char***)&argv);
 #endif
     perl_interp = perl_alloc();
     perl_construct(perl_interp);
diff -Naur vim72.orig/src/if_python.c vim72/src/if_python.c
--- vim72.orig/src/if_python.c	2008-07-17 14:09:32.000000000 -0700
+++ vim72/src/if_python.c	2009-06-05 14:25:31.000000000 -0700
@@ -531,6 +531,12 @@
 	if (PythonMod_Init())
 	    goto fail;
 
+	/* Remove the element from sys.path that was added because of our
+	 * argv[0] value in PythonMod_Init().  Previously we used an empty
+	 * string, but dependinding on the OS we then get an empty entry or
+	 * the current directory in sys.path. */
+	PyRun_SimpleString("import sys; sys.path = filter(lambda x: x != '/must>not&exist', sys.path)");
+
 	/* the first python thread is vim's, release the lock */
 	Python_SaveThread();
 
@@ -1090,9 +1096,8 @@
 
 /* Vim module - Implementation
  */
-/*ARGSUSED*/
     static PyObject *
-VimCommand(PyObject *self, PyObject *args)
+VimCommand(PyObject *self UNUSED, PyObject *args)
 {
     char *cmd;
     PyObject *result;
@@ -1145,14 +1150,23 @@
 
     /* Check if we run into a recursive loop.  The item must be in lookupDict
      * then and we can use it again. */
-    sprintf(ptrBuf, PRINTF_DECIMAL_LONG_U, (long_u)our_tv);
-    result = PyDict_GetItemString(lookupDict, ptrBuf);
-    if (result != NULL)
-	Py_INCREF(result);
-    else if (our_tv->v_type == VAR_STRING)
+    if ((our_tv->v_type == VAR_LIST && our_tv->vval.v_list != NULL)
+	    || (our_tv->v_type == VAR_DICT && our_tv->vval.v_dict != NULL))
+    {
+	sprintf(ptrBuf, PRINTF_DECIMAL_LONG_U,
+	        our_tv->v_type == VAR_LIST ? (long_u)our_tv->vval.v_list
+		                           : (long_u)our_tv->vval.v_dict);
+	result = PyDict_GetItemString(lookupDict, ptrBuf);
+	if (result != NULL)
+	{
+	    Py_INCREF(result);
+	    return result;
+	}
+    }
+
+    if (our_tv->v_type == VAR_STRING)
     {
 	result = Py_BuildValue("s", our_tv->vval.v_string);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
     }
     else if (our_tv->v_type == VAR_NUMBER)
     {
@@ -1161,7 +1175,6 @@
 	/* For backwards compatibility numbers are stored as strings. */
 	sprintf(buf, "%ld", (long)our_tv->vval.v_number);
 	result = Py_BuildValue("s", buf);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
     }
 # ifdef FEAT_FLOAT
     else if (our_tv->v_type == VAR_FLOAT)
@@ -1170,7 +1183,6 @@
 
 	sprintf(buf, "%f", our_tv->vval.v_float);
 	result = Py_BuildValue("s", buf);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
     }
 # endif
     else if (our_tv->v_type == VAR_LIST)
@@ -1179,10 +1191,11 @@
 	listitem_T	*curr;
 
 	result = PyList_New(0);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
 
 	if (list != NULL)
 	{
+	    PyDict_SetItemString(lookupDict, ptrBuf, result);
+
 	    for (curr = list->lv_first; curr != NULL; curr = curr->li_next)
 	    {
 		newObj = VimToPython(&curr->li_tv, depth + 1, lookupDict);
@@ -1194,7 +1207,6 @@
     else if (our_tv->v_type == VAR_DICT)
     {
 	result = PyDict_New();
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
 
 	if (our_tv->vval.v_dict != NULL)
 	{
@@ -1203,6 +1215,8 @@
 	    hashitem_T	*hi;
 	    dictitem_T	*di;
 
+	    PyDict_SetItemString(lookupDict, ptrBuf, result);
+
 	    for (hi = ht->ht_array; todo > 0; ++hi)
 	    {
 		if (!HASHITEM_EMPTY(hi))
@@ -1227,9 +1241,8 @@
 }
 #endif
 
-/*ARGSUSED*/
     static PyObject *
-VimEval(PyObject *self, PyObject *args)
+VimEval(PyObject *self UNUSED, PyObject *args)
 {
 #ifdef FEAT_EVAL
     char	*expr;
@@ -1879,9 +1892,8 @@
 /* Buffer list object - Implementation
  */
 
-/*ARGSUSED*/
     static PyInt
-BufListLength(PyObject *self)
+BufListLength(PyObject *self UNUSED)
 {
     buf_T	*b = firstbuf;
     PyInt	n = 0;
@@ -1895,9 +1907,8 @@
     return n;
 }
 
-/*ARGSUSED*/
     static PyObject *
-BufListItem(PyObject *self, PyInt n)
+BufListItem(PyObject *self UNUSED, PyInt n)
 {
     buf_T *b;
 
@@ -2195,9 +2206,8 @@
 
 /* Window list object - Implementation
  */
-/*ARGSUSED*/
     static PyInt
-WinListLength(PyObject *self)
+WinListLength(PyObject *self UNUSED)
 {
     win_T	*w = firstwin;
     PyInt	n = 0;
@@ -2211,9 +2221,8 @@
     return n;
 }
 
-/*ARGSUSED*/
     static PyObject *
-WinListItem(PyObject *self, PyInt n)
+WinListItem(PyObject *self UNUSED, PyInt n)
 {
     win_T *w;
 
@@ -2259,9 +2268,8 @@
 
 /* Current items object - Implementation
  */
-/*ARGSUSED*/
     static PyObject *
-CurrentGetattr(PyObject *self, char *name)
+CurrentGetattr(PyObject *self UNUSED, char *name)
 {
     if (strcmp(name, "buffer") == 0)
 	return (PyObject *)BufferNew(curbuf);
@@ -2280,9 +2288,8 @@
     }
 }
 
-/*ARGSUSED*/
     static int
-CurrentSetattr(PyObject *self, char *name, PyObject *value)
+CurrentSetattr(PyObject *self UNUSED, char *name, PyObject *value)
 {
     if (strcmp(name, "line") == 0)
     {
@@ -2345,7 +2352,8 @@
 {
     PyObject *mod;
     PyObject *dict;
-    static char *(argv[2]) = {"", NULL};
+    /* The special value is removed from sys.path in Python_Init(). */
+    static char *(argv[2]) = {"/must>not&exist/foo", NULL};
 
     /* Fixups... */
     BufferType.ob_type = &PyType_Type;
diff -Naur vim72.orig/src/if_ruby.c vim72/src/if_ruby.c
--- vim72.orig/src/if_ruby.c	2007-09-10 01:40:38.000000000 -0700
+++ vim72/src/if_ruby.c	2009-06-05 14:25:34.000000000 -0700
@@ -492,7 +492,7 @@
     }
 }
 
-static VALUE vim_message(VALUE self, VALUE str)
+static VALUE vim_message(VALUE self UNUSED, VALUE str)
 {
     char *buff, *p;
 
@@ -505,20 +505,20 @@
     return Qnil;
 }
 
-static VALUE vim_set_option(VALUE self, VALUE str)
+static VALUE vim_set_option(VALUE self UNUSED, VALUE str)
 {
     do_set((char_u *)STR2CSTR(str), 0);
     update_screen(NOT_VALID);
     return Qnil;
 }
 
-static VALUE vim_command(VALUE self, VALUE str)
+static VALUE vim_command(VALUE self UNUSED, VALUE str)
 {
     do_cmdline_cmd((char_u *)STR2CSTR(str));
     return Qnil;
 }
 
-static VALUE vim_evaluate(VALUE self, VALUE str)
+static VALUE vim_evaluate(VALUE self UNUSED, VALUE str)
 {
 #ifdef FEAT_EVAL
     char_u *value = eval_to_string((char_u *)STR2CSTR(str), NULL, TRUE);
@@ -580,7 +580,7 @@
     return INT2NUM(n);
 }
 
-static VALUE buffer_s_aref(VALUE self, VALUE num)
+static VALUE buffer_s_aref(VALUE self UNUSED, VALUE num)
 {
     buf_T *b;
     int n = NUM2INT(num);
@@ -629,7 +629,9 @@
 	return line ? rb_str_new2(line) : Qnil;
     }
     rb_raise(rb_eIndexError, "index %d out of buffer", n);
+#ifndef __GNUC__
     return Qnil; /* For stop warning */
+#endif
 }
 
 static VALUE buffer_aref(VALUE self, VALUE num)
@@ -668,7 +670,9 @@
     else
     {
 	rb_raise(rb_eIndexError, "index %d out of buffer", n);
+#ifndef __GNUC__
 	return Qnil; /* For stop warning */
+#endif
     }
     return str;
 }
@@ -789,7 +793,7 @@
     return get_buffer_line(curbuf, curwin->w_cursor.lnum);
 }
 
-static VALUE set_current_line(VALUE self, VALUE str)
+static VALUE set_current_line(VALUE self UNUSED, VALUE str)
 {
     return set_buffer_line(curbuf, curwin->w_cursor.lnum, str);
 }
@@ -815,7 +819,7 @@
 #endif
 }
 
-static VALUE window_s_aref(VALUE self, VALUE num)
+static VALUE window_s_aref(VALUE self UNUSED, VALUE num)
 {
     win_T *w;
     int n = NUM2INT(num);
@@ -897,7 +901,7 @@
     return Qnil;
 }
 
-static VALUE f_p(int argc, VALUE *argv, VALUE self)
+static VALUE f_p(int argc, VALUE *argv, VALUE self UNUSED)
 {
     int i;
     VALUE str = rb_str_new("", 0);
diff -Naur vim72.orig/src/if_tcl.c vim72/src/if_tcl.c
--- vim72.orig/src/if_tcl.c	2007-05-07 12:50:14.000000000 -0700
+++ vim72/src/if_tcl.c	2009-06-05 14:25:41.000000000 -0700
@@ -161,7 +161,7 @@
 # endif
 
 /*
- * Declare HANDLE for perl.dll and function pointers.
+ * Declare HANDLE for tcl.dll and function pointers.
  */
 static HANDLE hTclLib = NULL;
 Tcl_Interp* (*dll_Tcl_CreateInterp)();
@@ -182,7 +182,7 @@
  * Make all runtime-links of tcl.
  *
  * 1. Get module handle using LoadLibraryEx.
- * 2. Get pointer to perl function by GetProcAddress.
+ * 2. Get pointer to tcl function by GetProcAddress.
  * 3. Repeat 2, until get all functions will be used.
  *
  * Parameter 'libname' provides name of DLL.
@@ -290,10 +290,9 @@
  */
 #define TCL_EXIT	5
 
-/* ARGSUSED */
     static int
 exitcmd(dummy, interp, objc, objv)
-    ClientData dummy;
+    ClientData dummy UNUSED;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
@@ -315,10 +314,9 @@
     return TCL_ERROR;
 }
 
-/* ARGSUSED */
     static int
 catchcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -356,10 +354,9 @@
 /*
  *  "::vim::beep" - what Vi[m] does best :-)
  */
-/* ARGSUSED */
     static int
 beepcmd(dummy, interp, objc, objv)
-    ClientData dummy;
+    ClientData dummy UNUSED;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
@@ -378,10 +375,9 @@
  *  "::vim::buffer {N}" - create buffer command for buffer N.
  *  "::vim::buffer new" - create a new buffer (not implemented)
  */
-/* ARGSUSED */
     static int
 buffercmd(dummy, interp, objc, objv)
-    ClientData dummy;
+    ClientData dummy UNUSED;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
@@ -475,10 +471,9 @@
 /*
  * "::vim::window list" - create list of window commands.
  */
-/* ARGSUSED */
     static int
 windowcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -1130,10 +1125,9 @@
 }
 
 
-/* ARGSUSED */
     static int
 commandcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -1145,10 +1139,9 @@
     return err;
 }
 
-/* ARGSUSED */
     static int
 optioncmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -1160,10 +1153,9 @@
     return err;
 }
 
-/* ARGSUSED */
     static int
 exprcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -1584,11 +1576,10 @@
     I/O Channel
 ********************************************/
 
-/* ARGSUSED */
     static int
 channel_close(instance, interp)
     ClientData	instance;
-    Tcl_Interp	*interp;
+    Tcl_Interp	*interp UNUSED;
 {
     int		err = 0;
 
@@ -1602,12 +1593,11 @@
     return err;
 }
 
-/* ARGSUSED */
     static int
 channel_input(instance, buf, bufsiz, errptr)
-    ClientData	instance;
-    char	*buf;
-    int		bufsiz;
+    ClientData	instance UNUSED;
+    char	*buf UNUSED;
+    int		bufsiz UNUSED;
     int		*errptr;
 {
 
@@ -1659,21 +1649,19 @@
     return result;
 }
 
-/* ARGSUSED */
     static void
 channel_watch(instance, mask)
-    ClientData	instance;
-    int		mask;
+    ClientData	instance UNUSED;
+    int		mask UNUSED;
 {
     Tcl_SetErrno(EINVAL);
 }
 
-/* ARGSUSED */
     static int
 channel_gethandle(instance, direction, handleptr)
-    ClientData	instance;
-    int		direction;
-    ClientData	*handleptr;
+    ClientData	instance UNUSED;
+    int		direction UNUSED;
+    ClientData	*handleptr UNUSED;
 {
     Tcl_SetErrno(EINVAL);
     return EINVAL;
@@ -1682,16 +1670,31 @@
 
 static Tcl_ChannelType channel_type =
 {
-    "vimmessage",
-    NULL,   /* blockmode */
-    channel_close,
-    channel_input,
-    channel_output,
-    NULL,   /* seek */
-    NULL,   /* set option */
-    NULL,   /* get option */
-    channel_watch,
-    channel_gethandle
+    "vimmessage",	/* typeName */
+    NULL,		/* version */
+    channel_close,	/* closeProc */
+    channel_input,	/* inputProc */
+    channel_output,	/* outputProc */
+    NULL,		/* seekProc */
+    NULL,		/* setOptionProc */
+    NULL,		/* getOptionProc */
+    channel_watch,	/* watchProc */
+    channel_gethandle,	/* getHandleProc */
+    NULL,		/* close2Proc */
+    NULL,		/* blockModeProc */
+#ifdef TCL_CHANNEL_VERSION_2
+    NULL,		/* flushProc */
+    NULL,		/* handlerProc */
+#endif
+#ifdef TCL_CHANNEL_VERSION_3
+    NULL,		/* wideSeekProc */
+#endif
+#ifdef TCL_CHANNEL_VERSION_4
+    NULL,		/* threadActionProc */
+#endif
+#ifdef TCL_CHANNEL_VERSION_5
+    NULL		/* truncateProc */
+#endif
 };
 
 /**********************************
diff -Naur vim72.orig/src/if_xcmdsrv.c vim72/src/if_xcmdsrv.c
--- vim72.orig/src/if_xcmdsrv.c	2008-07-18 06:05:03.000000000 -0700
+++ vim72/src/if_xcmdsrv.c	2009-06-05 14:25:02.000000000 -0700
@@ -682,7 +682,7 @@
      * Scan all of the names out of the property.
      */
     ga_init2(&ga, 1, 100);
-    for (p = regProp; (p - regProp) < numItems; p++)
+    for (p = regProp; (long_u)(p - regProp) < numItems; p++)
     {
 	entry = p;
 	while (*p != 0 && !isspace(*p))
@@ -736,7 +736,7 @@
 		+ serverReply.ga_len;
 	    e.id = w;
 	    ga_init2(&e.strings, 1, 100);
-	    memcpy(p, &e, sizeof(e));
+	    mch_memmove(p, &e, sizeof(e));
 	    serverReply.ga_len++;
 	}
     }
@@ -969,7 +969,7 @@
      */
     returnValue = (int_u)None;
     entry = NULL;	/* Not needed, but eliminates compiler warning. */
-    for (p = regProp; (p - regProp) < numItems; )
+    for (p = regProp; (long_u)(p - regProp) < numItems; )
     {
 	entry = p;
 	while (*p != 0 && !isspace(*p))
@@ -986,7 +986,7 @@
 
     if (loose != NULL && returnValue == (int_u)None && !IsSerialName(name))
     {
-	for (p = regProp; (p - regProp) < numItems; )
+	for (p = regProp; (long_u)(p - regProp) < numItems; )
 	{
 	    entry = p;
 	    while (*p != 0 && !isspace(*p))
@@ -1018,7 +1018,7 @@
 	p++;
 	count = numItems - (p - regProp);
 	if (count > 0)
-	    memcpy(entry, p, count);
+	    mch_memmove(entry, p, count);
 	XChangeProperty(dpy, RootWindow(dpy, 0), registryProperty, XA_STRING,
 			8, PropModeReplace, regProp,
 			(int)(numItems - (p - entry)));
@@ -1056,7 +1056,7 @@
 	return;
 
     /* Scan the property for the window id.  */
-    for (p = regProp; (p - regProp) < numItems; )
+    for (p = regProp; (long_u)(p - regProp) < numItems; )
     {
 	if (*p != 0)
 	{
@@ -1072,7 +1072,7 @@
 		p++;
 		lastHalf = numItems - (p - regProp);
 		if (lastHalf > 0)
-		    memcpy(entry, p, lastHalf);
+		    mch_memmove(entry, p, lastHalf);
 		numItems = (entry - regProp) + lastHalf;
 		p = entry;
 		continue;
@@ -1196,7 +1196,7 @@
      * one time;  each iteration through the outer loop handles a
      * single command or result.
      */
-    for (p = propInfo; (p - propInfo) < numItems; )
+    for (p = propInfo; (long_u)(p - propInfo) < numItems; )
     {
 	/*
 	 * Ignore leading NULs; each command or result starts with a
@@ -1230,7 +1230,7 @@
 	    serial = (char_u *)"";
 	    script = NULL;
 	    enc = NULL;
-	    while (p - propInfo < numItems && *p == '-')
+	    while ((long_u)(p - propInfo) < numItems && *p == '-')
 	    {
 		switch (p[1])
 		{
@@ -1333,7 +1333,7 @@
 	    res = (char_u *)"";
 	    code = 0;
 	    enc = NULL;
-	    while ((p-propInfo) < numItems && *p == '-')
+	    while ((long_u)(p - propInfo) < numItems && *p == '-')
 	    {
 		switch (p[1])
 		{
@@ -1401,7 +1401,7 @@
 	    gotWindow = 0;
 	    str = (char_u *)"";
 	    enc = NULL;
-	    while ((p-propInfo) < numItems && *p == '-')
+	    while ((long_u)(p - propInfo) < numItems && *p == '-')
 	    {
 		switch (p[1])
 		{
@@ -1489,11 +1489,10 @@
 /*
  * Another X Error handler, just used to check for errors.
  */
-/* ARGSUSED */
     static int
 x_error_check(dpy, error_event)
-    Display	*dpy;
-    XErrorEvent	*error_event;
+    Display	*dpy UNUSED;
+    XErrorEvent	*error_event UNUSED;
 {
     got_x_error = TRUE;
     return 0;
diff -Naur vim72.orig/src/macros.h vim72/src/macros.h
--- vim72.orig/src/macros.h	2007-08-04 04:44:18.000000000 -0700
+++ vim72/src/macros.h	2009-06-05 14:25:15.000000000 -0700
@@ -127,15 +127,31 @@
 #ifdef FEAT_LANGMAP
 /*
  * Adjust chars in a language according to 'langmap' option.
- * NOTE that there is NO overhead if 'langmap' is not set; but even
- * when set we only have to do 2 ifs and an array lookup.
+ * NOTE that there is no noticeable overhead if 'langmap' is not set.
+ * When set the overhead for characters < 256 is small.
  * Don't apply 'langmap' if the character comes from the Stuff buffer.
  * The do-while is just to ignore a ';' after the macro.
  */
-# define LANGMAP_ADJUST(c, condition) do { \
-	if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0 && (c) < 256) \
-	    c = langmap_mapchar[c]; \
+# ifdef FEAT_MBYTE
+#  define LANGMAP_ADJUST(c, condition) \
+    do { \
+        if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0) \
+	{ \
+	    if ((c) < 256) \
+		c = langmap_mapchar[c]; \
+	    else \
+		c = langmap_adjust_mb(c); \
+	} \
     } while (0)
+# else
+#  define LANGMAP_ADJUST(c, condition) \
+    do { \
+        if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0 && (c) < 256) \
+            c = langmap_mapchar[c]; \
+    } while (0)
+# endif
+#else
+# define LANGMAP_ADJUST(c, condition) /* nop */
 #endif
 
 /*
@@ -268,7 +284,7 @@
 # define mb_cptr2len(p)	    (enc_utf8 ? utf_ptr2len(p) : (*mb_ptr2len)(p))
 
 # define MB_COPY_CHAR(f, t) if (has_mbyte) mb_copy_char(&f, &t); else *t++ = *f++
-# define MB_CHARLEN(p)	    (has_mbyte ? mb_charlen(p) : STRLEN(p))
+# define MB_CHARLEN(p)	    (has_mbyte ? mb_charlen(p) : (int)STRLEN(p))
 # define PTR2CHAR(p)	    (has_mbyte ? mb_ptr2char(p) : (int)*(p))
 #else
 # define mb_ptr_adv(p)		++p
diff -Naur vim72.orig/src/main.c vim72/src/main.c
--- vim72.orig/src/main.c	2008-07-24 01:40:56.000000000 -0700
+++ vim72/src/main.c	2009-06-05 14:25:15.000000000 -0700
@@ -645,11 +645,12 @@
 
 #ifdef FEAT_VIMINFO
     /*
-     * Read in registers, history etc, but not marks, from the viminfo file
+     * Read in registers, history etc, but not marks, from the viminfo file.
+     * This is where v:oldfiles gets filled.
      */
     if (*p_viminfo != NUL)
     {
-	read_viminfo(NULL, TRUE, FALSE, FALSE);
+	read_viminfo(NULL, VIF_WANT_INFO | VIF_GET_OLDFILES);
 	TIME_MSG("reading viminfo");
     }
 #endif
@@ -1457,7 +1458,8 @@
 	++initstr;
     }
 
-    if (TOLOWER_ASC(initstr[0]) == 'g' || initstr[0] == 'k')
+    /* "gvim" starts the GUI.  Also accept "Gvim" for MS-Windows. */
+    if (TOLOWER_ASC(initstr[0]) == 'g')
     {
 	main_start_gui();
 #ifdef FEAT_GUI
@@ -1503,12 +1505,12 @@
  *
  * Also find the --server... arguments and --socketid and --windowid
  */
-/*ARGSUSED*/
     static void
 early_arg_scan(parmp)
-    mparm_T	*parmp;
+    mparm_T	*parmp UNUSED;
 {
-#if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER)
+#if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER) \
+	|| !defined(FEAT_NETBEANS_INTG)
     int		argc = parmp->argc;
     char	**argv = parmp->argv;
     int		i;
@@ -1580,6 +1582,14 @@
 	else if (STRICMP(argv[i], "--echo-wid") == 0)
 	    echo_wid_arg = TRUE;
 # endif
+# ifndef FEAT_NETBEANS_INTG
+	else if (strncmp(argv[i], "-nb", (size_t)3) == 0)
+        {
+            mch_errmsg(_("'-nb' cannot be used: not enabled at compile time\n"));
+            mch_exit(2);
+        }
+# endif
+
     }
 #endif
 }
@@ -2361,7 +2371,7 @@
      * Is there any other system that cannot do this?
      */
     close(0);
-    dup(2);
+    ignored = dup(2);
 #endif
 }
 
@@ -2369,10 +2379,9 @@
  * Create the requested number of windows and edit buffers in them.
  * Also does recovery if "recoverymode" set.
  */
-/*ARGSUSED*/
     static void
 create_windows(parmp)
-    mparm_T	*parmp;
+    mparm_T	*parmp UNUSED;
 {
 #ifdef FEAT_WINDOWS
     int		dorewind;
@@ -3840,10 +3849,9 @@
  * return an allocated string.  Otherwise return "data".
  * "*tofree" is set to the result when it needs to be freed later.
  */
-/*ARGSUSED*/
     char_u *
 serverConvert(client_enc, data, tofree)
-    char_u *client_enc;
+    char_u *client_enc UNUSED;
     char_u *data;
     char_u **tofree;
 {
diff -Naur vim72.orig/src/Makefile vim72/src/Makefile
--- vim72.orig/src/Makefile	2008-08-09 07:50:04.000000000 -0700
+++ vim72/src/Makefile	2009-06-05 14:25:34.000000000 -0700
@@ -105,8 +105,8 @@
 # 4. "make test"  {{{1
 #	This is optional.  This will run Vim scripts on a number of test
 #	files, and compare the produced output with the expected output.
-#	If all is well, you will get the "ALL DONE" message in the end.  See
-#	below (search for "/^test").
+#	If all is well, you will get the "ALL DONE" message in the end.  If a
+#	test fails you get "TEST FAILURE".  See below (search for "/^test").
 #
 # 5. "make install"  {{{1
 #	If the new Vim seems to be working OK you can install it and the
@@ -533,6 +533,11 @@
 #CFLAGS = -g -DDEBUG -Wall -Wshadow -Wmissing-prototypes
 #CFLAGS = -g -O2 '-DSTARTUPTIME="vimstartup"' -fno-strength-reduce -Wall -Wmissing-prototypes
 
+# Use this with GCC to check for mistakes, unused arguments, etc.
+#CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code
+#PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
+#MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code
+
 # EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond
 # allocated memory (and makes every malloc()/free() very slow).
 # Electric Fence is free (search ftp sites).
@@ -551,7 +556,13 @@
 # }}}
 
 # LINT - for running lint
+#  For standard Unix lint
+LINT = lint
 LINT_OPTIONS = -beprxzF
+#  For splint
+#  It doesn't work well, crashes on include files and non-ascii characters.
+#LINT = splint
+#LINT_OPTIONS = +unixlib -weak -macrovarprefixexclude -showfunc -linelen 9999
 
 # PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.
 # Might not work with GUI or Perl.
@@ -1259,16 +1270,16 @@
 #     This is for cproto 3 patchlevel 8 or below
 #     __inline, __attribute__ and __extension__ are not recognized by cproto
 #     G_IMPLEMENT_INLINES is to avoid functions defined in glib/gutils.h.
-NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \
-	  -D"__attribute__\\(x\\)=" -D"__asm__\\(x\\)=" \
-	  -D__extension__= -D__restrict="" \
-	  -D__gnuc_va_list=char -D__builtin_va_list=char
+#NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \
+#	  -D"__attribute__\\(x\\)=" -D"__asm__\\(x\\)=" \
+#	  -D__extension__= -D__restrict="" \
+#	  -D__gnuc_va_list=char -D__builtin_va_list=char
 
 #
-#     This is for cproto 3 patchlevel 9 or above (currently 4.6)
+#     This is for cproto 3 patchlevel 9 or above (currently 4.6, 4.7g)
 #     __inline and __attribute__ are now recognized by cproto
 #     -D"foo()=" is not supported by all compilers so do not use it
-# NO_ATTR=
+NO_ATTR=
 #
 #     maybe the "/usr/bin/cc -E" has to be adjusted for some systems
 # This is for cproto 3.5 patchlevel 3:
@@ -1432,6 +1443,7 @@
 	$(SNIFF_SRC) $(WORKSHOP_SRC) $(WSDEBUG_SRC) $(NETBEANS_SRC)
 #LINT_SRC = $(SRC)
 #LINT_SRC = $(ALL_SRC)
+#LINT_SRC = $(BASIC_SRC)
 
 OBJ = \
 	objects/buffer.o \
@@ -1737,7 +1749,8 @@
 # messages.  Don't worry about that.
 # If there is a real error, there will be a difference between "test.out" and
 # a "test99.ok" file.
-# If everything is alright, the final message will be "ALL DONE".
+# If everything is alright, the final message will be "ALL DONE".  If not you
+# get "TEST FAILURE".
 #
 test check:
 	$(MAKE) -f Makefile $(VIMTARGET)
@@ -2272,12 +2285,12 @@
 
 # Run lint.  Clean up the *.ln files that are sometimes left behind.
 lint:
-	lint $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)
+	$(LINT) $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)
 	-rm -f *.ln
 
 # Check dosinst.c with lint.
 lintinstall:
-	lint $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c
+	$(LINT) $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c
 	-rm -f dosinst.ln
 
 ###########################################################################
@@ -2421,7 +2434,7 @@
 	$(CCC) -o $@ if_xcmdsrv.c
 
 objects/if_mzsch.o: if_mzsch.c
-	$(CCC) -o $@ if_mzsch.c
+	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
 
 objects/if_perl.o: auto/if_perl.c
 	$(CCC) -o $@ auto/if_perl.c
@@ -2430,7 +2443,7 @@
 	$(CCC) -o $@ if_perlsfio.c
 
 objects/if_python.o: if_python.c
-	$(CCC) -o $@ if_python.c
+	$(CCC) -o $@ $(PYTHON_CFLAGS_EXTRA) if_python.c
 
 objects/if_ruby.o: if_ruby.c
 	$(CCC) -o $@ if_ruby.c
diff -Naur vim72.orig/src/mark.c vim72/src/mark.c
--- vim72.orig/src/mark.c	2008-08-08 15:06:49.000000000 -0700
+++ vim72/src/mark.c	2009-06-05 14:25:02.000000000 -0700
@@ -884,10 +884,9 @@
 /*
  * print the jumplist
  */
-/*ARGSUSED*/
     void
 ex_jumps(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		i;
     char_u	*name;
@@ -933,10 +932,9 @@
 /*
  * print the changelist
  */
-/*ARGSUSED*/
     void
 ex_changes(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		i;
     char_u	*name;
@@ -1023,6 +1021,9 @@
     int		fnum = curbuf->b_fnum;
     linenr_T	*lp;
     win_T	*win;
+#ifdef FEAT_WINDOWS
+    tabpage_T	*tab;
+#endif
 
     if (line2 < line1 && amount_after == 0L)	    /* nothing to do */
 	return;
@@ -1064,7 +1065,7 @@
 	/* quickfix marks */
 	qf_mark_adjust(NULL, line1, line2, amount, amount_after);
 	/* location lists */
-	FOR_ALL_WINDOWS(win)
+	FOR_ALL_TAB_WINDOWS(tab, win)
 	    qf_mark_adjust(win, line1, line2, amount, amount_after);
 #endif
 
@@ -1086,7 +1087,7 @@
     /*
      * Adjust items in all windows related to the current buffer.
      */
-    FOR_ALL_WINDOWS(win)
+    FOR_ALL_TAB_WINDOWS(tab, win)
     {
 #ifdef FEAT_JUMPLIST
 	if (!cmdmod.lockmarks)
@@ -1627,15 +1628,17 @@
 
 /*
  * Handle marks in the viminfo file:
- * fp_out == NULL   read marks for current buffer only
- * fp_out != NULL   copy marks for buffers not in buffer list
+ * fp_out != NULL: copy marks for buffers not in buffer list
+ * fp_out == NULL && (flags & VIF_WANT_MARKS): read marks for curbuf only
+ * fp_out == NULL && (flags & VIF_GET_OLDFILES | VIF_FORCEIT): fill v:oldfiles
  */
     void
-copy_viminfo_marks(virp, fp_out, count, eof)
+copy_viminfo_marks(virp, fp_out, count, eof, flags)
     vir_T	*virp;
     FILE	*fp_out;
     int		count;
     int		eof;
+    int		flags;
 {
     char_u	*line = virp->vir_line;
     buf_T	*buf;
@@ -1647,10 +1650,23 @@
     char_u	*p;
     char_u	*name_buf;
     pos_T	pos;
+#ifdef FEAT_EVAL
+    list_T	*list = NULL;
+#endif
 
     if ((name_buf = alloc(LSIZE)) == NULL)
 	return;
     *name_buf = NUL;
+
+#ifdef FEAT_EVAL
+    if (fp_out == NULL && (flags & (VIF_GET_OLDFILES | VIF_FORCEIT)))
+    {
+	list = list_alloc();
+	if (list != NULL)
+	    set_vim_var_list(VV_OLDFILES, list);
+    }
+#endif
+
     num_marked_files = get_viminfo_parameter('\'');
     while (!eof && (count < num_marked_files || fp_out == NULL))
     {
@@ -1681,6 +1697,11 @@
 	    p++;
 	*p = NUL;
 
+#ifdef FEAT_EVAL
+	if (list != NULL)
+	    list_append_string(list, str, -1);
+#endif
+
 	/*
 	 * If fp_out == NULL, load marks for current buffer.
 	 * If fp_out != NULL, copy marks for buffers not in buflist.
@@ -1688,7 +1709,7 @@
 	load_marks = copy_marks_out = FALSE;
 	if (fp_out == NULL)
 	{
-	    if (curbuf->b_ffname != NULL)
+	    if ((flags & VIF_WANT_MARKS) && curbuf->b_ffname != NULL)
 	    {
 		if (*name_buf == NUL)	    /* only need to do this once */
 		    home_replace(NULL, curbuf->b_ffname, name_buf, LSIZE, TRUE);
diff -Naur vim72.orig/src/mbyte.c vim72/src/mbyte.c
--- vim72.orig/src/mbyte.c	2008-07-14 05:38:05.000000000 -0700
+++ vim72/src/mbyte.c	2009-06-05 14:25:15.000000000 -0700
@@ -717,7 +717,7 @@
 		     * where mblen() returns 0 for invalid character.
 		     * Therefore, following condition includes 0.
 		     */
-		    (void)mblen(NULL, 0);	/* First reset the state. */
+		    ignored = mblen(NULL, 0);	/* First reset the state. */
 		    if (mblen(buf, (size_t)1) <= 0)
 			n = 2;
 		    else
@@ -1015,10 +1015,9 @@
  * Return length in bytes of character "c".
  * Returns 1 for a single-byte character.
  */
-/* ARGSUSED */
     int
 latin_char2len(c)
-    int		c;
+    int		c UNUSED;
 {
     return 1;
 }
@@ -1248,10 +1247,9 @@
  * Return the number of display cells character at "*p" occupies.
  * This doesn't take care of unprintable characters, use ptr2cells() for that.
  */
-/*ARGSUSED*/
     int
 latin_ptr2cells(p)
-    char_u	*p;
+    char_u	*p UNUSED;
 {
     return 1;
 }
@@ -1293,10 +1291,9 @@
  * Return the number of display cells character "c" occupies.
  * Only takes care of multi-byte chars, not "^C" and such.
  */
-/*ARGSUSED*/
     int
 latin_char2cells(c)
-    int		c;
+    int		c UNUSED;
 {
     return 1;
 }
@@ -1318,11 +1315,10 @@
  * Return number of display cells for char at ScreenLines[off].
  * We make sure that the offset used is less than "max_off".
  */
-/*ARGSUSED*/
     int
 latin_off2cells(off, max_off)
-    unsigned	off;
-    unsigned	max_off;
+    unsigned	off UNUSED;
+    unsigned	max_off UNUSED;
 {
     return 1;
 }
@@ -2419,11 +2415,10 @@
  * Return offset from "p" to the first byte of the character it points into.
  * Returns 0 when already at the first byte of a character.
  */
-/*ARGSUSED*/
     int
 latin_head_off(base, p)
-    char_u	*base;
-    char_u	*p;
+    char_u	*base UNUSED;
+    char_u	*p UNUSED;
 {
     return 0;
 }
@@ -2540,7 +2535,6 @@
     return (int)(p - q);
 }
 
-#if defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Copy a character from "*fp" to "*tp" and advance the pointers.
  */
@@ -2555,7 +2549,6 @@
     *tp += l;
     *fp += l;
 }
-#endif
 
 /*
  * Return the offset from "p" to the first byte of a character.  When "p" is
@@ -3133,7 +3126,7 @@
 	else
 	    s = p + 1;
     }
-    for (i = 0; s[i] != NUL && s + i < buf + sizeof(buf) - 1; ++i)
+    for (i = 0; s[i] != NUL && i < (int)sizeof(buf) - 1; ++i)
     {
 	if (s[i] == '_' || s[i] == '-')
 	    buf[i] = '-';
@@ -3584,9 +3577,10 @@
  * Callback invoked when the user finished preediting.
  * Put the final string into the input buffer.
  */
-/*ARGSUSED0*/
     static void
-im_commit_cb(GtkIMContext *context, const gchar *str, gpointer data)
+im_commit_cb(GtkIMContext *context UNUSED,
+	     const gchar *str,
+	     gpointer data UNUSED)
 {
     int	slen = (int)STRLEN(str);
     int	add_to_input = TRUE;
@@ -3672,9 +3666,8 @@
 /*
  * Callback invoked after start to the preedit.
  */
-/*ARGSUSED*/
     static void
-im_preedit_start_cb(GtkIMContext *context, gpointer data)
+im_preedit_start_cb(GtkIMContext *context UNUSED, gpointer data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("im_preedit_start_cb()\n");
@@ -3689,9 +3682,8 @@
 /*
  * Callback invoked after end to the preedit.
  */
-/*ARGSUSED*/
     static void
-im_preedit_end_cb(GtkIMContext *context, gpointer data)
+im_preedit_end_cb(GtkIMContext *context UNUSED, gpointer data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("im_preedit_end_cb()\n");
@@ -3750,9 +3742,8 @@
  * remaining input from within the "retrieve_surrounding" signal handler, this
  * might not be necessary.  Gotta ask on vim-dev for opinions.
  */
-/*ARGSUSED1*/
     static void
-im_preedit_changed_cb(GtkIMContext *context, gpointer data)
+im_preedit_changed_cb(GtkIMContext *context, gpointer data UNUSED)
 {
     char    *preedit_string = NULL;
     int	    cursor_index    = 0;
@@ -4618,11 +4609,10 @@
     }
 }
 
-/*ARGSUSED*/
     void
 im_set_position(row, col)
-    int		row;
-    int		col;
+    int		row UNUSED;
+    int		col UNUSED;
 {
     xim_set_preedit();
 }
@@ -4929,12 +4919,11 @@
 static void xim_instantiate_cb __ARGS((Display *display, XPointer client_data, XPointer	call_data));
 static void xim_destroy_cb __ARGS((XIM im, XPointer client_data, XPointer call_data));
 
-/*ARGSUSED*/
     static void
 xim_instantiate_cb(display, client_data, call_data)
     Display	*display;
-    XPointer	client_data;
-    XPointer	call_data;
+    XPointer	client_data UNUSED;
+    XPointer	call_data UNUSED;
 {
     Window	x11_window;
     Display	*x11_display;
@@ -4954,12 +4943,11 @@
 					 xim_instantiate_cb, NULL);
 }
 
-/*ARGSUSED*/
     static void
 xim_destroy_cb(im, client_data, call_data)
-    XIM		im;
-    XPointer	client_data;
-    XPointer	call_data;
+    XIM		im UNUSED;
+    XPointer	client_data UNUSED;
+    XPointer	call_data UNUSED;
 {
     Window	x11_window;
     Display	*x11_display;
@@ -5278,9 +5266,10 @@
     }
 }
 
-/*ARGSUSED*/
     static void
-preedit_start_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_start_cbproc(XIC thexic UNUSED,
+	             XPointer client_data UNUSED,
+		     XPointer call_data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("xim_decide_input_style()\n");
@@ -5312,9 +5301,10 @@
 static GSList *key_press_event_queue = NULL;
 static gboolean processing_queued_event = FALSE;
 
-/*ARGSUSED*/
     static void
-preedit_draw_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_draw_cbproc(XIC thexic UNUSED,
+		    XPointer client_data UNUSED,
+		    XPointer call_data)
 {
     XIMPreeditDrawCallbackStruct *draw_data;
     XIMText	*text;
@@ -5386,7 +5376,7 @@
 			draw_feedback = (char *)alloc(draw_data->chg_first
 							      + text->length);
 		    else
-			draw_feedback = realloc(draw_feedback,
+			draw_feedback = vim_realloc(draw_feedback,
 					 draw_data->chg_first + text->length);
 		    if (draw_feedback != NULL)
 		    {
@@ -5453,18 +5443,20 @@
     return -1;
 }
 
-/*ARGSUSED*/
     static void
-preedit_caret_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_caret_cbproc(XIC thexic UNUSED,
+		     XPointer client_data UNUSED,
+		     XPointer call_data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("preedit_caret_cbproc()\n");
 #endif
 }
 
-/*ARGSUSED*/
     static void
-preedit_done_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_done_cbproc(XIC thexic UNUSED,
+		    XPointer client_data UNUSED,
+		    XPointer call_data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("preedit_done_cbproc()\n");
@@ -5503,9 +5495,8 @@
     }
 }
 
-/*ARGSUSED*/
     int
-xim_queue_key_press_event(GdkEventKey *event, int down)
+xim_queue_key_press_event(GdkEventKey *event, int down UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("xim_queue_key_press_event()\n");
@@ -5521,9 +5512,8 @@
     return TRUE;
 }
 
-/*ARGSUSED*/
     static void
-preedit_callback_setup(GdkIC *ic)
+preedit_callback_setup(GdkIC *ic UNUSED)
 {
     XIC xxic;
     XVaNestedList preedit_attr;
@@ -5548,9 +5538,8 @@
     XFree(preedit_attr);
 }
 
-/*ARGSUSED*/
     static void
-reset_state_setup(GdkIC *ic)
+reset_state_setup(GdkIC *ic UNUSED)
 {
 #ifdef USE_X11R6_XIM
     /* don't change the input context when we call reset */
diff -Naur vim72.orig/src/memline.c vim72/src/memline.c
--- vim72.orig/src/memline.c	2008-07-13 09:19:22.000000000 -0700
+++ vim72/src/memline.c	2009-06-05 14:23:47.000000000 -0700
@@ -1554,10 +1554,15 @@
 	    for (i = 0; i < num_files; ++i)
 		if (fullpathcmp(p, files[i], TRUE) & FPC_SAME)
 		{
+		    /* Remove the name from files[i].  Move further entries
+		     * down.  When the array becomes empty free it here, since
+		     * FreeWild() won't be called below. */
 		    vim_free(files[i]);
-		    --num_files;
-		    for ( ; i < num_files; ++i)
-			files[i] = files[i + 1];
+		    if (--num_files == 0)
+			vim_free(files);
+		    else
+			for ( ; i < num_files; ++i)
+			    files[i] = files[i + 1];
 		}
 	}
 	if (nr > 0)
@@ -3522,7 +3527,7 @@
 	    if (errno == EINVAL || errno == ENOENT)
 	    {
 		/* Found non-symlink or not existing file, stop here.
-		 * When at the first level use the unmodifed name, skip the
+		 * When at the first level use the unmodified name, skip the
 		 * call to vim_FullName(). */
 		if (depth == 1)
 		    return FAIL;
@@ -3766,8 +3771,10 @@
     set_vim_var_string(VV_SWAPCHOICE, NULL, -1);
 
     /* Trigger SwapExists autocommands with <afile> set to the file being
-     * edited. */
+     * edited.  Disallow changing directory here. */
+    ++allbuf_lock;
     apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);
+    --allbuf_lock;
 
     set_vim_var_string(VV_SWAPNAME, NULL, -1);
 
@@ -3793,6 +3800,7 @@
  *
  * Note: If BASENAMELEN is not correct, you will get error messages for
  *	 not being able to open the swapfile
+ * Note: May trigger SwapExists autocmd, pointers may change!
  */
     static char_u *
 findswapname(buf, dirp, old_fname)
@@ -4560,7 +4568,7 @@
 			buf->b_ml.ml_chunksize + curix,
 			(buf->b_ml.ml_usedchunks - curix) *
 			sizeof(chunksize_T));
-	    /* Compute length of first half of lines in the splitted chunk */
+	    /* Compute length of first half of lines in the split chunk */
 	    size = 0;
 	    linecnt = 0;
 	    while (curline < buf->b_ml.ml_line_count
diff -Naur vim72.orig/src/menu.c vim72/src/menu.c
--- vim72.orig/src/menu.c	2008-06-21 12:53:43.000000000 -0700
+++ vim72/src/menu.c	2009-06-05 14:25:15.000000000 -0700
@@ -231,7 +231,7 @@
 		if (skipdigits(menu_path + 7) == p)
 		{
 		    menuarg.iconidx = atoi((char *)menu_path + 7);
-		    if (menuarg.iconidx >= TOOLBAR_NAME_COUNT)
+		    if (menuarg.iconidx >= (int)TOOLBAR_NAME_COUNT)
 			menuarg.iconidx = -1;
 		    else
 			menuarg.icon_builtin = TRUE;
@@ -239,7 +239,7 @@
 	    }
 	    else
 	    {
-		for (i = 0; i < TOOLBAR_NAME_COUNT; ++i)
+		for (i = 0; i < (int)TOOLBAR_NAME_COUNT; ++i)
 		    if (STRNCMP(toolbar_names[i], menu_path, p - menu_path)
 									 == 0)
 		    {
@@ -1120,6 +1120,7 @@
 	parent = menu;
 	menu = menu->children;
     }
+    vim_free(path_name);
 
     /* Now we have found the matching menu, and we list the mappings */
 						    /* Highlight title */
@@ -1340,10 +1341,9 @@
  * Function given to ExpandGeneric() to obtain the list of (sub)menus (not
  * entries).
  */
-/*ARGSUSED*/
     char_u *
 get_menu_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static vimmenu_T	*menu = NULL;
@@ -1377,10 +1377,9 @@
  * Function given to ExpandGeneric() to obtain the list of menus and menu
  * entries.
  */
-/*ARGSUSED*/
     char_u *
 get_menu_names(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static vimmenu_T	*menu = NULL;
@@ -1738,10 +1737,9 @@
 /*
  * Return TRUE if the menu is the tearoff menu.
  */
-/*ARGSUSED*/
     static int
 menu_is_tearoff(name)
-    char_u *name;
+    char_u *name UNUSED;
 {
 #ifdef FEAT_GUI
     return (STRCMP(name, TEAR_STRING) == 0);
@@ -2342,10 +2340,9 @@
  * This function is also defined without the +multi_lang feature, in which
  * case the commands are ignored.
  */
-/*ARGSUSED*/
     void
 ex_menutranslate(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_MULTI_LANG
     char_u		*arg = eap->arg;
diff -Naur vim72.orig/src/message.c vim72/src/message.c
--- vim72.orig/src/message.c	2008-07-09 11:24:55.000000000 -0700
+++ vim72/src/message.c	2009-06-05 14:25:15.000000000 -0700
@@ -818,10 +818,9 @@
 /*
  * ":messages" command.
  */
-/*ARGSUSED*/
     void
 ex_messages(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     struct msg_hist *p;
     char_u	    *s;
@@ -976,7 +975,7 @@
 		    }
 		}
 		else if (msg_scrolled > Rows - 2
-				     && (c == 'j' || c == K_DOWN || c == 'd'))
+			 && (c == 'j' || c == K_DOWN || c == 'd' || c == 'f'))
 		    c = K_IGNORE;
 	    }
 	} while ((had_got_int && c == Ctrl_C)
@@ -2504,7 +2503,6 @@
 	    break;
 
 	case 'u':		/* Up half a page */
-	case K_PAGEUP:
 	    scroll = -(Rows / 2);
 	    break;
 
@@ -2513,10 +2511,12 @@
 	    break;
 
 	case 'b':		/* one page back */
+	case K_PAGEUP:
 	    scroll = -(Rows - 1);
 	    break;
 
 	case ' ':		/* one extra page */
+	case 'f':
 	case K_PAGEDOWN:
 	case K_LEFTMOUSE:
 	    scroll = Rows - 1;
@@ -2552,7 +2552,6 @@
 	    {
 		/* Jump to the choices of the dialog. */
 		retval = TRUE;
-		lines_left = Rows - 1;
 	    }
 	    else
 #endif
@@ -2560,6 +2559,9 @@
 		got_int = TRUE;
 		quit_more = TRUE;
 	    }
+	    /* When there is some more output (wrapping line) display that
+	     * without another prompt. */
+	    lines_left = Rows - 1;
 	    break;
 
 #ifdef FEAT_CLIPBOARD
@@ -3020,11 +3022,7 @@
     if (*p_vfile != NUL)
 	verbose_write(s, maxlen);
 
-    if (redir_fd != NULL
-#ifdef FEAT_EVAL
-			  || redir_reg || redir_vname
-#endif
-				       )
+    if (redirecting())
     {
 	/* If the string doesn't start with CR or NL, go to msg_col */
 	if (*s != '\n' && *s != '\r')
@@ -3071,6 +3069,16 @@
     }
 }
 
+    int
+redirecting()
+{
+    return redir_fd != NULL
+#ifdef FEAT_EVAL
+			  || redir_reg || redir_vname
+#endif
+				       ;
+}
+
 /*
  * Before giving verbose message.
  * Must always be called paired with verbose_leave()!
@@ -3281,15 +3289,15 @@
  * A '&' in a button name becomes a shortcut, so each '&' should be before a
  * different letter.
  */
-/* ARGSUSED */
     int
 do_dialog(type, title, message, buttons, dfltbutton, textfield)
-    int		type;
-    char_u	*title;
+    int		type UNUSED;
+    char_u	*title UNUSED;
     char_u	*message;
     char_u	*buttons;
     int		dfltbutton;
-    char_u	*textfield;	/* IObuff for inputdialog(), NULL otherwise */
+    char_u	*textfield UNUSED;	/* IObuff for inputdialog(), NULL
+					   otherwise */
 {
     int		oldState;
     int		retval = 0;
@@ -3309,7 +3317,10 @@
     {
 	c = gui_mch_dialog(type, title, message, buttons, dfltbutton,
 								   textfield);
-	msg_end_prompt();
+	/* avoid a hit-enter prompt without clearing the cmdline */
+	need_wait_return = FALSE;
+	emsg_on_display = FALSE;
+	cmdline_row = msg_row;
 
 	/* Flush output to avoid that further messages and redrawing is done
 	 * in the wrong order. */
@@ -4009,7 +4020,7 @@
 	if (*p != '%')
 	{
 	    char    *q = strchr(p + 1, '%');
-	    size_t  n = (q == NULL) ? STRLEN(p) : (q - p);
+	    size_t  n = (q == NULL) ? STRLEN(p) : (size_t)(q - p);
 
 	    /* Copy up to the next '%' or NUL without any changes. */
 	    if (str_l < str_m)
@@ -4256,7 +4267,8 @@
 				  precision <= (size_t)0x7fffffffL ? precision
 						       : (size_t)0x7fffffffL);
 #endif
-			str_arg_l = (q == NULL) ? precision : q - str_arg;
+			str_arg_l = (q == NULL) ? precision
+						      : (size_t)(q - str_arg);
 		    }
 		    break;
 
@@ -4356,7 +4368,8 @@
 					    get_a_arg(arg_idx);
 #else
 # if defined(FEAT_EVAL)
-					    tvs != NULL ? tv_nr(tvs, &arg_idx) :
+					    tvs != NULL ? (unsigned)
+							tv_nr(tvs, &arg_idx) :
 # endif
 						va_arg(ap, unsigned int);
 #endif
@@ -4369,7 +4382,8 @@
 					    get_a_arg(arg_idx);
 #else
 # if defined(FEAT_EVAL)
-					    tvs != NULL ? tv_nr(tvs, &arg_idx) :
+					    tvs != NULL ? (unsigned long)
+							tv_nr(tvs, &arg_idx) :
 # endif
 						va_arg(ap, unsigned long int);
 #endif
@@ -4556,7 +4570,13 @@
 			remove_trailing_zeroes = TRUE;
 		    }
 
-		    if (fmt_spec == 'f' && abs_f > 1.0e307)
+		    if (fmt_spec == 'f' &&
+#ifdef VAX
+			    abs_f > 1.0e38
+#else
+			    abs_f > 1.0e307
+#endif
+			    )
 		    {
 			/* Avoid a buffer overflow */
 			strcpy(tmp, "inf");
@@ -4585,61 +4605,62 @@
 			if (remove_trailing_zeroes)
 			{
 			    int i;
-			    char *p;
+			    char *tp;
 
 			    /* Using %g or %G: remove superfluous zeroes. */
 			    if (fmt_spec == 'f')
-				p = tmp + str_arg_l - 1;
+				tp = tmp + str_arg_l - 1;
 			    else
 			    {
-				p = (char *)vim_strchr((char_u *)tmp,
+				tp = (char *)vim_strchr((char_u *)tmp,
 						 fmt_spec == 'e' ? 'e' : 'E');
-				if (p != NULL)
+				if (tp != NULL)
 				{
 				    /* Remove superfluous '+' and leading
 				     * zeroes from the exponent. */
-				    if (p[1] == '+')
+				    if (tp[1] == '+')
 				    {
 					/* Change "1.0e+07" to "1.0e07" */
-					STRMOVE(p + 1, p + 2);
+					STRMOVE(tp + 1, tp + 2);
 					--str_arg_l;
 				    }
-				    i = (p[1] == '-') ? 2 : 1;
-				    while (p[i] == '0')
+				    i = (tp[1] == '-') ? 2 : 1;
+				    while (tp[i] == '0')
 				    {
 					/* Change "1.0e07" to "1.0e7" */
-					STRMOVE(p + i, p + i + 1);
+					STRMOVE(tp + i, tp + i + 1);
 					--str_arg_l;
 				    }
-				    --p;
+				    --tp;
 				}
 			    }
 
-			    if (p != NULL && !precision_specified)
+			    if (tp != NULL && !precision_specified)
 				/* Remove trailing zeroes, but keep the one
 				 * just after a dot. */
-				while (p > tmp + 2 && *p == '0' && p[-1] != '.')
+				while (tp > tmp + 2 && *tp == '0'
+							     && tp[-1] != '.')
 				{
-				    STRMOVE(p, p + 1);
-				    --p;
+				    STRMOVE(tp, tp + 1);
+				    --tp;
 				    --str_arg_l;
 				}
 			}
 			else
 			{
-			    char *p;
+			    char *tp;
 
 			    /* Be consistent: some printf("%e") use 1.0e+12
 			     * and some 1.0e+012.  Remove one zero in the last
 			     * case. */
-			    p = (char *)vim_strchr((char_u *)tmp,
+			    tp = (char *)vim_strchr((char_u *)tmp,
 						 fmt_spec == 'e' ? 'e' : 'E');
-			    if (p != NULL && (p[1] == '+' || p[1] == '-')
-					  && p[2] == '0'
-					  && vim_isdigit(p[3])
-					  && vim_isdigit(p[4]))
+			    if (tp != NULL && (tp[1] == '+' || tp[1] == '-')
+					  && tp[2] == '0'
+					  && vim_isdigit(tp[3])
+					  && vim_isdigit(tp[4]))
 			    {
-				STRMOVE(p + 2, p + 3);
+				STRMOVE(tp + 2, tp + 3);
 				--str_arg_l;
 			    }
 			}
@@ -4685,7 +4706,8 @@
 			size_t avail = str_m - str_l;
 
 			vim_memset(str + str_l, zero_padding ? '0' : ' ',
-					     (size_t)pn > avail ? avail : pn);
+					     (size_t)pn > avail ? avail
+								: (size_t)pn);
 		    }
 		    str_l += pn;
 		}
@@ -4712,7 +4734,8 @@
 			size_t avail = str_m - str_l;
 
 			mch_memmove(str + str_l, str_arg,
-					     (size_t)zn > avail ? avail : zn);
+					     (size_t)zn > avail ? avail
+								: (size_t)zn);
 		    }
 		    str_l += zn;
 		}
@@ -4727,7 +4750,8 @@
 			size_t avail = str_m-str_l;
 
 			vim_memset(str + str_l, '0',
-					     (size_t)zn > avail ? avail : zn);
+					     (size_t)zn > avail ? avail
+								: (size_t)zn);
 		    }
 		    str_l += zn;
 		}
@@ -4746,7 +4770,7 @@
 
 			mch_memmove(str + str_l,
 				str_arg + zero_padding_insertion_ind,
-				(size_t)sn > avail ? avail : sn);
+				(size_t)sn > avail ? avail : (size_t)sn);
 		    }
 		    str_l += sn;
 		}
@@ -4766,7 +4790,8 @@
 			size_t avail = str_m - str_l;
 
 			vim_memset(str + str_l, ' ',
-					     (size_t)pn > avail ? avail : pn);
+					     (size_t)pn > avail ? avail
+								: (size_t)pn);
 		    }
 		    str_l += pn;
 		}
diff -Naur vim72.orig/src/misc1.c vim72/src/misc1.c
--- vim72.orig/src/misc1.c	2008-07-12 12:20:53.000000000 -0700
+++ vim72/src/misc1.c	2009-06-05 14:25:15.000000000 -0700
@@ -2188,12 +2188,11 @@
  *
  * return FAIL for failure, OK otherwise
  */
-/*ARGSUSED*/
     int
 del_bytes(count, fixpos_arg, use_delcombine)
     long	count;
     int		fixpos_arg;
-    int		use_delcombine;	    /* 'delcombine' option applies */
+    int		use_delcombine UNUSED;	    /* 'delcombine' option applies */
 {
     char_u	*oldp, *newp;
     colnr_T	oldlen;
@@ -2717,6 +2716,9 @@
     long	xtra;
 {
     win_T	*wp;
+#ifdef FEAT_WINDOWS
+    tabpage_T	*tp;
+#endif
     int		i;
 #ifdef FEAT_JUMPLIST
     int		cols;
@@ -2769,7 +2771,7 @@
 		    curbuf->b_changelistlen = JUMPLISTSIZE - 1;
 		    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,
 					  sizeof(pos_T) * (JUMPLISTSIZE - 1));
-		    FOR_ALL_WINDOWS(wp)
+		    FOR_ALL_TAB_WINDOWS(tp, wp)
 		    {
 			/* Correct position in changelist for other windows on
 			 * this buffer. */
@@ -2777,7 +2779,7 @@
 			    --wp->w_changelistidx;
 		    }
 		}
-		FOR_ALL_WINDOWS(wp)
+		FOR_ALL_TAB_WINDOWS(tp, wp)
 		{
 		    /* For other windows, if the position in the changelist is
 		     * at the end it stays at the end. */
@@ -2796,7 +2798,7 @@
 #endif
     }
 
-    FOR_ALL_WINDOWS(wp)
+    FOR_ALL_TAB_WINDOWS(tp, wp)
     {
 	if (wp->w_buffer == curbuf)
 	{
@@ -2955,6 +2957,8 @@
     int	    col;		/* column for message; non-zero when in insert
 				   mode and 'showmode' is on */
 {
+    static char *w_readonly = N_("W10: Warning: Changing a readonly file");
+
     if (curbuf->b_did_warn == FALSE
 	    && curbufIsChanged() == 0
 #ifdef FEAT_AUTOCMD
@@ -2977,8 +2981,10 @@
 	if (msg_row == Rows - 1)
 	    msg_col = col;
 	msg_source(hl_attr(HLF_W));
-	MSG_PUTS_ATTR(_("W10: Warning: Changing a readonly file"),
-						   hl_attr(HLF_W) | MSG_HIST);
+	MSG_PUTS_ATTR(_(w_readonly), hl_attr(HLF_W) | MSG_HIST);
+#ifdef FEAT_EVAL
+	set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);
+#endif
 	msg_clr_eos();
 	(void)msg_end();
 	if (msg_silent == 0 && !silent_mode)
@@ -3245,9 +3251,9 @@
 
     /* When using ":silent" assume that <CR> was entered. */
     if (mouse_used != NULL)
-	MSG_PUTS(_("Type number or click with mouse (<Enter> cancels): "));
+	MSG_PUTS(_("Type number and <Enter> or click with mouse (empty cancels): "));
     else
-	MSG_PUTS(_("Choice number (<Enter> cancels): "));
+	MSG_PUTS(_("Type number and <Enter> (empty cancels): "));
 
     /* Set the state such that text can be selected/copied/pasted and we still
      * get mouse events. */
@@ -4141,10 +4147,9 @@
 /*
  * Function given to ExpandGeneric() to obtain an environment variable name.
  */
-/*ARGSUSED*/
     char_u *
 get_env_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
 # if defined(AMIGA) || defined(__MRC__) || defined(__SC__)
@@ -4736,9 +4741,9 @@
 	 * If it is then restrict the search to below this line and try again.
 	 */
 	line = ml_get(pos->lnum);
-	for (p = line; *p && (unsigned)(p - line) < pos->col; ++p)
+	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
 	    p = skip_string(p);
-	if ((unsigned)(p - line) <= pos->col)
+	if ((colnr_T)(p - line) <= pos->col)
 	    break;
 	cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;
 	if (cur_maxcomment <= 0)
@@ -6269,7 +6274,7 @@
      * check for that.
      */
     if ((State & INSERT)
-	    && curwin->w_cursor.col < STRLEN(linecopy)
+	    && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)
 	    && linecopy[curwin->w_cursor.col] == ')')
 	linecopy[curwin->w_cursor.col] = NUL;
 
diff -Naur vim72.orig/src/misc2.c vim72/src/misc2.c
--- vim72.orig/src/misc2.c	2008-07-23 12:12:56.000000000 -0700
+++ vim72/src/misc2.c	2009-06-05 14:25:06.000000000 -0700
@@ -496,7 +496,8 @@
 {
     colnr_T len;
 #ifdef FEAT_VIRTUALEDIT
-    colnr_T oldcol = curwin->w_cursor.col + curwin->w_cursor.coladd;
+    colnr_T oldcol = curwin->w_cursor.col;
+    colnr_T oldcoladd = curwin->w_cursor.col + curwin->w_cursor.coladd;
 #endif
 
     len = (colnr_T)STRLEN(ml_get_curline());
@@ -535,7 +536,13 @@
     if (oldcol == MAXCOL)
 	curwin->w_cursor.coladd = 0;
     else if (ve_flags == VE_ALL)
-	curwin->w_cursor.coladd = oldcol - curwin->w_cursor.col;
+    {
+	if (oldcoladd > curwin->w_cursor.col)
+	    curwin->w_cursor.coladd = oldcoladd - curwin->w_cursor.col;
+	else
+	    /* avoid weird number when there is a miscalculation or overflow */
+	    curwin->w_cursor.coladd = 0;
+    }
 #endif
 }
 
@@ -873,7 +880,7 @@
 	    /* 3. check for available memory: call mch_avail_mem() */
 	    if (mch_avail_mem(TRUE) < KEEP_ROOM && !releasing)
 	    {
-		vim_free((char *)p);	/* System is low... no go! */
+		free((char *)p);	/* System is low... no go! */
 		p = NULL;
 	    }
 	    else
@@ -1010,6 +1017,9 @@
 # if defined(FEAT_PROFILE)
     do_cmdline_cmd((char_u *)"profdel *");
 # endif
+# if defined(FEAT_KEYMAP)
+    do_cmdline_cmd((char_u *)"set keymap=");
+#endif
 
 # ifdef FEAT_TITLE
     free_titles();
@@ -1034,6 +1044,9 @@
     free_regexp_stuff();
     free_tag_stuff();
     free_cd_dir();
+# ifdef FEAT_SIGNS
+    free_signs();
+# endif
 # ifdef FEAT_EVAL
     set_expr_line(NULL);
 # endif
@@ -1062,11 +1075,12 @@
 
 #ifdef FEAT_QUICKFIX
     {
-	win_T	*win;
+	win_T	    *win;
+	tabpage_T   *tab;
 
 	qf_free_all(NULL);
 	/* Free all location lists */
-	FOR_ALL_WINDOWS(win)
+	FOR_ALL_TAB_WINDOWS(tab, win)
 	    qf_free_all(win);
     }
 #endif
@@ -1257,7 +1271,6 @@
     return escaped_string;
 }
 
-#if !defined(BACKSLASH_IN_FILENAME) || defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Return TRUE when 'shell' has "csh" in the tail.
  */
@@ -1266,9 +1279,7 @@
 {
     return (strstr((char *)gettail(p_sh), "csh") != NULL);
 }
-#endif
 
-#if defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Escape "string" for use as a shell argument with system().
  * This uses single quotes, except when we know we need to use double qoutes
@@ -1391,7 +1402,6 @@
 
     return escaped_string;
 }
-#endif
 
 /*
  * Like vim_strsave(), but make all characters uppercase.
@@ -2565,7 +2575,7 @@
     int		key;
     int		dlen = 0;
 
-    key = find_special_key(srcp, &modifiers, keycode);
+    key = find_special_key(srcp, &modifiers, keycode, FALSE);
     if (key == 0)
 	return 0;
 
@@ -2601,10 +2611,11 @@
  * returns 0 if there is no match.
  */
     int
-find_special_key(srcp, modp, keycode)
+find_special_key(srcp, modp, keycode, keep_x_key)
     char_u	**srcp;
     int		*modp;
-    int		keycode; /* prefer key code, e.g. K_DEL instead of DEL */
+    int		keycode;     /* prefer key code, e.g. K_DEL instead of DEL */
+    int		keep_x_key;  /* don't translate xHome to Home key */
 {
     char_u	*last_dash;
     char_u	*end_of_name;
@@ -2672,7 +2683,8 @@
 	    else
 	    {
 		key = get_special_key_code(last_dash + 1);
-		key = handle_x_keys(key);
+		if (!keep_x_key)
+		    key = handle_x_keys(key);
 	    }
 
 	    /*
@@ -2829,7 +2841,7 @@
 get_key_name(i)
     int	    i;
 {
-    if (i >= KEY_NAMES_TABLE_LEN)
+    if (i >= (int)KEY_NAMES_TABLE_LEN)
 	return NULL;
     return  key_names_table[i].name;
 }
@@ -3857,7 +3869,8 @@
      * use filename.
      */
 #ifdef UNIX
-    int			ffv_dev;	/* device number (-1 if not set) */
+    int			ffv_dev_valid;	/* ffv_dev and ffv_ino were set */
+    dev_t		ffv_dev;	/* device number */
     ino_t		ffv_ino;	/* inode number */
 #endif
     /* The memory for this struct is allocated according to the length of
@@ -4047,13 +4060,12 @@
  * This function silently ignores a few errors, vim_findfile() will have
  * limited functionality then.
  */
-/*ARGSUSED*/
     void *
 vim_findfile_init(path, filename, stopdirs, level, free_visited, find_what,
 					   search_ctx_arg, tagfile, rel_fname)
     char_u	*path;
     char_u	*filename;
-    char_u	*stopdirs;
+    char_u	*stopdirs UNUSED;
     int		level;
     int		free_visited;
     int		find_what;
@@ -4698,7 +4710,8 @@
 				stackp->ffs_filearray_cur = i + 1;
 				ff_push(search_ctx, stackp);
 
-				simplify_filename(file_path);
+				if (!path_with_url(file_path))
+				    simplify_filename(file_path);
 				if (mch_dirname(ff_expand_buffer, MAXPATHL)
 									== OK)
 				{
@@ -5050,10 +5063,9 @@
     {
 	if (
 #ifdef UNIX
-		!url
-		    ? (vp->ffv_dev == st.st_dev
-			&& vp->ffv_ino == st.st_ino)
-		    :
+		!url ? (vp->ffv_dev_valid && vp->ffv_dev == st.st_dev
+						  && vp->ffv_ino == st.st_ino)
+		     :
 #endif
 		fnamecmp(vp->ffv_fname, ff_expand_buffer) == 0
 	   )
@@ -5078,14 +5090,14 @@
 #ifdef UNIX
 	if (!url)
 	{
+	    vp->ffv_dev_valid = TRUE;
 	    vp->ffv_ino = st.st_ino;
 	    vp->ffv_dev = st.st_dev;
 	    vp->ffv_fname[0] = NUL;
 	}
 	else
 	{
-	    vp->ffv_ino = 0;
-	    vp->ffv_dev = -1;
+	    vp->ffv_dev_valid = FALSE;
 #endif
 	    STRCPY(vp->ffv_fname, ff_expand_buffer);
 #ifdef UNIX
diff -Naur vim72.orig/src/move.c vim72/src/move.c
--- vim72.orig/src/move.c	2008-07-12 09:26:47.000000000 -0700
+++ vim72/src/move.c	2009-06-05 14:24:51.000000000 -0700
@@ -280,18 +280,20 @@
 
 	if (curwin->w_botline <= curbuf->b_ml.ml_line_count)
 	{
-	    if (curwin->w_cursor.lnum < curwin->w_botline
-		    && ((long)curwin->w_cursor.lnum
+	    if (curwin->w_cursor.lnum < curwin->w_botline)
+	    {
+	      if (((long)curwin->w_cursor.lnum
 					     >= (long)curwin->w_botline - p_so
 #ifdef FEAT_FOLDING
 			|| hasAnyFolding(curwin)
 #endif
 			))
-	    {
+	      {
 		lineoff_T	loff;
 
-		/* Cursor is above botline, check if there are 'scrolloff'
-		 * window lines below the cursor.  If not, need to scroll. */
+		/* Cursor is (a few lines) above botline, check if there are
+		 * 'scrolloff' window lines below the cursor.  If not, need to
+		 * scroll. */
 		n = curwin->w_empty_rows;
 		loff.lnum = curwin->w_cursor.lnum;
 #ifdef FEAT_FOLDING
@@ -317,6 +319,10 @@
 		if (n >= p_so)
 		    /* sufficient context, no need to scroll */
 		    check_botline = FALSE;
+	      }
+	      else
+		  /* sufficient context, no need to scroll */
+		  check_botline = FALSE;
 	    }
 	    if (check_botline)
 	    {
@@ -509,6 +515,9 @@
     /* Approximate the value of w_botline */
     wp->w_botline += lnum - wp->w_topline;
     wp->w_topline = lnum;
+#ifdef FEAT_AUTOCMD
+    wp->w_topline_was_set = TRUE;
+#endif
 #ifdef FEAT_DIFF
     wp->w_topfill = 0;
 #endif
@@ -1229,11 +1238,10 @@
 /*
  * Scroll the current window down by "line_count" logical lines.  "CTRL-Y"
  */
-/*ARGSUSED*/
     void
 scrolldown(line_count, byfold)
     long	line_count;
-    int		byfold;		/* TRUE: count a closed fold as one line */
+    int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
 {
     long	done = 0;	/* total # of physical lines done */
     int		wrow;
@@ -1340,11 +1348,10 @@
 /*
  * Scroll the current window up by "line_count" logical lines.  "CTRL-E"
  */
-/*ARGSUSED*/
     void
 scrollup(line_count, byfold)
     long	line_count;
-    int		byfold;		/* TRUE: count a closed fold as one line */
+    int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
 {
 #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
     linenr_T	lnum;
diff -Naur vim72.orig/src/nbdebug.c vim72/src/nbdebug.c
--- vim72.orig/src/nbdebug.c	2008-06-22 08:38:58.000000000 -0700
+++ vim72/src/nbdebug.c	2009-06-05 14:21:41.000000000 -0700
@@ -33,7 +33,6 @@
 u_int		 nb_dlevel = 0;		/* nb_debug verbosity level */
 
 void		 nbdb(char *, ...);
-void		 nbtrace(char *, ...);
 
 static int	 lookup(char *);
 #ifdef USE_NB_ERRORHANDLER
@@ -100,25 +99,6 @@
 }    /* end nbdebug_log_init */
 
 
-
-
-void
-nbtrace(
-	char		*fmt,
-	...)
-{
-	va_list		 ap;
-
-	if (nb_debug!= NULL && (nb_dlevel & (NB_TRACE | NB_TRACE_VERBOSE))) {
-		va_start(ap, fmt);
-		vfprintf(nb_debug, fmt, ap);
-		va_end(ap);
-		fflush(nb_debug);
-	}
-
-}    /* end nbtrace */
-
-
 void
 nbdbg(
 	char		*fmt,
@@ -136,23 +116,6 @@
 }    /* end nbdbg */
 
 
-void
-nbprt(
-	char		*fmt,
-	...)
-{
-	va_list		 ap;
-
-	if (nb_debug != NULL && nb_dlevel & NB_PRINT) {
-		va_start(ap, fmt);
-		vfprintf(nb_debug, fmt, ap);
-		va_end(ap);
-		fflush(nb_debug);
-	}
-
-}    /* end nbprt */
-
-
 static int
 lookup(
 	char		*file)
diff -Naur vim72.orig/src/nbdebug.h vim72/src/nbdebug.h
--- vim72.orig/src/nbdebug.h	2008-06-22 07:31:50.000000000 -0700
+++ vim72/src/nbdebug.h	2009-06-05 14:21:41.000000000 -0700
@@ -43,8 +43,6 @@
 
 
 void		 nbdbg(char *, ...);
-void		 nbprt(char *, ...);
-void		 nbtrace(char *, ...);
 
 void nbdebug_wait __ARGS((u_int wait_flags, char *wait_var, u_int wait_secs));
 void nbdebug_log_init __ARGS((char *log_var, char *level_var));
@@ -70,19 +68,5 @@
 {
 }
 
-void
-nbprt(
-	char		*fmt,
-	...)
-{
-}
-
-void
-nbtrace(
-	char		*fmt,
-	...)
-{
-}
-
 #endif /* NBDEBUG */
 #endif /* NBDEBUG_H */
diff -Naur vim72.orig/src/netbeans.c vim72/src/netbeans.c
--- vim72.orig/src/netbeans.c	2008-07-13 09:19:54.000000000 -0700
+++ vim72/src/netbeans.c	2009-06-05 14:25:22.000000000 -0700
@@ -700,7 +700,6 @@
 /*
  * Read and process a command from netbeans.
  */
-/*ARGSUSED*/
 #if defined(FEAT_GUI_W32) || defined(PROTO)
 /* Use this one when generating prototypes, the others are static. */
     void
@@ -708,12 +707,15 @@
 #else
 # ifdef FEAT_GUI_MOTIF
     static void
-messageFromNetbeans(XtPointer clientData, int *unused1, XtInputId *unused2)
+messageFromNetbeans(XtPointer clientData UNUSED,
+		    int *unused1 UNUSED,
+		    XtInputId *unused2 UNUSED)
 # endif
 # ifdef FEAT_GUI_GTK
     static void
-messageFromNetbeans(gpointer clientData, gint unused1,
-						    GdkInputCondition unused2)
+messageFromNetbeans(gpointer clientData UNUSED,
+		    gint unused1 UNUSED,
+		    GdkInputCondition unused2 UNUSED)
 # endif
 #endif
 {
@@ -1043,7 +1045,7 @@
 	nbdebug(("EVT: %s", buf));
 /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
 	if (sd >= 0)
-	    sock_write(sd, buf, (int)STRLEN(buf));  /* ignore errors */
+	    ignored = sock_write(sd, buf, (int)STRLEN(buf));
     }
 }
 
@@ -1582,7 +1584,9 @@
 			    buf_delsign(buf->bufp, id);
 			}
 			else
+			{
 			    nbdebug(("    No sign on line %d\n", i));
+			}
 		    }
 
 		    nbdebug(("    Deleting lines %d through %d\n", del_from_lnum, del_to_lnum));
@@ -1921,7 +1925,7 @@
 	    vim_free(path);
 	    if (bufp == NULL)
 	    {
-	    	nbdebug(("    File %s not found in setBufferNumber\n", args));
+		nbdebug(("    File %s not found in setBufferNumber\n", args));
 		EMSG2("E642: File %s not found in setBufferNumber", args);
 		return FAIL;
 	    }
@@ -2141,7 +2145,9 @@
 #endif
 	    }
 	    else
+	    {
 		nbdebug(("    BAD POSITION in setDot: %s\n", s));
+	    }
 
 	    /* gui_update_cursor(TRUE, FALSE); */
 	    /* update_curbuf(NOT_VALID); */
@@ -2277,9 +2283,6 @@
 	    int serNum;
 	    int localTypeNum;
 	    int typeNum;
-# ifdef NBDEBUG
-	    int len;
-# endif
 	    pos_T *pos;
 
 	    if (buf == NULL || buf->bufp == NULL)
@@ -2303,13 +2306,10 @@
 	    pos = get_off_or_lnum(buf->bufp, &args);
 
 	    cp = (char *)args;
-# ifdef NBDEBUG
-	    len =
-# endif
-		strtol(cp, &cp, 10);
+	    ignored = (int)strtol(cp, &cp, 10);
 	    args = (char_u *)cp;
 # ifdef NBDEBUG
-	    if (len != -1)
+	    if (ignored != -1)
 	    {
 		nbdebug(("    partial line annotation -- Not Yet Implemented!\n"));
 	    }
@@ -2321,7 +2321,7 @@
 	    }
 	    if (pos)
 	    {
-		coloncmd(":sign place %d line=%d name=%d buffer=%d",
+		coloncmd(":sign place %d line=%ld name=%d buffer=%d",
 			   serNum, pos->lnum, typeNum, buf->bufp->b_fnum);
 		if (typeNum == curPCtype)
 		    coloncmd(":sign jump %d buffer=%d", serNum,
@@ -2425,7 +2425,7 @@
 				GUARDED) == 0)
 			    {
 				coloncmd(
-				    ":sign place %d line=%d name=%d buffer=%d",
+				    ":sign place %d line=%ld name=%d buffer=%d",
 				     guardId++, lnum, GUARDED,
 				     buf->bufp->b_fnum);
 			    }
@@ -2747,11 +2747,10 @@
  * cursor and sends it to the debugger for evaluation.  The debugger should
  * respond with a showBalloon command when there is a useful result.
  */
-/*ARGSUSED*/
     void
 netbeans_beval_cb(
 	BalloonEval	*beval,
-	int		 state)
+	int		 state UNUSED)
 {
     win_T	*wp;
     char_u	*text;
@@ -2924,44 +2923,26 @@
 }
 
 /*
- * Tell netbeans a file was closed.
+ * Tell netbeans that a file was deleted or wiped out.
  */
     void
-netbeans_file_closed(buf_T *bufp)
+netbeans_file_killed(buf_T *bufp)
 {
     int		bufno = nb_getbufno(bufp);
     nbbuf_T	*nbbuf = nb_get_buf(bufno);
     char	buffer[2*MAXPATHL];
 
-    if (!haveConnection || bufno < 0)
-	return;
-
-    if (!netbeansCloseFile)
-    {
-	nbdebug(("Ignoring file_closed for %s. File was closed from IDE\n",
-		    bufp->b_ffname));
+    if (!haveConnection || bufno == -1)
 	return;
-    }
-
-    nbdebug(("netbeans_file_closed:\n"));
-    nbdebug(("    Closing bufno: %d", bufno));
-    if (curbuf != NULL && curbuf != bufp)
-    {
-	nbdebug(("    Curbuf bufno:  %d\n", nb_getbufno(curbuf)));
-    }
-    else if (curbuf == bufp)
-    {
-	nbdebug(("    curbuf == bufp\n"));
-    }
 
-    if (bufno <= 0)
-	return;
+    nbdebug(("netbeans_file_killed:\n"));
+    nbdebug(("    Killing bufno: %d", bufno));
 
     sprintf(buffer, "%d:killed=%d\n", bufno, r_cmdno);
 
     nbdebug(("EVT: %s", buffer));
 
-    nb_send(buffer, "netbeans_file_closed");
+    nb_send(buffer, "netbeans_file_killed");
 
     if (nbbuf != NULL)
 	nbbuf->bufp = NULL;
@@ -3082,9 +3063,8 @@
 /*
  * Send netbeans an unmodufied command.
  */
-/*ARGSUSED*/
     void
-netbeans_unmodified(buf_T *bufp)
+netbeans_unmodified(buf_T *bufp UNUSED)
 {
 #if 0
     char_u	buf[128];
@@ -3391,13 +3371,12 @@
  * buf->signmapused[]	maps buffer-local annotation IDs to an index in
  *			globalsignmap[].
  */
-/*ARGSUSED*/
     static void
 addsigntype(
     nbbuf_T	*buf,
     int		typeNum,
     char_u	*typeName,
-    char_u	*tooltip,
+    char_u	*tooltip UNUSED,
     char_u	*glyphFile,
     int		use_fg,
     int		fg,
diff -Naur vim72.orig/src/normal.c vim72/src/normal.c
--- vim72.orig/src/normal.c	2008-07-31 13:03:08.000000000 -0700
+++ vim72/src/normal.c	2009-06-05 14:25:15.000000000 -0700
@@ -183,6 +183,8 @@
 static void	nv_cursorhold __ARGS((cmdarg_T *cap));
 #endif
 
+static char *e_noident = N_("E349: No identifier under cursor");
+
 /*
  * Function to be called for a Normal or Visual mode command.
  * The argument is a cmdarg_T.
@@ -491,14 +493,14 @@
     int		i;
 
     /* Fill the index table with a one to one relation. */
-    for (i = 0; i < NV_CMDS_SIZE; ++i)
+    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
 	nv_cmd_idx[i] = i;
 
     /* Sort the commands by the command character.  */
     qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);
 
     /* Find the first entry that can't be indexed by the command character. */
-    for (i = 0; i < NV_CMDS_SIZE; ++i)
+    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
 	if (i != nv_cmds[nv_cmd_idx[i]].cmd_char)
 	    break;
     nv_max_linear = i - 1;
@@ -559,11 +561,10 @@
 /*
  * Execute a command in Normal mode.
  */
-/*ARGSUSED*/
     void
 normal_cmd(oap, toplevel)
     oparg_T	*oap;
-    int		toplevel;		/* TRUE when called from main() */
+    int		toplevel UNUSED;	/* TRUE when called from main() */
 {
     cmdarg_T	ca;			/* command arguments */
     int		c;
@@ -578,6 +579,9 @@
     static int	old_mapped_len = 0;
 #endif
     int		idx;
+#ifdef FEAT_EVAL
+    int		set_prevcount = FALSE;
+#endif
 
     vim_memset(&ca, 0, sizeof(ca));	/* also resets ca.retval */
     ca.oap = oap;
@@ -613,7 +617,12 @@
     /* When not finishing an operator and no register name typed, reset the
      * count. */
     if (!finish_op && !oap->regname)
+    {
 	ca.opcount = 0;
+#ifdef FEAT_EVAL
+	set_prevcount = TRUE;
+#endif
+    }
 
 #ifdef FEAT_AUTOCMD
     /* Restore counts from before receiving K_CURSORHOLD.  This means after
@@ -641,10 +650,7 @@
      * Get the command character from the user.
      */
     c = safe_vgetc();
-
-#ifdef FEAT_LANGMAP
     LANGMAP_ADJUST(c, TRUE);
-#endif
 
 #ifdef FEAT_VISUAL
     /*
@@ -717,7 +723,15 @@
 	     * command, so that v:count can be used in an expression mapping
 	     * right after the count. */
 	    if (toplevel && stuff_empty())
-		set_vcount(ca.count0, ca.count0 == 0 ? 1 : ca.count0);
+	    {
+		long count = ca.count0;
+
+		/* multiply with ca.opcount the same way as below */
+		if (ca.opcount != 0)
+		    count = ca.opcount * (count == 0 ? 1 : count);
+		set_vcount(count, count == 0 ? 1 : count, set_prevcount);
+		set_prevcount = FALSE;  /* only set v:prevcount once */
+	    }
 #endif
 	    if (ctrl_w)
 	    {
@@ -726,9 +740,7 @@
 	    }
 	    ++no_zero_mapping;		/* don't map zero here */
 	    c = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(c, TRUE);
-#endif
 	    --no_zero_mapping;
 	    if (ctrl_w)
 	    {
@@ -751,9 +763,7 @@
 	    ++no_mapping;
 	    ++allow_keys;		/* no mapping for nchar, but keys */
 	    c = plain_vgetc();		/* get next character */
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(c, TRUE);
-#endif
 	    --no_mapping;
 	    --allow_keys;
 #ifdef FEAT_CMDL_INFO
@@ -804,7 +814,7 @@
      * Only set v:count when called from main() and not a stuffed command.
      */
     if (toplevel && stuff_empty())
-	set_vcount(ca.count0, ca.count1);
+	set_vcount(ca.count0, ca.count1, set_prevcount);
 #endif
 
     /*
@@ -941,9 +951,7 @@
 	     * "gr", "g'" and "g`".
 	     */
 	    ca.nchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(ca.nchar, TRUE);
-#endif
 #ifdef FEAT_CMDL_INFO
 	    need_flushbuf |= add_to_showcmd(ca.nchar);
 #endif
@@ -1044,10 +1052,8 @@
 		}
 #endif
 
-#ifdef FEAT_LANGMAP
 		/* adjust chars > 127, except after "tTfFr" commands */
 		LANGMAP_ADJUST(*cp, !lang);
-#endif
 #ifdef FEAT_RIGHTLEFT
 		/* adjust Hebrew mapped char */
 		if (p_hkmap && lang && KeyTyped)
@@ -1132,7 +1138,8 @@
 	out_flush();
 #endif
 #ifdef FEAT_AUTOCMD
-    did_cursorhold = FALSE;
+    if (ca.cmdchar != K_IGNORE)
+	did_cursorhold = FALSE;
 #endif
 
     State = NORMAL;
@@ -2180,10 +2187,9 @@
 /*
  * Handle the "g@" operator: call 'operatorfunc'.
  */
-/*ARGSUSED*/
     static void
 op_function(oap)
-    oparg_T	*oap;
+    oparg_T	*oap UNUSED;
 {
 #ifdef FEAT_EVAL
     char_u	*(argv[1]);
@@ -3509,7 +3515,7 @@
 	if (find_type & FIND_STRING)
 	    EMSG(_("E348: No string under cursor"));
 	else
-	    EMSG(_("E349: No identifier under cursor"));
+	    EMSG(_(e_noident));
 	return 0;
     }
     ptr += col;
@@ -3701,13 +3707,13 @@
 #ifdef FEAT_VISUAL
     if (VIsual_active && !char_avail())
     {
-	int		i = lt(VIsual, curwin->w_cursor);
+	int		cursor_bot = lt(VIsual, curwin->w_cursor);
 	long		lines;
 	colnr_T		leftcol, rightcol;
 	linenr_T	top, bot;
 
 	/* Show the size of the Visual area. */
-	if (i)
+	if (cursor_bot)
 	{
 	    top = VIsual.lnum;
 	    bot = curwin->w_cursor.lnum;
@@ -3726,14 +3732,23 @@
 
 	if (VIsual_mode == Ctrl_V)
 	{
+#ifdef FEAT_LINEBREAK
+	    char_u *saved_sbr = p_sbr;
+
+	    /* Make 'sbr' empty for a moment to get the correct size. */
+	    p_sbr = empty_option;
+#endif
 	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
+#ifdef FEAT_LINEBREAK
+	    p_sbr = saved_sbr;
+#endif
 	    sprintf((char *)showcmd_buf, "%ldx%ld", lines,
 					      (long)(rightcol - leftcol + 1));
 	}
 	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
 	    sprintf((char *)showcmd_buf, "%ld", lines);
 	else
-	    sprintf((char *)showcmd_buf, "%ld", (long)(i
+	    sprintf((char *)showcmd_buf, "%ld", (long)(cursor_bot
 		    ? curwin->w_cursor.col - VIsual.col
 		    : VIsual.col - curwin->w_cursor.col) + (*p_sel != 'e'));
 	showcmd_buf[SHOWCMD_COLS] = NUL;	/* truncate */
@@ -4083,10 +4098,9 @@
  * Command character that doesn't do anything, but unlike nv_ignore() does
  * start edit().  Used for "startinsert" executed while starting up.
  */
-/*ARGSUSED */
     static void
 nv_nop(cap)
-    cmdarg_T	*cap;
+    cmdarg_T	*cap UNUSED;
 {
 }
 
@@ -4611,9 +4625,7 @@
 	    ++no_mapping;
 	    ++allow_keys;   /* no mapping for nchar, but allow key codes */
 	    nchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(nchar, TRUE);
-#endif
 	    --no_mapping;
 	    --allow_keys;
 #ifdef FEAT_CMDL_INFO
@@ -4969,9 +4981,7 @@
 		++no_mapping;
 		++allow_keys;   /* no mapping for nchar, but allow key codes */
 		nchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 		LANGMAP_ADJUST(nchar, TRUE);
-#endif
 		--no_mapping;
 		--allow_keys;
 #ifdef FEAT_CMDL_INFO
@@ -5228,7 +5238,7 @@
 	if (cap->oap->op_type != OP_NOP
 		&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count
 		    || cap->oap->start.col >
-					 STRLEN(ml_get(cap->oap->start.lnum))))
+			       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))))
 	    clearopbeep(cap->oap);
     }
 }
@@ -5469,6 +5479,20 @@
 		STRCPY(buf, "he! ");
 	    else
 	    {
+		/* An external command will probably use an argument starting
+		 * with "-" as an option.  To avoid trouble we skip the "-". */
+		while (*ptr == '-' && n > 0)
+		{
+		    ++ptr;
+		    --n;
+		}
+		if (n == 0)
+		{
+		    EMSG(_(e_noident));	 /* found dashes only */
+		    vim_free(buf);
+		    return;
+		}
+
 		/* When a count is given, turn it into a range.  Is this
 		 * really what we want? */
 		isman = (STRCMP(kp, "man") == 0);
@@ -5511,37 +5535,59 @@
     /*
      * Now grab the chars in the identifier
      */
-    if (cmdchar == '*')
-	aux_ptr = (char_u *)(p_magic ? "/.*~[^$\\" : "/^$\\");
-    else if (cmdchar == '#')
-	aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
-    else if (cmdchar == 'K' && !kp_help)
-	aux_ptr = (char_u *)" \t\\\"|!";
-    else
-	/* Don't escape spaces and Tabs in a tag with a backslash */
-	aux_ptr = (char_u *)"\\|\"";
-
-    p = buf + STRLEN(buf);
-    while (n-- > 0)
-    {
-	/* put a backslash before \ and some others */
-	if (vim_strchr(aux_ptr, *ptr) != NULL)
-	    *p++ = '\\';
-#ifdef FEAT_MBYTE
-	/* When current byte is a part of multibyte character, copy all bytes
-	 * of that character. */
-	if (has_mbyte)
+    if (cmdchar == 'K' && !kp_help)
+    {
+	/* Escape the argument properly for a shell command */
+	ptr = vim_strnsave(ptr, n);
+	p = vim_strsave_shellescape(ptr, TRUE);
+	vim_free(ptr);
+	if (p == NULL)
 	{
-	    int i;
-	    int len = (*mb_ptr2len)(ptr) - 1;
-
-	    for (i = 0; i < len && n >= 1; ++i, --n)
-		*p++ = *ptr++;
+	    vim_free(buf);
+	    return;
 	}
+	buf = (char_u *)vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);
+	if (buf == NULL)
+	{
+	    vim_free(buf);
+	    vim_free(p);
+	    return;
+	}
+	STRCAT(buf, p);
+	vim_free(p);
+    }
+    else
+    {
+	if (cmdchar == '*')
+	    aux_ptr = (char_u *)(p_magic ? "/.*~[^$\\" : "/^$\\");
+	else if (cmdchar == '#')
+	    aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
+	else
+	    /* Don't escape spaces and Tabs in a tag with a backslash */
+	    aux_ptr = (char_u *)"\\|\"\n*?[";
+
+	p = buf + STRLEN(buf);
+	while (n-- > 0)
+	{
+	    /* put a backslash before \ and some others */
+	    if (vim_strchr(aux_ptr, *ptr) != NULL)
+		*p++ = '\\';
+#ifdef FEAT_MBYTE
+	    /* When current byte is a part of multibyte character, copy all
+	     * bytes of that character. */
+	    if (has_mbyte)
+	    {
+		int i;
+		int len = (*mb_ptr2len)(ptr) - 1;
+
+		for (i = 0; i < len && n >= 1; ++i, --n)
+		    *p++ = *ptr++;
+	    }
 #endif
-	*p++ = *ptr++;
+	    *p++ = *ptr++;
+	}
+	*p = NUL;
     }
-    *p = NUL;
 
     /*
      * Execute the command.
@@ -5767,7 +5813,10 @@
     for (n = cap->count1; n > 0; --n)
     {
 	if ((!PAST_LINE && oneright() == FAIL)
-		|| (PAST_LINE && *ml_get_cursor() == NUL))
+#ifdef FEAT_VISUAL
+		|| (PAST_LINE && *ml_get_cursor() == NUL)
+#endif
+		)
 	{
 	    /*
 	     *	  <Space> wraps to next line if 'whichwrap' has 's'.
@@ -6728,6 +6777,8 @@
     /* Visual mode "r" */
     if (VIsual_active)
     {
+	if (got_int)
+	    reset_VIsual();
 	nv_operator(cap);
 	return;
     }
@@ -7784,7 +7835,7 @@
 	else
 	    i = curwin->w_leftcol;
 	/* Go to the middle of the screen line.  When 'number' is on and lines
-	 * are wrapping the middle can be more to the left.*/
+	 * are wrapping the middle can be more to the left. */
 	if (cap->nchar == 'm')
 	    i += (W_WIDTH(curwin) - curwin_col_off()
 		    + ((curwin->w_p_wrap && i > 0)
@@ -9192,10 +9243,9 @@
 }
 
 #ifdef FEAT_SNIFF
-/*ARGSUSED*/
     static void
 nv_sniff(cap)
-    cmdarg_T	*cap;
+    cmdarg_T	*cap UNUSED;
 {
     ProcessSniffRequests();
 }
@@ -9211,10 +9261,9 @@
 #endif
 
 #ifdef FEAT_DND
-/*ARGSUSED*/
     static void
 nv_drop(cap)
-    cmdarg_T	*cap;
+    cmdarg_T	*cap UNUSED;
 {
     do_put('~', BACKWARD, 1L, PUT_CURSEND);
 }
@@ -9226,7 +9275,6 @@
  * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the
  * input buffer.  "did_cursorhold" is set to avoid retriggering.
  */
-/*ARGSUSED*/
     static void
 nv_cursorhold(cap)
     cmdarg_T	*cap;
diff -Naur vim72.orig/src/ops.c vim72/src/ops.c
--- vim72.orig/src/ops.c	2008-06-21 13:08:59.000000000 -0700
+++ vim72/src/ops.c	2009-06-05 14:25:51.000000000 -0700
@@ -72,11 +72,11 @@
  */
 struct block_def
 {
-    int		startspaces;	/* 'extra' cols of first char */
-    int		endspaces;	/* 'extra' cols of first char */
+    int		startspaces;	/* 'extra' cols before first char */
+    int		endspaces;	/* 'extra' cols after last char */
     int		textlen;	/* chars in block */
-    char_u	*textstart;	/* pointer to 1st char in block */
-    colnr_T	textcol;	/* cols of chars (at least part.) in block */
+    char_u	*textstart;	/* pointer to 1st char (partially) in block */
+    colnr_T	textcol;	/* index of chars (partially) in block */
     colnr_T	start_vcol;	/* start col of 1st char wholly inside block */
     colnr_T	end_vcol;	/* start col of 1st char wholly after block */
 #ifdef FEAT_VISUALEXTRA
@@ -382,18 +382,16 @@
 {
     int			left = (oap->op_type == OP_LSHIFT);
     int			oldstate = State;
-    int			total, split;
-    char_u		*newp, *oldp, *midp, *ptr;
+    int			total;
+    char_u		*newp, *oldp;
     int			oldcol = curwin->w_cursor.col;
     int			p_sw = (int)curbuf->b_p_sw;
     int			p_ts = (int)curbuf->b_p_ts;
     struct block_def	bd;
-    int			internal = 0;
     int			incr;
-    colnr_T		vcol, col = 0, ws_vcol;
+    colnr_T		ws_vcol;
     int			i = 0, j = 0;
     int			len;
-
 #ifdef FEAT_RIGHTLEFT
     int			old_p_ri = p_ri;
 
@@ -456,67 +454,90 @@
     }
     else /* left */
     {
-	vcol = oap->start_vcol;
-	/* walk vcol past ws to be removed */
-	for (midp = oldp + bd.textcol;
-	      vcol < (oap->start_vcol + total) && vim_iswhite(*midp); )
-	{
-	    incr = lbr_chartabsize_adv(&midp, (colnr_T)vcol);
-	    vcol += incr;
-	}
-	/* internal is the block-internal ws replacing a split TAB */
-	if (vcol > (oap->start_vcol + total))
-	{
-	    /* we have to split the TAB *(midp-1) */
-	    internal = vcol - (oap->start_vcol + total);
-	}
-	/* if 'expandtab' is not set, use TABs */
+	colnr_T	    destination_col;	/* column to which text in block will
+					   be shifted */
+	char_u	    *verbatim_copy_end;	/* end of the part of the line which is
+					   copied verbatim */
+	colnr_T	    verbatim_copy_width;/* the (displayed) width of this part
+					   of line */
+	unsigned    fill;		/* nr of spaces that replace a TAB */
+	unsigned    new_line_len;	/* the length of the line after the
+					   block shift */
+	size_t	    block_space_width;
+	size_t	    shift_amount;
+	char_u	    *non_white = bd.textstart;
+	colnr_T	    non_white_col;
 
-	split = bd.startspaces + internal;
-	if (split > 0)
-	{
-	    if (!curbuf->b_p_et)
-	    {
-		for (ptr = oldp, col = 0; ptr < oldp+bd.textcol; )
-		    col += lbr_chartabsize_adv(&ptr, (colnr_T)col);
+	/*
+	 * Firstly, let's find the first non-whitespace character that is
+	 * displayed after the block's start column and the character's column
+	 * number. Also, let's calculate the width of all the whitespace
+	 * characters that are displayed in the block and precede the searched
+	 * non-whitespace character.
+	 */
 
-		/* col+1 now equals the start col of the first char of the
-		 * block (may be < oap.start_vcol if we're splitting a TAB) */
-		i = ((col % p_ts) + split) / p_ts; /* number of tabs */
-	    }
-	    if (i)
-		j = ((col % p_ts) + split) % p_ts; /* number of spp */
-	    else
-		j = split;
-	}
+	/* If "bd.startspaces" is set, "bd.textstart" points to the character,
+	 * the part of which is displayed at the block's beginning. Let's start
+	 * searching from the next character. */
+	if (bd.startspaces)
+	    mb_ptr_adv(non_white);
 
-	newp = alloc_check(bd.textcol + i + j + (unsigned)STRLEN(midp) + 1);
-	if (newp == NULL)
-	    return;
-	vim_memset(newp, NUL, (size_t)(bd.textcol + i + j + STRLEN(midp) + 1));
+	/* The character's column is in "bd.start_vcol".  */
+	non_white_col = bd.start_vcol;
 
-	/* copy first part we want to keep */
-	mch_memmove(newp, oldp, (size_t)bd.textcol);
-	/* Now copy any TABS and spp to ensure correct alignment! */
-	while (vim_iswhite(*midp))
+	while (vim_iswhite(*non_white))
 	{
-	    if (*midp == TAB)
-		i++;
-	    else /*space */
-		j++;
-	    midp++;
+	    incr = lbr_chartabsize_adv(&non_white, non_white_col);
+	    non_white_col += incr;
 	}
-	/* We might have an extra TAB worth of spp now! */
-	if (j / p_ts && !curbuf->b_p_et)
+
+	block_space_width = non_white_col - oap->start_vcol;
+	/* We will shift by "total" or "block_space_width", whichever is less.
+	 */
+	shift_amount = (block_space_width < (size_t)total
+					 ? block_space_width : (size_t)total);
+
+	/* The column to which we will shift the text.  */
+	destination_col = (colnr_T)(non_white_col - shift_amount);
+
+	/* Now let's find out how much of the beginning of the line we can
+	 * reuse without modification.  */
+	verbatim_copy_end = bd.textstart;
+	verbatim_copy_width = bd.start_vcol;
+
+	/* If "bd.startspaces" is set, "bd.textstart" points to the character
+	 * preceding the block. We have to subtract its width to obtain its
+	 * column number.  */
+	if (bd.startspaces)
+	    verbatim_copy_width -= bd.start_char_vcols;
+	while (verbatim_copy_width < destination_col)
 	{
-	    i++;
-	    j -= p_ts;
+	    incr = lbr_chartabsize(verbatim_copy_end, verbatim_copy_width);
+	    if (verbatim_copy_width + incr > destination_col)
+		break;
+	    verbatim_copy_width += incr;
+	    mb_ptr_adv(verbatim_copy_end);
 	}
-	copy_chars(newp + bd.textcol, (size_t)i, TAB);
-	copy_spaces(newp + bd.textcol + i, (size_t)j);
 
-	/* the end */
-	STRMOVE(newp + STRLEN(newp), midp);
+	/* If "destination_col" is different from the width of the initial
+	 * part of the line that will be copied, it means we encountered a tab
+	 * character, which we will have to partly replace with spaces.  */
+	fill = destination_col - verbatim_copy_width;
+
+	/* The replacement line will consist of:
+	 * - the beginning of the original line up to "verbatim_copy_end",
+	 * - "fill" number of spaces,
+	 * - the rest of the line, pointed to by non_white.  */
+	new_line_len = (unsigned)(verbatim_copy_end - oldp)
+		       + fill
+		       + (unsigned)STRLEN(non_white) + 1;
+
+	newp = alloc_check(new_line_len);
+	if (newp == NULL)
+	    return;
+	mch_memmove(newp, oldp, (size_t)(verbatim_copy_end - oldp));
+	copy_spaces(newp + (verbatim_copy_end - oldp), (size_t)fill);
+	STRMOVE(newp + (verbatim_copy_end - oldp) + fill, non_white);
     }
     /* replace the line */
     ml_replace(curwin->w_cursor.lnum, newp, FALSE);
@@ -1122,6 +1143,8 @@
     return OK;
 }
 
+static int execreg_lastc = NUL;
+
 /*
  * execute a yank register: copy it into the stuff buffer
  *
@@ -1134,7 +1157,6 @@
     int	    addcr;		/* always add '\n' to end of line */
     int	    silent;		/* set "silent" flag in typeahead buffer */
 {
-    static int	lastc = NUL;
     long	i;
     char_u	*p;
     int		retval = OK;
@@ -1142,12 +1164,12 @@
 
     if (regname == '@')			/* repeat previous one */
     {
-	if (lastc == NUL)
+	if (execreg_lastc == NUL)
 	{
 	    EMSG(_("E748: No previously used register"));
 	    return FAIL;
 	}
-	regname = lastc;
+	regname = execreg_lastc;
     }
 					/* check for valid regname */
     if (regname == '%' || regname == '#' || !valid_yank_reg(regname, FALSE))
@@ -1155,7 +1177,7 @@
 	emsg_invreg(regname);
 	return FAIL;
     }
-    lastc = regname;
+    execreg_lastc = regname;
 
 #ifdef FEAT_CLIPBOARD
     regname = may_get_selection(regname);
@@ -2209,12 +2231,15 @@
     {
 	for (; pos.lnum <= oap->end.lnum; ++pos.lnum)
 	{
+	    int one_change;
+
 	    block_prep(oap, &bd, pos.lnum, FALSE);
 	    pos.col = bd.textcol;
-	    did_change = swapchars(oap->op_type, &pos, bd.textlen);
+	    one_change = swapchars(oap->op_type, &pos, bd.textlen);
+	    did_change |= one_change;
 
 # ifdef FEAT_NETBEANS_INTG
-	    if (usingNetbeans && did_change)
+	    if (usingNetbeans && one_change)
 	    {
 		char_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);
 
@@ -4848,7 +4873,8 @@
  * - textlen includes the first/last char to be (partly) deleted
  * - start/endspaces is the number of columns that are taken by the
  *   first/last deleted char minus the number of columns that have to be
- *   deleted.  for yank and tilde:
+ *   deleted.
+ * for yank and tilde:
  * - textlen includes the first/last char to be wholly yanked
  * - start/endspaces is the number of columns of the first/last yanked char
  *   that are to be yanked.
@@ -5312,11 +5338,14 @@
 
     /* We only get here (hopefully) if line[0] == '"' */
     str = virp->vir_line + 1;
+
+    /* If the line starts with "" this is the y_previous register. */
     if (*str == '"')
     {
 	set_prev = TRUE;
 	str++;
     }
+
     if (!ASCII_ISALNUM(*str) && *str != '-')
     {
 	if (viminfo_error("E577: ", _("Illegal register name"), virp->vir_line))
@@ -5326,6 +5355,14 @@
     get_yank_register(*str++, FALSE);
     if (!force && y_current->y_array != NULL)
 	do_it = FALSE;
+
+    if (*str == '@')
+    {
+	/* "x@: register x used for @@ */
+	if (force || execreg_lastc == NUL)
+	    execreg_lastc = str[-1];
+    }
+
     size = 0;
     limit = 100;	/* Optimized for registers containing <= 100 lines */
     if (do_it)
@@ -5335,7 +5372,7 @@
 	vim_free(y_current->y_array);
 	array = y_current->y_array =
 		       (char_u **)alloc((unsigned)(limit * sizeof(char_u *)));
-	str = skipwhite(str);
+	str = skipwhite(skiptowhite(str));
 	if (STRNCMP(str, "CHAR", 4) == 0)
 	    y_current->y_type = MCHAR;
 #ifdef FEAT_VISUAL
@@ -5418,6 +5455,7 @@
     max_kbyte = get_viminfo_parameter('s');
     if (max_kbyte == 0)
 	return;
+
     for (i = 0; i < NUM_REGISTERS; i++)
     {
 	if (y_regs[i].y_array == NULL)
@@ -5472,7 +5510,10 @@
 	if (y_previous == &y_regs[i])
 	    fprintf(fp, "\"");
 	c = get_register_name(i);
-	fprintf(fp, "\"%c\t%s\t%d\n", c, type,
+	fprintf(fp, "\"%c", c);
+	if (c == execreg_lastc)
+	    fprintf(fp, "@");
+	fprintf(fp, "\t%s\t%d\n", type,
 #ifdef FEAT_VISUAL
 		    (int)y_regs[i].y_width
 #else
@@ -6258,11 +6299,20 @@
 
 	    if (VIsual_mode == Ctrl_V)
 	    {
+#ifdef FEAT_LINEBREAK
+		char_u * saved_sbr = p_sbr;
+
+		/* Make 'sbr' empty for a moment to get the correct size. */
+		p_sbr = empty_option;
+#endif
 		oparg.is_VIsual = 1;
 		oparg.block_mode = TRUE;
 		oparg.op_type = OP_NOP;
 		getvcols(curwin, &min_pos, &max_pos,
 					  &oparg.start_vcol, &oparg.end_vcol);
+#ifdef FEAT_LINEBREAK
+		p_sbr = saved_sbr;
+#endif
 		if (curwin->w_curswant == MAXCOL)
 		    oparg.end_vcol = MAXCOL;
 		/* Swap the start, end vcol if needed */
@@ -6366,7 +6416,7 @@
 	    {
 		getvcols(curwin, &min_pos, &max_pos, &min_pos.col,
 								&max_pos.col);
-		sprintf((char *)buf1, _("%ld Cols; "),
+		vim_snprintf((char *)buf1, sizeof(buf1), _("%ld Cols; "),
 			(long)(oparg.end_vcol - oparg.start_vcol + 1));
 	    }
 	    else
@@ -6374,13 +6424,15 @@
 
 	    if (char_count_cursor == byte_count_cursor
 						  && char_count == byte_count)
-		sprintf((char *)IObuff, _("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+			_("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
 			buf1, line_count_selected,
 			(long)curbuf->b_ml.ml_line_count,
 			word_count_cursor, word_count,
 			byte_count_cursor, byte_count);
 	    else
-		sprintf((char *)IObuff, _("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+			_("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
 			buf1, line_count_selected,
 			(long)curbuf->b_ml.ml_line_count,
 			word_count_cursor, word_count,
@@ -6392,20 +6444,22 @@
 	{
 	    p = ml_get_curline();
 	    validate_virtcol();
-	    col_print(buf1, (int)curwin->w_cursor.col + 1,
+	    col_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,
 		    (int)curwin->w_virtcol + 1);
-	    col_print(buf2, (int)STRLEN(p), linetabsize(p));
+	    col_print(buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));
 
 	    if (char_count_cursor == byte_count_cursor
 		    && char_count == byte_count)
-		sprintf((char *)IObuff, _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+		    _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
 		    (char *)buf1, (char *)buf2,
 		    (long)curwin->w_cursor.lnum,
 		    (long)curbuf->b_ml.ml_line_count,
 		    word_count_cursor, word_count,
 		    byte_count_cursor, byte_count);
 	    else
-		sprintf((char *)IObuff, _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+		    _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
 		    (char *)buf1, (char *)buf2,
 		    (long)curwin->w_cursor.lnum,
 		    (long)curbuf->b_ml.ml_line_count,
diff -Naur vim72.orig/src/option.c vim72/src/option.c
--- vim72.orig/src/option.c	2008-07-18 06:05:33.000000000 -0700
+++ vim72/src/option.c	2009-06-05 14:25:15.000000000 -0700
@@ -387,6 +387,9 @@
     char_u	*def_val[2];	/* default values for variable (vi and vim) */
 #ifdef FEAT_EVAL
     scid_T	scriptID;	/* script in which the option was last set */
+# define SCRIPTID_INIT , 0
+#else
+# define SCRIPTID_INIT
 #endif
 };
 
@@ -477,7 +480,7 @@
 #else
 			    (char_u *)224L,
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"antialias",   "anti", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
 #if defined(FEAT_GUI) && defined(MACOS_X)
 			    (char_u *)&p_antialias, PV_NONE,
@@ -486,35 +489,35 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)FALSE}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"arabic",	    "arab", P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_ARABIC
 			    (char_u *)VAR_WIN, PV_ARAB,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"arabicshape", "arshape", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
 #ifdef FEAT_ARABIC
 			    (char_u *)&p_arshape, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"allowrevins", "ari",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_ari, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"altkeymap",   "akm",  P_BOOL|P_VI_DEF,
 #ifdef FEAT_FKMAP
 			    (char_u *)&p_altkeymap, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"ambiwidth",  "ambw",  P_STRING|P_VI_DEF|P_RCLR,
 #if defined(FEAT_MBYTE)
 			    (char_u *)&p_ambw, PV_NONE,
@@ -523,27 +526,27 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
 #ifdef FEAT_AUTOCHDIR
     {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_acd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
 #endif
     {"autoindent",  "ai",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ai, PV_AI,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autoprint",   "ap",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autoread",    "ar",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ar, PV_AR,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autowrite",   "aw",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_aw, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autowriteall","awa",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_awa, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"background",  "bg",   P_STRING|P_VI_DEF|P_RCLR,
 			    (char_u *)&p_bg, PV_NONE,
 			    {
@@ -552,13 +555,13 @@
 #else
 			    (char_u *)"light",
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"backspace",   "bs",   P_STRING|P_VI_DEF|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_bs, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"backup",	    "bk",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_bk, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"backupcopy",  "bkc",  P_STRING|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_bkc, PV_NONE,
 #ifdef UNIX
@@ -566,10 +569,10 @@
 #else
 			    {(char_u *)"auto", (char_u *)"auto"}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"backupdir",   "bdir", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
 			    (char_u *)&p_bdir, PV_NONE,
-			    {(char_u *)DFLT_BDIR, (char_u *)0L}},
+			    {(char_u *)DFLT_BDIR, (char_u *)0L} SCRIPTID_INIT},
     {"backupext",   "bex",  P_STRING|P_VI_DEF|P_NFNAME,
 			    (char_u *)&p_bex, PV_NONE,
 			    {
@@ -578,7 +581,7 @@
 #else
 			    (char_u *)"~",
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"backupskip",  "bsk",  P_STRING|P_VI_DEF|P_COMMA,
 #ifdef FEAT_WILDIGN
 			    (char_u *)&p_bsk, PV_NONE,
@@ -587,40 +590,40 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
 #ifdef FEAT_BEVAL
     {"balloondelay","bdlay",P_NUM|P_VI_DEF,
 			    (char_u *)&p_bdlay, PV_NONE,
-			    {(char_u *)600L, (char_u *)0L}},
+			    {(char_u *)600L, (char_u *)0L} SCRIPTID_INIT},
     {"ballooneval", "beval",P_BOOL|P_VI_DEF|P_NO_MKRC,
 			    (char_u *)&p_beval, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
 # ifdef FEAT_EVAL
     {"balloonexpr", "bexpr", P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
 			    (char_u *)&p_bexpr, PV_BEXPR,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
 # endif
 #endif
     {"beautify",    "bf",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"binary",	    "bin",  P_BOOL|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_bin, PV_BIN,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"bioskey",	    "biosk",P_BOOL|P_VI_DEF,
 #ifdef MSDOS
 			    (char_u *)&p_biosk, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"bomb",	    NULL,   P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_bomb, PV_BOMB,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"breakat",	    "brk",  P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)&p_breakat, PV_NONE,
@@ -629,7 +632,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"browsedir",   "bsdir",P_STRING|P_VI_DEF,
 #ifdef FEAT_BROWSE
 			    (char_u *)&p_bsdir, PV_NONE,
@@ -638,7 +641,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"bufhidden",   "bh",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
 #if defined(FEAT_QUICKFIX)
 			    (char_u *)&p_bh, PV_BH,
@@ -647,11 +650,11 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"buflisted",   "bl",   P_BOOL|P_VI_DEF|P_NOGLOB,
 			    (char_u *)&p_bl, PV_BL,
 			    {(char_u *)1L, (char_u *)0L}
-			    },
+			    SCRIPTID_INIT},
     {"buftype",	    "bt",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
 #if defined(FEAT_QUICKFIX)
 			    (char_u *)&p_bt, PV_BT,
@@ -660,7 +663,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"casemap",	    "cmp",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_cmp, PV_NONE,
@@ -669,7 +672,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cdpath",	    "cd",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SEARCHPATH
 			    (char_u *)&p_cdpath, PV_NONE,
@@ -678,7 +681,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cedit",	    NULL,   P_STRING,
 #ifdef FEAT_CMDWIN
 			    (char_u *)&p_cedit, PV_NONE,
@@ -687,7 +690,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"charconvert",  "ccv", P_STRING|P_VI_DEF|P_SECURE,
 #if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
 			    (char_u *)&p_ccv, PV_NONE,
@@ -696,14 +699,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cindent",	    "cin",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_CINDENT
 			    (char_u *)&p_cin, PV_CIN,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"cinkeys",	    "cink", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_CINDENT
 			    (char_u *)&p_cink, PV_CINK,
@@ -712,14 +715,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cinoptions",  "cino", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_CINDENT
 			    (char_u *)&p_cino, PV_CINO,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"cinwords",    "cinw", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
 			    (char_u *)&p_cinw, PV_CINW,
@@ -729,7 +732,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"clipboard",   "cb",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_CLIPBOARD
 			    (char_u *)&p_cb, PV_NONE,
@@ -743,20 +746,20 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cmdheight",   "ch",   P_NUM|P_VI_DEF|P_RALL,
 			    (char_u *)&p_ch, PV_NONE,
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"cmdwinheight", "cwh", P_NUM|P_VI_DEF,
 #ifdef FEAT_CMDWIN
 			    (char_u *)&p_cwh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)7L, (char_u *)0L}},
+			    {(char_u *)7L, (char_u *)0L} SCRIPTID_INIT},
     {"columns",	    "co",   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
 			    (char_u *)&Columns, PV_NONE,
-			    {(char_u *)80L, (char_u *)0L}},
+			    {(char_u *)80L, (char_u *)0L} SCRIPTID_INIT},
     {"comments",    "com",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_COMMENTS
 			    (char_u *)&p_com, PV_COM,
@@ -766,7 +769,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"commentstring", "cms", P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_FOLDING
 			    (char_u *)&p_cms, PV_CMS,
@@ -775,12 +778,12 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
 			    /* P_PRI_MKRC isn't needed here, optval_default()
 			     * always returns TRUE for 'compatible' */
     {"compatible",  "cp",   P_BOOL|P_RALL,
 			    (char_u *)&p_cp, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)FALSE}},
+			    {(char_u *)TRUE, (char_u *)FALSE} SCRIPTID_INIT},
     {"complete",    "cpt",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_cpt, PV_CPT,
@@ -789,7 +792,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"completefunc", "cfu", P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
 #ifdef FEAT_COMPL_FUNC
 			    (char_u *)&p_cfu, PV_CFU,
@@ -798,7 +801,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"completeopt",   "cot",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_cot, PV_NONE,
@@ -807,34 +810,35 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"confirm",     "cf",   P_BOOL|P_VI_DEF,
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 			    (char_u *)&p_confirm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"conskey",	    "consk",P_BOOL|P_VI_DEF,
 #ifdef MSDOS
 			    (char_u *)&p_consk, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"copyindent",  "ci",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_ci, PV_CI,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"cpoptions",   "cpo",  P_STRING|P_VIM|P_RALL|P_FLAGLIST,
 			    (char_u *)&p_cpo, PV_NONE,
-			    {(char_u *)CPO_VI, (char_u *)CPO_VIM}},
+			    {(char_u *)CPO_VI, (char_u *)CPO_VIM}
+			    SCRIPTID_INIT},
     {"cscopepathcomp", "cspc", P_NUM|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_cspc, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cscopeprg",   "csprg", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_csprg, PV_NONE,
@@ -843,7 +847,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cscopequickfix", "csqf", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)
 			    (char_u *)&p_csqf, PV_NONE,
@@ -852,45 +856,45 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cscopetag",   "cst",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_cst, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cscopetagorder", "csto", P_NUM|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_csto, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cscopeverbose", "csverb", P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_csverbose, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cursorcolumn", "cuc", P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_SYN_HL
 			    (char_u *)VAR_WIN, PV_CUC,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"cursorline",   "cul", P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_SYN_HL
 			    (char_u *)VAR_WIN, PV_CUL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"debug",	    NULL,   P_STRING|P_VI_DEF,
 			    (char_u *)&p_debug, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"define",	    "def",  P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_FIND_ID
 			    (char_u *)&p_def, PV_DEF,
@@ -899,28 +903,28 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"delcombine", "deco",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_deco, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_dict, PV_DICT,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"diff",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN|P_NOGLOB,
 #ifdef FEAT_DIFF
 			    (char_u *)VAR_WIN, PV_DIFF,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"diffexpr",    "dex",  P_STRING|P_VI_DEF|P_SECURE,
 #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
 			    (char_u *)&p_dex, PV_NONE,
@@ -929,7 +933,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"diffopt",	    "dip",  P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN|P_COMMA|P_NODUP,
 #ifdef FEAT_DIFF
 			    (char_u *)&p_dip, PV_NONE,
@@ -938,20 +942,20 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)NULL}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"digraph",	    "dg",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_DIGRAPHS
 			    (char_u *)&p_dg, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"directory",   "dir",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
 			    (char_u *)&p_dir, PV_NONE,
-			    {(char_u *)DFLT_DIR, (char_u *)0L}},
+			    {(char_u *)DFLT_DIR, (char_u *)0L} SCRIPTID_INIT},
     {"display",	    "dy",   P_STRING|P_VI_DEF|P_COMMA|P_RALL|P_NODUP,
 			    (char_u *)&p_dy, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"eadirection", "ead",  P_STRING|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_ead, PV_NONE,
@@ -960,10 +964,10 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"edcompatible","ed",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ed, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"encoding",    "enc",  P_STRING|P_VI_DEF|P_RCLR,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_enc, PV_NONE,
@@ -972,19 +976,19 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"endofline",   "eol",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_eol, PV_EOL,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"equalalways", "ea",   P_BOOL|P_VI_DEF|P_RALL,
 			    (char_u *)&p_ea, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"equalprg",    "ep",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_ep, PV_EP,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"errorbells",  "eb",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_eb, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"errorfile",   "ef",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_ef, PV_NONE,
@@ -993,32 +997,32 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"errorformat", "efm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_efm, PV_EFM,
-			    {(char_u *)DFLT_EFM, (char_u *)0L},
+			    {(char_u *)DFLT_EFM, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"esckeys",	    "ek",   P_BOOL|P_VIM,
 			    (char_u *)&p_ek, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"eventignore", "ei",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_AUTOCMD
 			    (char_u *)&p_ei, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"expandtab",   "et",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_et, PV_ET,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"exrc",	    "ex",   P_BOOL|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_exrc, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"fileencoding","fenc", P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_RBUF|P_NO_MKRC,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_fenc, PV_FENC,
@@ -1027,7 +1031,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fileencodings","fencs", P_STRING|P_VI_DEF|P_COMMA,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_fencs, PV_NONE,
@@ -1036,13 +1040,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fileformat",  "ff",   P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_NO_MKRC,
 			    (char_u *)&p_ff, PV_FF,
-			    {(char_u *)DFLT_FF, (char_u *)0L}},
+			    {(char_u *)DFLT_FF, (char_u *)0L} SCRIPTID_INIT},
     {"fileformats", "ffs",  P_STRING|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_ffs, PV_NONE,
-			    {(char_u *)DFLT_FFS_VI, (char_u *)DFLT_FFS_VIM}},
+			    {(char_u *)DFLT_FFS_VI, (char_u *)DFLT_FFS_VIM}
+			    SCRIPTID_INIT},
     {"filetype",    "ft",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
 #ifdef FEAT_AUTOCMD
 			    (char_u *)&p_ft, PV_FT,
@@ -1051,7 +1056,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fillchars",   "fcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
 #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
 			    (char_u *)&p_fcs, PV_NONE,
@@ -1060,27 +1065,27 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fkmap",	    "fk",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_FKMAP
 			    (char_u *)&p_fkmap, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"flash",	    "fl",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
 #ifdef FEAT_FOLDING
     {"foldclose",   "fcl",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP|P_RWIN,
 			    (char_u *)&p_fcl, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"foldcolumn",  "fdc",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDC,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"foldenable",  "fen",  P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FEN,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"foldexpr",    "fde",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 # ifdef FEAT_EVAL
 			    (char_u *)VAR_WIN, PV_FDE,
@@ -1089,33 +1094,34 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 # endif
-			    },
+			    SCRIPTID_INIT},
     {"foldignore",  "fdi",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDI,
-			    {(char_u *)"#", (char_u *)NULL}},
+			    {(char_u *)"#", (char_u *)NULL} SCRIPTID_INIT},
     {"foldlevel",   "fdl",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDL,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"foldlevelstart","fdls", P_NUM|P_VI_DEF,
 			    (char_u *)&p_fdls, PV_NONE,
-			    {(char_u *)-1L, (char_u *)0L}},
+			    {(char_u *)-1L, (char_u *)0L} SCRIPTID_INIT},
     {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
 						       P_RWIN|P_COMMA|P_NODUP,
 			    (char_u *)VAR_WIN, PV_FMR,
-			    {(char_u *)"{{{,}}}", (char_u *)NULL}},
+			    {(char_u *)"{{{,}}}", (char_u *)NULL}
+			    SCRIPTID_INIT},
     {"foldmethod",  "fdm",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDM,
-			    {(char_u *)"manual", (char_u *)NULL}},
+			    {(char_u *)"manual", (char_u *)NULL} SCRIPTID_INIT},
     {"foldminlines","fml",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FML,
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"foldnestmax", "fdn",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDN,
-			    {(char_u *)20L, (char_u *)0L}},
+			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
     {"foldopen",    "fdo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_fdo, PV_NONE,
 		 {(char_u *)"block,hor,mark,percent,quickfix,search,tag,undo",
-							       (char_u *)0L}},
+						 (char_u *)0L} SCRIPTID_INIT},
     {"foldtext",    "fdt",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 # ifdef FEAT_EVAL
 			    (char_u *)VAR_WIN, PV_FDT,
@@ -1124,7 +1130,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 # endif
-			    },
+			    SCRIPTID_INIT},
 #endif
     {"formatexpr", "fex",   P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
 #ifdef FEAT_EVAL
@@ -1134,16 +1140,18 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"formatoptions","fo",  P_STRING|P_ALLOCED|P_VIM|P_FLAGLIST,
 			    (char_u *)&p_fo, PV_FO,
-			    {(char_u *)DFLT_FO_VI, (char_u *)DFLT_FO_VIM}},
+			    {(char_u *)DFLT_FO_VI, (char_u *)DFLT_FO_VIM}
+			    SCRIPTID_INIT},
     {"formatlistpat","flp", P_STRING|P_ALLOCED|P_VI_DEF,
 			    (char_u *)&p_flp, PV_FLP,
-			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*", (char_u *)0L}},
+			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*",
+						 (char_u *)0L} SCRIPTID_INIT},
     {"formatprg",   "fp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_fp, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"fsync",       "fs",   P_BOOL|P_SECURE|P_VI_DEF,
 #ifdef HAVE_FSYNC
 			    (char_u *)&p_fs, PV_NONE,
@@ -1152,22 +1160,22 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_gd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"graphic",	    "gr",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"grepformat",  "gfm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_gefm, PV_NONE,
-			    {(char_u *)DFLT_GREPFORMAT, (char_u *)0L},
+			    {(char_u *)DFLT_GREPFORMAT, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"grepprg",	    "gp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_gp, PV_GP,
@@ -1185,15 +1193,15 @@
 			    (char_u *)"SEARCH/NUMBERS ",
 #   else
 			    (char_u *)"grep -n ",
-#endif
-#endif
+#   endif
+#  endif
 # endif
-			    (char_u *)0L},
+			    (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"guicursor",    "gcr",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef CURSOR_SHAPE
 			    (char_u *)&p_guicursor, PV_NONE,
@@ -1208,7 +1216,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guifont",	    "gfn",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
 #ifdef FEAT_GUI
 			    (char_u *)&p_guifont, PV_NONE,
@@ -1217,7 +1225,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guifontset",  "gfs",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA,
 #if defined(FEAT_GUI) && defined(FEAT_XFONTSET)
 			    (char_u *)&p_guifontset, PV_NONE,
@@ -1226,7 +1234,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guifontwide", "gfw",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
 #if defined(FEAT_GUI) && defined(FEAT_MBYTE)
 			    (char_u *)&p_guifontwide, PV_NONE,
@@ -1235,14 +1243,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guiheadroom", "ghr",  P_NUM|P_VI_DEF,
 #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
 			    (char_u *)&p_ghr, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)50L, (char_u *)0L}},
+			    {(char_u *)50L, (char_u *)0L} SCRIPTID_INIT},
     {"guioptions",  "go",   P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
 #if defined(FEAT_GUI)
 			    (char_u *)&p_go, PV_NONE,
@@ -1255,14 +1263,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guipty",	    NULL,   P_BOOL|P_VI_DEF,
 #if defined(FEAT_GUI)
 			    (char_u *)&p_guipty, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"guitablabel",  "gtl", P_STRING|P_VI_DEF|P_RWIN,
 #if defined(FEAT_GUI_TABLINE)
 			    (char_u *)&p_gtl, PV_NONE,
@@ -1271,7 +1279,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guitabtooltip",  "gtt", P_STRING|P_VI_DEF|P_RWIN,
 #if defined(FEAT_GUI_TABLINE)
 			    (char_u *)&p_gtt, PV_NONE,
@@ -1280,20 +1288,21 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"hardtabs",    "ht",   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"helpfile",    "hf",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_hf, PV_NONE,
-			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}},
+			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"helpheight",  "hh",   P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_hh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)20L, (char_u *)0L}},
+			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
     {"helplang",    "hlg",  P_STRING|P_VI_DEF|P_COMMA,
 #ifdef FEAT_MULTI_LANG
 			    (char_u *)&p_hlg, PV_NONE,
@@ -1302,64 +1311,65 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"hidden",	    "hid",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_hid, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"highlight",   "hl",   P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
 			    (char_u *)&p_hl, PV_NONE,
-			    {(char_u *)HIGHLIGHT_INIT, (char_u *)0L}},
+			    {(char_u *)HIGHLIGHT_INIT, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"history",	    "hi",   P_NUM|P_VIM,
 			    (char_u *)&p_hi, PV_NONE,
-			    {(char_u *)0L, (char_u *)20L}},
+			    {(char_u *)0L, (char_u *)20L} SCRIPTID_INIT},
     {"hkmap",	    "hk",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_hkmap, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"hkmapp",	    "hkp",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_hkmapp, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"hlsearch",    "hls",  P_BOOL|P_VI_DEF|P_VIM|P_RALL,
 			    (char_u *)&p_hls, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"icon",	    NULL,   P_BOOL|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_icon, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"iconstring",  NULL,   P_STRING|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_iconstring, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"ignorecase",  "ic",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ic, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"imactivatekey","imak",P_STRING|P_VI_DEF,
 #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
 			    (char_u *)&p_imak, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"imcmdline",   "imc",  P_BOOL|P_VI_DEF,
 #ifdef USE_IM_CONTROL
 			    (char_u *)&p_imcmdline, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"imdisable",   "imd",  P_BOOL|P_VI_DEF,
 #ifdef USE_IM_CONTROL
 			    (char_u *)&p_imdisable, PV_NONE,
@@ -1371,7 +1381,7 @@
 #else
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"iminsert",    "imi",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_iminsert, PV_IMI,
 #ifdef B_IMODE_IM
@@ -1379,7 +1389,7 @@
 #else
 			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"imsearch",    "ims",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_imsearch, PV_IMS,
 #ifdef B_IMODE_IM
@@ -1387,7 +1397,7 @@
 #else
 			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"include",	    "inc",  P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_FIND_ID
 			    (char_u *)&p_inc, PV_INC,
@@ -1396,7 +1406,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"includeexpr", "inex", P_STRING|P_ALLOCED|P_VI_DEF,
 #if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
 			    (char_u *)&p_inex, PV_INEX,
@@ -1405,10 +1415,10 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"incsearch",   "is",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_is, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"indentexpr", "inde",  P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
 #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
 			    (char_u *)&p_inde, PV_INDE,
@@ -1417,7 +1427,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"indentkeys", "indk",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
 			    (char_u *)&p_indk, PV_INDK,
@@ -1426,13 +1436,13 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"infercase",   "inf",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_inf, PV_INF,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"insertmode",  "im",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_im, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"isfname",	    "isf",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_isf, PV_NONE,
 			    {
@@ -1455,7 +1465,7 @@
 #  endif
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"isident",	    "isi",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_isi, PV_NONE,
 			    {
@@ -1472,7 +1482,7 @@
 			    (char_u *)"@,48-57,_,192-255",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"iskeyword",   "isk",  P_STRING|P_ALLOCED|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_isk, PV_ISK,
 			    {
@@ -1491,7 +1501,7 @@
 				ISK_LATIN1
 # endif
 #endif
-				}},
+			    } SCRIPTID_INIT},
     {"isprint",	    "isp",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
 			    (char_u *)&p_isp, PV_NONE,
 			    {
@@ -1507,10 +1517,10 @@
 			    ISP_LATIN1,
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"joinspaces",  "js",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_js, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"key",	    NULL,   P_STRING|P_ALLOCED|P_VI_DEF|P_NO_MKRC,
 #ifdef FEAT_CRYPT
 			    (char_u *)&p_key, PV_KEY,
@@ -1519,7 +1529,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME|P_PRI_MKRC,
 #ifdef FEAT_KEYMAP
 			    (char_u *)&p_keymap, PV_KMAP,
@@ -1528,14 +1538,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-	},
+			    SCRIPTID_INIT},
     {"keymodel",    "km",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_VISUAL
 			    (char_u *)&p_km, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_kp, PV_KP,
 			    {
@@ -1556,7 +1566,7 @@
 # endif
 #endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"langmap",     "lmap", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_LANGMAP
 			    (char_u *)&p_langmap, PV_NONE,
@@ -1565,31 +1575,31 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"langmenu",    "lm",   P_STRING|P_VI_DEF|P_NFNAME,
 #if defined(FEAT_MENU) && defined(FEAT_MULTI_LANG)
 			    (char_u *)&p_lm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"laststatus",  "ls",   P_NUM|P_VI_DEF|P_RALL,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_ls, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"lazyredraw",  "lz",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_lz, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"linebreak",   "lbr",  P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)VAR_WIN, PV_LBR,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"lines",	    NULL,   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
 			    (char_u *)&Rows, PV_NONE,
 			    {
@@ -1598,7 +1608,7 @@
 #else
 			    (char_u *)24L,
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"linespace",   "lsp",  P_NUM|P_VI_DEF|P_RCLR,
 #ifdef FEAT_GUI
 			    (char_u *)&p_linespace, PV_NONE,
@@ -1610,14 +1620,14 @@
 #else
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"lisp",	    NULL,   P_BOOL|P_VI_DEF,
 #ifdef FEAT_LISP
 			    (char_u *)&p_lisp, PV_LISP,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"lispwords",   "lw",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_LISP
 			    (char_u *)&p_lispwords, PV_NONE,
@@ -1626,24 +1636,24 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"list",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_LIST,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"listchars",   "lcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
 			    (char_u *)&p_lcs, PV_NONE,
-			    {(char_u *)"eol:$", (char_u *)0L}},
+			    {(char_u *)"eol:$", (char_u *)0L} SCRIPTID_INIT},
     {"loadplugins", "lpl",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_lpl, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
 #ifdef FEAT_GUI_MAC
     {"macatsui",    NULL,   P_BOOL|P_VI_DEF|P_RCLR,
 			    (char_u *)&p_macatsui, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
 #endif
     {"magic",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_magic, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"makeef",	    "mef",  P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_mef, PV_NONE,
@@ -1652,7 +1662,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"makeprg",	    "mp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_mp, PV_MP,
@@ -1665,49 +1675,52 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"matchpairs",  "mps",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_mps, PV_MPS,
-			    {(char_u *)"(:),{:},[:]", (char_u *)0L}},
+			    {(char_u *)"(:),{:},[:]", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"matchtime",   "mat",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mat, PV_NONE,
-			    {(char_u *)5L, (char_u *)0L}},
+			    {(char_u *)5L, (char_u *)0L} SCRIPTID_INIT},
     {"maxcombine",  "mco",  P_NUM|P_VI_DEF,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_mco, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)2, (char_u *)0L}},
+			    {(char_u *)2, (char_u *)0L} SCRIPTID_INIT},
     {"maxfuncdepth", "mfd", P_NUM|P_VI_DEF,
 #ifdef FEAT_EVAL
 			    (char_u *)&p_mfd, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)100L, (char_u *)0L}},
+			    {(char_u *)100L, (char_u *)0L} SCRIPTID_INIT},
     {"maxmapdepth", "mmd",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mmd, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
+			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
     {"maxmem",	    "mm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_mm, PV_NONE,
-			    {(char_u *)DFLT_MAXMEM, (char_u *)0L}},
+			    {(char_u *)DFLT_MAXMEM, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"maxmempattern","mmp", P_NUM|P_VI_DEF,
 			    (char_u *)&p_mmp, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
+			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
     {"maxmemtot",   "mmt",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mmt, PV_NONE,
-			    {(char_u *)DFLT_MAXMEMTOT, (char_u *)0L}},
+			    {(char_u *)DFLT_MAXMEMTOT, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"menuitems",   "mis",  P_NUM|P_VI_DEF,
 #ifdef FEAT_MENU
 			    (char_u *)&p_mis, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)25L, (char_u *)0L}},
+			    {(char_u *)25L, (char_u *)0L} SCRIPTID_INIT},
     {"mesg",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"mkspellmem",  "msm",  P_STRING|P_VI_DEF|P_EXPAND|P_SECURE,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_msm, PV_NONE,
@@ -1716,22 +1729,22 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"modeline",    "ml",   P_BOOL|P_VIM,
 			    (char_u *)&p_ml, PV_ML,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"modelines",   "mls",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mls, PV_NONE,
-			    {(char_u *)5L, (char_u *)0L}},
+			    {(char_u *)5L, (char_u *)0L} SCRIPTID_INIT},
     {"modifiable",  "ma",   P_BOOL|P_VI_DEF|P_NOGLOB,
 			    (char_u *)&p_ma, PV_MA,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"modified",    "mod",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_mod, PV_MOD,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"more",	    NULL,   P_BOOL|P_VIM,
 			    (char_u *)&p_more, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"mouse",	    NULL,   P_STRING|P_VI_DEF|P_FLAGLIST,
 			    (char_u *)&p_mouse, PV_NONE,
 			    {
@@ -1740,21 +1753,21 @@
 #else
 				(char_u *)"",
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"mousefocus",   "mousef", P_BOOL|P_VI_DEF,
 #ifdef FEAT_GUI
 			    (char_u *)&p_mousef, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"mousehide",   "mh",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_GUI
 			    (char_u *)&p_mh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"mousemodel",  "mousem", P_STRING|P_VI_DEF,
 			    (char_u *)&p_mousem, PV_NONE,
 			    {
@@ -1767,7 +1780,7 @@
 				(char_u *)"extend",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"mouseshape",  "mouses",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_MOUSESHAPE
 			    (char_u *)&p_mouseshape, PV_NONE,
@@ -1776,33 +1789,34 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"mousetime",   "mouset",	P_NUM|P_VI_DEF,
 			    (char_u *)&p_mouset, PV_NONE,
-			    {(char_u *)500L, (char_u *)0L}},
+			    {(char_u *)500L, (char_u *)0L} SCRIPTID_INIT},
     {"mzquantum",  "mzq",   P_NUM,
 #ifdef FEAT_MZSCHEME
 			    (char_u *)&p_mzq, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)100L, (char_u *)100L}},
+			    {(char_u *)100L, (char_u *)100L} SCRIPTID_INIT},
     {"novice",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"nrformats",   "nf",   P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_nf, PV_NF,
-			    {(char_u *)"octal,hex", (char_u *)0L}},
+			    {(char_u *)"octal,hex", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"number",	    "nu",   P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_NU,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"numberwidth", "nuw",  P_NUM|P_RWIN|P_VIM,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)VAR_WIN, PV_NUW,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)8L, (char_u *)4L}},
+			    {(char_u *)8L, (char_u *)4L} SCRIPTID_INIT},
     {"omnifunc",    "ofu",  P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
 #ifdef FEAT_COMPL_FUNC
 			    (char_u *)&p_ofu, PV_OFU,
@@ -1811,10 +1825,10 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"open",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"opendevice",  "odev", P_BOOL|P_VI_DEF,
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
 			    (char_u *)&p_odev, PV_NONE,
@@ -1822,13 +1836,13 @@
 			    (char_u *)NULL, PV_NONE,
 #endif
 			    {(char_u *)FALSE, (char_u *)FALSE}
-			    },
+			    SCRIPTID_INIT},
     {"operatorfunc", "opfunc", P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_opfunc, PV_NONE,
-			    {(char_u *)"", (char_u *)0L} },
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"optimize",    "opt",  P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"osfiletype",  "oft",  P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_OSFILETYPE
 			    (char_u *)&p_oft, PV_OFT,
@@ -1837,17 +1851,17 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"paragraphs",  "para", P_STRING|P_VI_DEF,
 			    (char_u *)&p_para, PV_NONE,
 			    {(char_u *)"IPLPPPQPP TPHPLIPpLpItpplpipbp",
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"paste",	    NULL,   P_BOOL|P_VI_DEF|P_PRI_MKRC,
 			    (char_u *)&p_paste, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
 			    (char_u *)&p_pt, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"patchexpr",   "pex",  P_STRING|P_VI_DEF|P_SECURE,
 #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
 			    (char_u *)&p_pex, PV_NONE,
@@ -1856,10 +1870,10 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"patchmode",   "pm",   P_STRING|P_VI_DEF|P_NFNAME,
 			    (char_u *)&p_pm, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"path",	    "pa",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_path, PV_PATH,
 			    {
@@ -1872,24 +1886,24 @@
 			    (char_u *)".,/usr/include,,",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"preserveindent", "pi", P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_pi, PV_PI,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"previewheight", "pvh", P_NUM|P_VI_DEF,
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 			    (char_u *)&p_pvh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)12L, (char_u *)0L}},
+			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
     {"previewwindow", "pvw", P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 			    (char_u *)VAR_WIN, PV_PVW,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"printdevice", "pdev", P_STRING|P_VI_DEF|P_SECURE,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_pdev, PV_NONE,
@@ -1898,7 +1912,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printencoding", "penc", P_STRING|P_VI_DEF,
 #ifdef FEAT_POSTSCRIPT
 			    (char_u *)&p_penc, PV_NONE,
@@ -1907,7 +1921,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printexpr", "pexpr",  P_STRING|P_VI_DEF,
 #ifdef FEAT_POSTSCRIPT
 			    (char_u *)&p_pexpr, PV_NONE,
@@ -1916,7 +1930,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printfont", "pfn",    P_STRING|P_VI_DEF,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_pfn, PV_NONE,
@@ -1931,7 +1945,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printheader", "pheader",  P_STRING|P_VI_DEF|P_GETTEXT,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_header, PV_NONE,
@@ -1940,7 +1954,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
    {"printmbcharset", "pmbcs",  P_STRING|P_VI_DEF,
 #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
 			    (char_u *)&p_pmcs, PV_NONE,
@@ -1949,7 +1963,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printmbfont", "pmbfn",  P_STRING|P_VI_DEF,
 #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
 			    (char_u *)&p_pmfn, PV_NONE,
@@ -1958,7 +1972,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printoptions", "popt", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_popt, PV_NONE,
@@ -1967,17 +1981,17 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"prompt",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_prompt, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"pumheight",   "ph",   P_NUM|P_VI_DEF,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_ph, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"quoteescape", "qe",   P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_TEXTOBJ
 			    (char_u *)&p_qe, PV_QE,
@@ -1986,47 +2000,47 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"readonly",    "ro",   P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
 			    (char_u *)&p_ro, PV_RO,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"redraw",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"redrawtime",  "rdt",  P_NUM|P_VI_DEF,
 #ifdef FEAT_RELTIME
 			    (char_u *)&p_rdt, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)2000L, (char_u *)0L}},
+			    {(char_u *)2000L, (char_u *)0L} SCRIPTID_INIT},
     {"remap",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_remap, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"report",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)&p_report, PV_NONE,
-			    {(char_u *)2L, (char_u *)0L}},
+			    {(char_u *)2L, (char_u *)0L} SCRIPTID_INIT},
     {"restorescreen", "rs", P_BOOL|P_VI_DEF,
 #ifdef WIN3264
 			    (char_u *)&p_rs, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"revins",	    "ri",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_ri, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"rightleft",   "rl",   P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)VAR_WIN, PV_RL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"rightleftcmd", "rlc", P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)VAR_WIN, PV_RLC,
@@ -2035,40 +2049,41 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"ruler",	    "ru",   P_BOOL|P_VI_DEF|P_VIM|P_RSTAT,
 #ifdef FEAT_CMDL_INFO
 			    (char_u *)&p_ru, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"rulerformat", "ruf",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
 #ifdef FEAT_STL_OPT
 			    (char_u *)&p_ruf, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"runtimepath", "rtp",  P_STRING|P_VI_DEF|P_EXPAND|P_COMMA|P_NODUP|P_SECURE,
 			    (char_u *)&p_rtp, PV_NONE,
-			    {(char_u *)DFLT_RUNTIMEPATH, (char_u *)0L}},
+			    {(char_u *)DFLT_RUNTIMEPATH, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"scroll",	    "scr",  P_NUM|P_NO_MKRC|P_VI_DEF,
 			    (char_u *)VAR_WIN, PV_SCROLL,
-			    {(char_u *)12L, (char_u *)0L}},
+			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
     {"scrollbind",  "scb",  P_BOOL|P_VI_DEF,
 #ifdef FEAT_SCROLLBIND
 			    (char_u *)VAR_WIN, PV_SCBIND,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"scrolljump",  "sj",   P_NUM|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sj, PV_NONE,
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"scrolloff",   "so",   P_NUM|P_VI_DEF|P_VIM|P_RALL,
 			    (char_u *)&p_so, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"scrollopt",   "sbo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SCROLLBIND
 			    (char_u *)&p_sbo, PV_NONE,
@@ -2077,27 +2092,29 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"sections",    "sect", P_STRING|P_VI_DEF,
 			    (char_u *)&p_sections, PV_NONE,
-			    {(char_u *)"SHNHH HUnhsh", (char_u *)0L}},
+			    {(char_u *)"SHNHH HUnhsh", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"secure",	    NULL,   P_BOOL|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_secure, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"selection",   "sel",  P_STRING|P_VI_DEF,
 #ifdef FEAT_VISUAL
 			    (char_u *)&p_sel, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"inclusive", (char_u *)0L}},
+			    {(char_u *)"inclusive", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"selectmode",  "slm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_VISUAL
 			    (char_u *)&p_slm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"sessionoptions", "ssop", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SESSION
 			    (char_u *)&p_ssop, PV_NONE,
@@ -2107,7 +2124,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"shell",	    "sh",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_sh, PV_NONE,
 			    {
@@ -2136,7 +2153,7 @@
 #  endif
 # endif
 #endif /* VMS */
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"shellcmdflag","shcf", P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_shcf, PV_NONE,
 			    {
@@ -2149,7 +2166,7 @@
 			    (char_u *)"-c",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"shellpipe",   "sp",   P_STRING|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_sp, PV_NONE,
@@ -2168,30 +2185,30 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"shellquote",  "shq",  P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_shq, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"shellredir",  "srr",  P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_srr, PV_NONE,
-			    {(char_u *)">", (char_u *)0L}},
+			    {(char_u *)">", (char_u *)0L} SCRIPTID_INIT},
     {"shellslash",  "ssl",   P_BOOL|P_VI_DEF,
 #ifdef BACKSLASH_IN_FILENAME
 			    (char_u *)&p_ssl, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"shelltemp",   "stmp", P_BOOL,
 			    (char_u *)&p_stmp, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"shelltype",   "st",   P_NUM|P_VI_DEF,
 #ifdef AMIGA
 			    (char_u *)&p_st, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"shellxquote", "sxq",  P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_sxq, PV_NONE,
 			    {
@@ -2200,30 +2217,31 @@
 #else
 			    (char_u *)"",
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"shiftround",  "sr",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sr, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"shiftwidth",  "sw",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_sw, PV_SW,
-			    {(char_u *)8L, (char_u *)0L}},
+			    {(char_u *)8L, (char_u *)0L} SCRIPTID_INIT},
     {"shortmess",   "shm",  P_STRING|P_VIM|P_FLAGLIST,
 			    (char_u *)&p_shm, PV_NONE,
-			    {(char_u *)"", (char_u *)"filnxtToO"}},
+			    {(char_u *)"", (char_u *)"filnxtToO"}
+			    SCRIPTID_INIT},
     {"shortname",   "sn",   P_BOOL|P_VI_DEF,
 #ifdef SHORT_FNAME
 			    (char_u *)NULL, PV_NONE,
 #else
 			    (char_u *)&p_sn, PV_SN,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"showbreak",   "sbr",  P_STRING|P_VI_DEF|P_RALL,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)&p_sbr, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"showcmd",	    "sc",   P_BOOL|P_VIM,
 #ifdef FEAT_CMDL_INFO
 			    (char_u *)&p_sc, PV_NONE,
@@ -2236,58 +2254,58 @@
 #else
 				(char_u *)TRUE
 #endif
-				}},
+				} SCRIPTID_INIT},
     {"showfulltag", "sft",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_sft, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"showmatch",   "sm",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_sm, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"showmode",    "smd",  P_BOOL|P_VIM,
 			    (char_u *)&p_smd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"showtabline", "stal", P_NUM|P_VI_DEF|P_RALL,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_stal, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"sidescroll",  "ss",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_ss, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"sidescrolloff", "siso", P_NUM|P_VI_DEF|P_VIM|P_RBUF,
 			    (char_u *)&p_siso, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"slowopen",    "slow", P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"smartcase",   "scs",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_scs, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"smartindent", "si",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_SMARTINDENT
 			    (char_u *)&p_si, PV_SI,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"smarttab",    "sta",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sta, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"softtabstop", "sts",  P_NUM|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sts, PV_STS,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"sourceany",   NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"spell",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_SPELL
 			    (char_u *)VAR_WIN, PV_SPELL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"spellcapcheck", "spc", P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_spc, PV_SPC,
@@ -2296,7 +2314,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"spellfile",   "spf",  P_STRING|P_EXPAND|P_ALLOCED|P_VI_DEF|P_SECURE|P_COMMA,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_spf, PV_SPF,
@@ -2305,7 +2323,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"spelllang",   "spl",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_RBUF|P_EXPAND,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_spl, PV_SPL,
@@ -2314,7 +2332,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"spellsuggest", "sps", P_STRING|P_VI_DEF|P_EXPAND|P_SECURE|P_COMMA,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_sps, PV_NONE,
@@ -2323,35 +2341,35 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"splitbelow",  "sb",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_sb, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"splitright",  "spr",  P_BOOL|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_spr, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"startofline", "sol",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sol, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"statusline"  ,"stl",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
 #ifdef FEAT_STL_OPT
 			    (char_u *)&p_stl, PV_STL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"suffixes",    "su",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_su, PV_NONE,
 			    {(char_u *)".bak,~,.o,.h,.info,.swp,.obj",
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"suffixesadd", "sua",  P_STRING|P_VI_DEF|P_ALLOCED|P_COMMA|P_NODUP,
 #ifdef FEAT_SEARCHPATH
 			    (char_u *)&p_sua, PV_SUA,
@@ -2360,16 +2378,16 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"swapfile",    "swf",  P_BOOL|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_swf, PV_SWF,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"swapsync",    "sws",  P_STRING|P_VI_DEF,
 			    (char_u *)&p_sws, PV_NONE,
-			    {(char_u *)"fsync", (char_u *)0L}},
+			    {(char_u *)"fsync", (char_u *)0L} SCRIPTID_INIT},
     {"switchbuf",   "swb",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_swb, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"synmaxcol",   "smc",  P_NUM|P_VI_DEF|P_RBUF,
 #ifdef FEAT_SYN_HL
 			    (char_u *)&p_smc, PV_SMC,
@@ -2378,7 +2396,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"syntax",	    "syn",  P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
 #ifdef FEAT_SYN_HL
 			    (char_u *)&p_syn, PV_SYN,
@@ -2387,24 +2405,24 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"tabline",	    "tal",  P_STRING|P_VI_DEF|P_RALL,
 #ifdef FEAT_STL_OPT
 			    (char_u *)&p_tal, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"tabpagemax",  "tpm",  P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_tpm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)10L, (char_u *)0L}},
+			    {(char_u *)10L, (char_u *)0L} SCRIPTID_INIT},
     {"tabstop",	    "ts",   P_NUM|P_VI_DEF|P_RBUF,
 			    (char_u *)&p_ts, PV_TS,
-			    {(char_u *)8L, (char_u *)0L}},
+			    {(char_u *)8L, (char_u *)0L} SCRIPTID_INIT},
     {"tagbsearch",  "tbs",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_tbs, PV_NONE,
 #ifdef VMS	/* binary searching doesn't appear to work on VMS */
@@ -2412,13 +2430,13 @@
 #else
 			    {(char_u *)TRUE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"taglength",   "tl",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_tl, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"tagrelative", "tr",   P_BOOL|P_VIM,
 			    (char_u *)&p_tr, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"tags",	    "tag",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_tags, PV_TAGS,
 			    {
@@ -2427,20 +2445,20 @@
 #else
 			    (char_u *)"./tags,tags",
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"tagstack",    "tgst", P_BOOL|P_VI_DEF,
 			    (char_u *)&p_tgst, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"term",	    NULL,   P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
 			    (char_u *)&T_NAME, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"termbidi", "tbidi",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_ARABIC
 			    (char_u *)&p_tbidi, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"termencoding", "tenc", P_STRING|P_VI_DEF|P_RCLR,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_tenc, PV_NONE,
@@ -2449,13 +2467,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"terse",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_terse, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"textauto",    "ta",   P_BOOL|P_VIM,
 			    (char_u *)&p_ta, PV_NONE,
-			    {(char_u *)DFLT_TEXTAUTO, (char_u *)TRUE}},
+			    {(char_u *)DFLT_TEXTAUTO, (char_u *)TRUE}
+			    SCRIPTID_INIT},
     {"textmode",    "tx",   P_BOOL|P_VI_DEF|P_NO_MKRC,
 			    (char_u *)&p_tx, PV_TX,
 			    {
@@ -2464,40 +2483,40 @@
 #else
 			    (char_u *)FALSE,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"textwidth",   "tw",   P_NUM|P_VI_DEF|P_VIM,
 			    (char_u *)&p_tw, PV_TW,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"thesaurus",   "tsr",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_tsr, PV_TSR,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"tildeop",	    "top",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_to, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"timeout",	    "to",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_timeout, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"timeoutlen",  "tm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_tm, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
+			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
     {"title",	    NULL,   P_BOOL|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_title, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"titlelen",    NULL,   P_NUM|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_titlelen, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)85L, (char_u *)0L}},
+			    {(char_u *)85L, (char_u *)0L} SCRIPTID_INIT},
     {"titleold",    NULL,   P_STRING|P_VI_DEF|P_GETTEXT|P_SECURE|P_NO_MKRC,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_titleold, PV_NONE,
@@ -2507,49 +2526,50 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"titlestring", NULL,   P_STRING|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_titlestring, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
 #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
     {"toolbar",     "tb",   P_STRING|P_COMMA|P_VI_DEF|P_NODUP,
 			    (char_u *)&p_toolbar, PV_NONE,
-			    {(char_u *)"icons,tooltips", (char_u *)0L}},
+			    {(char_u *)"icons,tooltips", (char_u *)0L}
+			    SCRIPTID_INIT},
 #endif
 #if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
     {"toolbariconsize",	"tbis", P_STRING|P_VI_DEF,
 			    (char_u *)&p_tbis, PV_NONE,
-			    {(char_u *)"small", (char_u *)0L}},
+			    {(char_u *)"small", (char_u *)0L} SCRIPTID_INIT},
 #endif
     {"ttimeout",    NULL,   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_ttimeout, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"ttimeoutlen", "ttm",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_ttm, PV_NONE,
-			    {(char_u *)-1L, (char_u *)0L}},
+			    {(char_u *)-1L, (char_u *)0L} SCRIPTID_INIT},
     {"ttybuiltin",  "tbi",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_tbi, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"ttyfast",	    "tf",   P_BOOL|P_NO_MKRC|P_VI_DEF,
 			    (char_u *)&p_tf, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"ttymouse",    "ttym", P_STRING|P_NODEFAULT|P_NO_MKRC|P_VI_DEF,
 #if defined(FEAT_MOUSE) && (defined(UNIX) || defined(VMS))
 			    (char_u *)&p_ttym, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"ttyscroll",   "tsl",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_ttyscroll, PV_NONE,
-			    {(char_u *)999L, (char_u *)0L}},
+			    {(char_u *)999L, (char_u *)0L} SCRIPTID_INIT},
     {"ttytype",	    "tty",  P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
 			    (char_u *)&T_NAME, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"undolevels",  "ul",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_ul, PV_NONE,
 			    {
@@ -2558,19 +2578,19 @@
 #else
 			    (char_u *)100L,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"updatecount", "uc",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_uc, PV_NONE,
-			    {(char_u *)200L, (char_u *)0L}},
+			    {(char_u *)200L, (char_u *)0L} SCRIPTID_INIT},
     {"updatetime",  "ut",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_ut, PV_NONE,
-			    {(char_u *)4000L, (char_u *)0L}},
+			    {(char_u *)4000L, (char_u *)0L} SCRIPTID_INIT},
     {"verbose",	    "vbs",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_verbose, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"verbosefile", "vfile", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_vfile, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"viewdir",     "vdir", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_SESSION
 			    (char_u *)&p_vdir, PV_NONE,
@@ -2579,7 +2599,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"viewoptions", "vop",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SESSION
 			    (char_u *)&p_vop, PV_NONE,
@@ -2588,25 +2608,25 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"viminfo",	    "vi",   P_STRING|P_COMMA|P_NODUP|P_SECURE,
 #ifdef FEAT_VIMINFO
 			    (char_u *)&p_viminfo, PV_NONE,
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-			    {(char_u *)"", (char_u *)"'20,<50,s10,h,rA:,rB:"}
+			    {(char_u *)"", (char_u *)"'100,<50,s10,h,rA:,rB:"}
 #else
 # ifdef AMIGA
 			    {(char_u *)"",
-				 (char_u *)"'20,<50,s10,h,rdf0:,rdf1:,rdf2:"}
+				 (char_u *)"'100,<50,s10,h,rdf0:,rdf1:,rdf2:"}
 # else
-			    {(char_u *)"", (char_u *)"'20,<50,s10,h"}
+			    {(char_u *)"", (char_u *)"'100,<50,s10,h"}
 # endif
 #endif
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"virtualedit", "ve",   P_STRING|P_COMMA|P_NODUP|P_VI_DEF|P_VIM,
 #ifdef FEAT_VIRTUALEDIT
 			    (char_u *)&p_ve, PV_NONE,
@@ -2615,51 +2635,52 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"visualbell",  "vb",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_vb, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"w300",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"w1200",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"w9600",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"warn",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_warn, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"weirdinvert", "wiv",  P_BOOL|P_VI_DEF|P_RCLR,
 			    (char_u *)&p_wiv, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"whichwrap",   "ww",   P_STRING|P_VIM|P_COMMA|P_FLAGLIST,
 			    (char_u *)&p_ww, PV_NONE,
-			    {(char_u *)"", (char_u *)"b,s"}},
+			    {(char_u *)"", (char_u *)"b,s"} SCRIPTID_INIT},
     {"wildchar",    "wc",   P_NUM|P_VIM,
 			    (char_u *)&p_wc, PV_NONE,
-			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}},
+			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}
+			    SCRIPTID_INIT},
     {"wildcharm",   "wcm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_wcm, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"wildignore",  "wig",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_WILDIGN
 			    (char_u *)&p_wig, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"wildmenu",    "wmnu", P_BOOL|P_VI_DEF,
 #ifdef FEAT_WILDMENU
 			    (char_u *)&p_wmnu, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"wildmode",    "wim",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_wim, PV_NONE,
-			    {(char_u *)"full", (char_u *)0L}},
+			    {(char_u *)"full", (char_u *)0L} SCRIPTID_INIT},
     {"wildoptions", "wop",  P_STRING|P_VI_DEF,
 #ifdef FEAT_CMDL_COMPL
 			    (char_u *)&p_wop, PV_NONE,
@@ -2668,7 +2689,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"winaltkeys",  "wak",  P_STRING|P_VI_DEF,
 #ifdef FEAT_WAK
 			    (char_u *)&p_wak, PV_NONE,
@@ -2677,67 +2698,67 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"window",	    "wi",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_window, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"winheight",   "wh",   P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_wh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"winfixheight", "wfh", P_BOOL|P_VI_DEF|P_RSTAT,
 #ifdef FEAT_WINDOWS
 			    (char_u *)VAR_WIN, PV_WFH,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"winfixwidth", "wfw", P_BOOL|P_VI_DEF|P_RSTAT,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)VAR_WIN, PV_WFW,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"winminheight", "wmh", P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_wmh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"winminwidth", "wmw", P_NUM|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_wmw, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"winwidth",   "wiw",   P_NUM|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_wiw, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)20L, (char_u *)0L}},
+			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
     {"wrap",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_WRAP,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"wrapmargin",  "wm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_wm, PV_WM,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"wrapscan",    "ws",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ws, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"write",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_write, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"writeany",    "wa",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_wa, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"writebackup", "wb",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_wb, PV_NONE,
 			    {
@@ -2746,15 +2767,15 @@
 #else
 			    (char_u *)FALSE,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"writedelay",  "wd",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_wd, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
 
 /* terminal output codes */
 #define p_term(sss, vvv)   {sss, NULL, P_STRING|P_VI_DEF|P_RALL|P_SECURE, \
 			    (char_u *)&vvv, PV_NONE, \
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
 
     p_term("t_AB", T_CAB)
     p_term("t_AF", T_CAF)
@@ -2815,7 +2836,8 @@
 
 /* terminal key codes are not in here */
 
-    {NULL, NULL, 0, NULL, PV_NONE, {NULL, NULL}}	/* end marker */
+    /* end marker */
+    {NULL, NULL, 0, NULL, PV_NONE, {NULL, NULL} SCRIPTID_INIT}
 };
 
 #define PARAM_COUNT (sizeof(options) / sizeof(struct vimoption))
@@ -4119,11 +4141,23 @@
 					   && options[opt_idx].var == VAR_WIN)
 		goto skip;
 
-	    /* Disallow changing some options from modelines */
-	    if ((opt_flags & OPT_MODELINE) && (flags & P_SECURE))
+	    /* Disallow changing some options from modelines. */
+	    if (opt_flags & OPT_MODELINE)
 	    {
-		errmsg = (char_u *)_("E520: Not allowed in a modeline");
-		goto skip;
+		if (flags & P_SECURE)
+		{
+		    errmsg = (char_u *)_("E520: Not allowed in a modeline");
+		    goto skip;
+		}
+#ifdef FEAT_DIFF
+		/* In diff mode some options are overruled.  This avoids that
+		 * 'foldmethod' becomes "marker" instead of "diff" and that
+		 * "wrap" gets set. */
+		if (curwin->w_p_diff
+			&& (options[opt_idx].indir == PV_FDM
+			    || options[opt_idx].indir == PV_WRAP))
+		    goto skip;
+#endif
 	    }
 
 #ifdef HAVE_SANDBOX
@@ -5268,6 +5302,21 @@
 }
 #endif
 
+#ifdef FEAT_TITLE
+static void redraw_titles __ARGS((void));
+
+/*
+ * Redraw the window title and/or tab page text later.
+ */
+static void redraw_titles()
+{
+    need_maketitle = TRUE;
+# ifdef FEAT_WINDOWS
+    redraw_tabline = TRUE;
+# endif
+}
+#endif
+
 /*
  * Set a string option to a new value (without checking the effect).
  * The string is copied into allocated memory.
@@ -5275,14 +5324,13 @@
  * When "set_sid" is zero set the scriptID to current_SID.  When "set_sid" is
  * SID_NONE don't set the scriptID.  Otherwise set the scriptID to "set_sid".
  */
-/*ARGSUSED*/
     void
 set_string_option_direct(name, opt_idx, val, opt_flags, set_sid)
     char_u	*name;
     int		opt_idx;
     char_u	*val;
     int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
-    int		set_sid;
+    int		set_sid UNUSED;
 {
     char_u	*s;
     char_u	**varp;
@@ -5407,6 +5455,10 @@
     int		did_chartab = FALSE;
     char_u	**gvarp;
     long_u	free_oldval = (options[opt_idx].flags & P_ALLOCED);
+#ifdef FEAT_GUI
+    /* set when changing an option that only requires a redraw in the GUI */
+    int		redraw_gui_only = FALSE;
+#endif
 
     /* Get the global option to compare with, otherwise we would have to check
      * two values for all local options. */
@@ -5668,7 +5720,7 @@
 	    {
 # ifdef FEAT_TITLE
 		/* May show a "+" in the title now. */
-		need_maketitle = TRUE;
+		redraw_titles();
 # endif
 		/* Add 'fileencoding' to the swap file. */
 		ml_setflags(curbuf);
@@ -5687,7 +5739,7 @@
 	    {
 		errmsg = mb_init();
 # ifdef FEAT_TITLE
-		need_maketitle = TRUE;
+		redraw_titles();
 # endif
 	    }
 	}
@@ -5766,14 +5818,28 @@
 	/* load or unload key mapping tables */
 	errmsg = keymap_init();
 
-	/* When successfully installed a new keymap switch on using it. */
-	if (*curbuf->b_p_keymap != NUL && errmsg == NULL)
+	if (errmsg == NULL)
 	{
-	    curbuf->b_p_iminsert = B_IMODE_LMAP;
-	    if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
-		curbuf->b_p_imsearch = B_IMODE_LMAP;
-	    set_iminsert_global();
-	    set_imsearch_global();
+	    if (*curbuf->b_p_keymap != NUL)
+	    {
+		/* Installed a new keymap, switch on using it. */
+		curbuf->b_p_iminsert = B_IMODE_LMAP;
+		if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
+		    curbuf->b_p_imsearch = B_IMODE_LMAP;
+	    }
+	    else
+	    {
+		/* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */
+		if (curbuf->b_p_iminsert == B_IMODE_LMAP)
+		    curbuf->b_p_iminsert = B_IMODE_NONE;
+		if (curbuf->b_p_imsearch == B_IMODE_LMAP)
+		    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;
+	    }
+	    if ((opt_flags & OPT_LOCAL) == 0)
+	    {
+		set_iminsert_global();
+		set_imsearch_global();
+	    }
 # ifdef FEAT_WINDOWS
 	    status_redraw_curbuf();
 # endif
@@ -5796,7 +5862,7 @@
 	    else
 		curbuf->b_p_tx = FALSE;
 #ifdef FEAT_TITLE
-	    need_maketitle = TRUE;
+	    redraw_titles();
 #endif
 	    /* update flag in swap file */
 	    ml_setflags(curbuf);
@@ -5977,15 +6043,23 @@
 	/* ":set t_Co=0" and ":set t_Co=1" do ":set t_Co=" */
 	if (varp == &T_CCO)
 	{
-	    t_colors = atoi((char *)T_CCO);
-	    if (t_colors <= 1)
+	    int colors = atoi((char *)T_CCO);
+
+	    /* Only reinitialize colors if t_Co value has really changed to
+	     * avoid expensive reload of colorscheme if t_Co is set to the
+	     * same value multiple times. */
+	    if (colors != t_colors)
 	    {
-		if (new_value_alloced)
-		    vim_free(T_CCO);
-		T_CCO = empty_option;
+		t_colors = colors;
+		if (t_colors <= 1)
+		{
+		    if (new_value_alloced)
+			vim_free(T_CCO);
+		    T_CCO = empty_option;
+		}
+		/* We now have a different color setup, initialize it again. */
+		init_highlight(TRUE, FALSE);
 	    }
-	    /* We now have a different color setup, initialize it again. */
-	    init_highlight(TRUE, FALSE);
 	}
 	ttest(FALSE);
 	if (varp == &T_ME)
@@ -6055,6 +6129,7 @@
 		    errmsg = (char_u *)N_("E596: Invalid font(s)");
 	    }
 	}
+	redraw_gui_only = TRUE;
     }
 # ifdef FEAT_XFONTSET
     else if (varp == &p_guifontset)
@@ -6063,6 +6138,7 @@
 	    errmsg = (char_u *)N_("E597: can't select fontset");
 	else if (gui.in_use && gui_init_font(p_guifontset, TRUE) != OK)
 	    errmsg = (char_u *)N_("E598: Invalid fontset");
+	redraw_gui_only = TRUE;
     }
 # endif
 # ifdef FEAT_MBYTE
@@ -6072,6 +6148,7 @@
 	    errmsg = (char_u *)N_("E533: can't select wide font");
 	else if (gui_get_wide_font() == FAIL)
 	    errmsg = (char_u *)N_("E534: Invalid wide font");
+	redraw_gui_only = TRUE;
     }
 # endif
 #endif
@@ -6133,13 +6210,24 @@
 #ifdef FEAT_GUI
     /* 'guioptions' */
     else if (varp == &p_go)
+    {
 	gui_init_which_components(oldval);
+	redraw_gui_only = TRUE;
+    }
 #endif
 
 #if defined(FEAT_GUI_TABLINE)
     /* 'guitablabel' */
     else if (varp == &p_gtl)
+    {
 	redraw_tabline = TRUE;
+	redraw_gui_only = TRUE;
+    }
+    /* 'guitabtooltip' */
+    else if (varp == &p_gtt)
+    {
+	redraw_gui_only = TRUE;
+    }
 #endif
 
 #if defined(FEAT_MOUSE_TTY) && (defined(UNIX) || defined(VMS))
@@ -6717,7 +6805,11 @@
 
     if (curwin->w_curswant != MAXCOL)
 	curwin->w_set_curswant = TRUE;  /* in case 'showbreak' changed */
-    check_redraw(options[opt_idx].flags);
+#ifdef FEAT_GUI
+    /* check redraw when it's not a GUI option or the GUI is active. */
+    if (!redraw_gui_only || gui.in_use)
+#endif
+	check_redraw(options[opt_idx].flags);
 
     return errmsg;
 }
@@ -7105,22 +7197,28 @@
 	    curbuf->b_did_warn = FALSE;
 
 #ifdef FEAT_TITLE
-	need_maketitle = TRUE;
+	redraw_titles();
 #endif
     }
 
 #ifdef FEAT_TITLE
     /* when 'modifiable' is changed, redraw the window title */
     else if ((int *)varp == &curbuf->b_p_ma)
-	need_maketitle = TRUE;
+    {
+	redraw_titles();
+    }
     /* when 'endofline' is changed, redraw the window title */
     else if ((int *)varp == &curbuf->b_p_eol)
-	need_maketitle = TRUE;
-#ifdef FEAT_MBYTE
-    /* when 'bomb' is changed, redraw the window title */
+    {
+	redraw_titles();
+    }
+# ifdef FEAT_MBYTE
+    /* when 'bomb' is changed, redraw the window title and tab page text */
     else if ((int *)varp == &curbuf->b_p_bomb)
-	need_maketitle = TRUE;
-#endif
+    {
+	redraw_titles();
+    }
+# endif
 #endif
 
     /* when 'bin' is set also set some other options */
@@ -7128,7 +7226,7 @@
     {
 	set_options_bin(old_value, curbuf->b_p_bin, opt_flags);
 #ifdef FEAT_TITLE
-	need_maketitle = TRUE;
+	redraw_titles();
 #endif
     }
 
@@ -7279,7 +7377,7 @@
 	if (!value)
 	    save_file_ff(curbuf);	/* Buffer is unchanged */
 #ifdef FEAT_TITLE
-	need_maketitle = TRUE;
+	redraw_titles();
 #endif
 #ifdef FEAT_AUTOCMD
 	modified_was_set = value;
@@ -7486,9 +7584,13 @@
 	     * set. */
 	    if (STRCMP(p_enc, "utf-8") != 0)
 	    {
+		static char *w_arabic = N_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'");
+
 		msg_source(hl_attr(HLF_W));
-		MSG_ATTR(_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'"),
-			hl_attr(HLF_W));
+		MSG_ATTR(_(w_arabic), hl_attr(HLF_W));
+#ifdef FEAT_EVAL
+		set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);
+#endif
 	    }
 
 # ifdef FEAT_MBYTE
@@ -7714,7 +7816,7 @@
 	newFoldLevel();
     }
 
-    /* 'foldminlevel' */
+    /* 'foldminlines' */
     else if (pp == &curwin->w_p_fml)
     {
 	foldUpdateAll(curwin);
@@ -7974,6 +8076,11 @@
 	else /* curwin->w_p_scr > curwin->w_height */
 	    curwin->w_p_scr = curwin->w_height;
     }
+    if (p_hi < 0)
+    {
+	errmsg = e_positive;
+	p_hi = 0;
+    }
     if (p_report < 0)
     {
 	errmsg = e_positive;
@@ -8227,13 +8334,13 @@
 	    {
 		if (number == 0 && string != NULL)
 		{
-		    int index;
+		    int idx;
 
 		    /* Either we are given a string or we are setting option
 		     * to zero. */
-		    for (index = 0; string[index] == '0'; ++index)
+		    for (idx = 0; string[idx] == '0'; ++idx)
 			;
-		    if (string[index] != NUL || index == 0)
+		    if (string[idx] != NUL || idx == 0)
 		    {
 			/* There's another character after zeros or the string
 			 * is empty.  In both cases, we are trying to set a
@@ -8323,7 +8430,7 @@
     {
 	--arg;			    /* put arg at the '<' */
 	modifiers = 0;
-	key = find_special_key(&arg, &modifiers, TRUE);
+	key = find_special_key(&arg, &modifiers, TRUE, TRUE);
 	if (modifiers)		    /* can't handle modifiers here */
 	    key = 0;
     }
@@ -9271,10 +9378,9 @@
 /*
  * Check for NULL pointers in a winopt_T and replace them with empty_option.
  */
-/*ARGSUSED*/
     void
 check_winopt(wop)
-    winopt_T	*wop;
+    winopt_T	*wop UNUSED;
 {
 #ifdef FEAT_FOLDING
     check_string_option(&wop->wo_fdi);
@@ -9296,10 +9402,9 @@
 /*
  * Free the allocated memory inside a winopt_T.
  */
-/*ARGSUSED*/
     void
 clear_winopt(wop)
-    winopt_T	*wop;
+    winopt_T	*wop UNUSED;
 {
 #ifdef FEAT_FOLDING
     clear_string_option(&wop->wo_fdi);
@@ -9834,7 +9939,8 @@
 	regmatch->rm_ic = ic;
 	if (xp->xp_context != EXPAND_BOOL_SETTINGS)
 	{
-	    for (match = 0; match < sizeof(names) / sizeof(char *); ++match)
+	    for (match = 0; match < (int)(sizeof(names) / sizeof(char *));
+								      ++match)
 		if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))
 		{
 		    if (loop == 0)
@@ -10093,25 +10199,110 @@
 
 #ifdef FEAT_LANGMAP
 /*
- * Any character has an equivalent character.  This is used for keyboards that
- * have a special language mode that sends characters above 128 (although
- * other characters can be translated too).
+ * Any character has an equivalent 'langmap' character.  This is used for
+ * keyboards that have a special language mode that sends characters above
+ * 128 (although other characters can be translated too).  The "to" field is a
+ * Vim command character.  This avoids having to switch the keyboard back to
+ * ASCII mode when leaving Insert mode.
+ *
+ * langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim
+ * commands.
+ * When FEAT_MBYTE is defined langmap_mapga.ga_data is a sorted table of
+ * langmap_entry_T.  This does the same as langmap_mapchar[] for characters >=
+ * 256.
+ */
+# ifdef FEAT_MBYTE
+/*
+ * With multi-byte support use growarray for 'langmap' chars >= 256
+ */
+typedef struct
+{
+    int	    from;
+    int     to;
+} langmap_entry_T;
+
+static garray_T langmap_mapga;
+static void langmap_set_entry __ARGS((int from, int to));
+
+/*
+ * Search for an entry in "langmap_mapga" for "from".  If found set the "to"
+ * field.  If not found insert a new entry at the appropriate location.
  */
+    static void
+langmap_set_entry(from, to)
+    int    from;
+    int    to;
+{
+    langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
+    int             a = 0;
+    int             b = langmap_mapga.ga_len;
+
+    /* Do a binary search for an existing entry. */
+    while (a != b)
+    {
+	int i = (a + b) / 2;
+	int d = entries[i].from - from;
+
+	if (d == 0)
+	{
+	    entries[i].to = to;
+	    return;
+	}
+	if (d < 0)
+	    a = i + 1;
+	else
+	    b = i;
+    }
+
+    if (ga_grow(&langmap_mapga, 1) != OK)
+	return;  /* out of memory */
+
+    /* insert new entry at position "a" */
+    entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;
+    mch_memmove(entries + 1, entries,
+			(langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));
+    ++langmap_mapga.ga_len;
+    entries[0].from = from;
+    entries[0].to = to;
+}
 
 /*
- * char_u langmap_mapchar[256];
- * Normally maps each of the 128 upper chars to an <128 ascii char; used to
- * "translate" native lang chars in normal mode or some cases of
- * insert mode without having to tediously switch lang mode back&forth.
+ * Apply 'langmap' to multi-byte character "c" and return the result.
  */
+    int
+langmap_adjust_mb(c)
+    int c;
+{
+    langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
+    int a = 0;
+    int b = langmap_mapga.ga_len;
+
+    while (a != b)
+    {
+	int i = (a + b) / 2;
+	int d = entries[i].from - c;
+
+	if (d == 0)
+	    return entries[i].to;  /* found matching entry */
+	if (d < 0)
+	    a = i + 1;
+	else
+	    b = i;
+    }
+    return c;  /* no entry found, return "c" unmodified */
+}
+# endif
 
     static void
 langmap_init()
 {
     int i;
 
-    for (i = 0; i < 256; i++)		/* we init with a-one-to one map */
-	langmap_mapchar[i] = i;
+    for (i = 0; i < 256; i++)
+	langmap_mapchar[i] = i;	 /* we init with a one-to-one map */
+# ifdef FEAT_MBYTE
+    ga_init2(&langmap_mapga, sizeof(langmap_entry_T), 8);
+# endif
 }
 
 /*
@@ -10125,7 +10316,10 @@
     char_u  *p2;
     int	    from, to;
 
-    langmap_init();			    /* back to one-to-one map first */
+#ifdef FEAT_MBYTE
+    ga_clear(&langmap_mapga);		    /* clear the previous map first */
+#endif
+    langmap_init();			    /* back to one-to-one map */
 
     for (p = p_langmap; p[0] != NUL; )
     {
@@ -10175,7 +10369,13 @@
 							     transchar(from));
 		return;
 	    }
-	    langmap_mapchar[from & 255] = to;
+
+#ifdef FEAT_MBYTE
+	    if (from >= 256)
+		langmap_set_entry(from, to);
+	    else
+#endif
+		langmap_mapchar[from & 255] = to;
 
 	    /* Advance to next pair */
 	    mb_ptr_adv(p);
diff -Naur vim72.orig/src/os_unix.c vim72/src/os_unix.c
--- vim72.orig/src/os_unix.c	2008-08-06 04:01:40.000000000 -0700
+++ vim72/src/os_unix.c	2009-06-05 14:25:15.000000000 -0700
@@ -181,7 +181,8 @@
 	&& defined(FEAT_TITLE) && !defined(FEAT_GUI_GTK)
 # define SET_SIG_ALARM
 static RETSIGTYPE sig_alarm __ARGS(SIGPROTOARG);
-static int sig_alarm_called;
+/* volatile because it is used in signal handler sig_alarm(). */
+static volatile int sig_alarm_called;
 #endif
 static RETSIGTYPE deathtrap __ARGS(SIGPROTOARG);
 
@@ -201,13 +202,16 @@
 # define SIG_ERR	((RETSIGTYPE (*)())-1)
 #endif
 
-static int	do_resize = FALSE;
+/* volatile because it is used in signal handler sig_winch(). */
+static volatile int do_resize = FALSE;
 #ifndef __EMX__
 static char_u	*extra_shell_arg = NULL;
 static int	show_shell_mess = TRUE;
 #endif
-static int	deadly_signal = 0;	    /* The signal we caught */
-static int	in_mch_delay = FALSE;	    /* sleeping in mch_delay() */
+/* volatile because it is used in signal handler deathtrap(). */
+static volatile int deadly_signal = 0;	    /* The signal we caught */
+/* volatile because it is used in signal handler deathtrap(). */
+static volatile int in_mch_delay = FALSE;    /* sleeping in mch_delay() */
 
 static int curr_tmode = TMODE_COOK;	/* contains current terminal mode */
 
@@ -315,12 +319,15 @@
     {-1,	    "Unknown!", FALSE}
 };
 
+/*
+ * Write s[len] to the screen.
+ */
     void
 mch_write(s, len)
     char_u	*s;
     int		len;
 {
-    write(1, (char *)s, len);
+    ignored = (int)write(1, (char *)s, len);
     if (p_wd)		/* Unix is too fast, slow down a bit more */
 	RealWaitForChar(read_cmd_fd, p_wd, NULL);
 }
@@ -447,10 +454,9 @@
  * Return total amount of memory available in Kbyte.
  * Doesn't change when memory has been allocated.
  */
-/* ARGSUSED */
     long_u
 mch_total_mem(special)
-    int special;
+    int special UNUSED;
 {
 # ifdef __EMX__
     return ulimit(3, 0L) >> 10;   /* always 32MB? */
@@ -799,12 +805,11 @@
 #endif
 
 /*
- * We need correct potatotypes for a signal function, otherwise mean compilers
+ * We need correct prototypes for a signal function, otherwise mean compilers
  * will barf when the second argument to signal() is ``wrong''.
  * Let me try it with a few tricky defines from my own osdef.h	(jw).
  */
 #if defined(SIGWINCH)
-/* ARGSUSED */
     static RETSIGTYPE
 sig_winch SIGDEFARG(sigarg)
 {
@@ -816,7 +821,6 @@
 #endif
 
 #if defined(SIGINT)
-/* ARGSUSED */
     static RETSIGTYPE
 catch_sigint SIGDEFARG(sigarg)
 {
@@ -828,7 +832,6 @@
 #endif
 
 #if defined(SIGPWR)
-/* ARGSUSED */
     static RETSIGTYPE
 catch_sigpwr SIGDEFARG(sigarg)
 {
@@ -848,7 +851,6 @@
 /*
  * signal function for alarm().
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sig_alarm SIGDEFARG(sigarg)
 {
@@ -1065,19 +1067,23 @@
     SIGRETURN;
 }
 
-#ifdef _REENTRANT
+#if defined(_REENTRANT) && defined(SIGCONT)
 /*
  * On Solaris with multi-threading, suspending might not work immediately.
  * Catch the SIGCONT signal, which will be used as an indication whether the
  * suspending has been done or not.
+ *
+ * On Linux, signal is not always handled immediately either.
+ * See https://bugs.launchpad.net/bugs/291373
+ *
+ * volatile because it is used in in signal handler sigcont_handler().
  */
-static int sigcont_received;
+static volatile int sigcont_received;
 static RETSIGTYPE sigcont_handler __ARGS(SIGPROTOARG);
 
 /*
  * signal handler for SIGCONT
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sigcont_handler SIGDEFARG(sigarg)
 {
@@ -1115,15 +1121,28 @@
     }
 # endif
 
-# ifdef _REENTRANT
+# if defined(_REENTRANT) && defined(SIGCONT)
     sigcont_received = FALSE;
 # endif
     kill(0, SIGTSTP);	    /* send ourselves a STOP signal */
-# ifdef _REENTRANT
-    /* When we didn't suspend immediately in the kill(), do it now.  Happens
-     * on multi-threaded Solaris. */
-    if (!sigcont_received)
-	pause();
+# if defined(_REENTRANT) && defined(SIGCONT)
+    /*
+     * Wait for the SIGCONT signal to be handled. It generally happens
+     * immediately, but somehow not all the time. Do not call pause()
+     * because there would be race condition which would hang Vim if
+     * signal happened in between the test of sigcont_received and the
+     * call to pause(). If signal is not yet received, call sleep(0)
+     * to just yield CPU. Signal should then be received. If somehow
+     * it's still not received, sleep 1, 2, 3 ms. Don't bother waiting
+     * further if signal is not received after 1+2+3+4 ms (not expected
+     * to happen).
+     */
+    {
+	long wait;
+	for (wait = 0; !sigcont_received && wait <= 3L; wait++)
+	    /* Loop is not entered most of the time */
+	    mch_delay(wait, FALSE);
+    }
 # endif
 
 # ifdef FEAT_TITLE
@@ -1172,7 +1191,7 @@
 #ifdef SIGTSTP
     signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);
 #endif
-#ifdef _REENTRANT
+#if defined(_REENTRANT) && defined(SIGCONT)
     signal(SIGCONT, sigcont_handler);
 #endif
 
@@ -1231,7 +1250,7 @@
 reset_signals()
 {
     catch_signals(SIG_DFL, SIG_DFL);
-#ifdef _REENTRANT
+#if defined(_REENTRANT) && defined(SIGCONT)
     /* SIGCONT isn't in the list, because its default action is ignore */
     signal(SIGCONT, SIG_DFL);
 #endif
@@ -1326,11 +1345,10 @@
 /*
  * Check_win checks whether we have an interactive stdout.
  */
-/* ARGSUSED */
     int
 mch_check_win(argc, argv)
-    int	    argc;
-    char    **argv;
+    int	    argc UNUSED;
+    char    **argv UNUSED;
 {
 #ifdef OS2
     /*
@@ -1414,11 +1432,10 @@
 /*
  * Another X Error handler, just used to check for errors.
  */
-/* ARGSUSED */
     static int
 x_error_check(dpy, error_event)
-    Display *dpy;
-    XErrorEvent	*error_event;
+    Display *dpy UNUSED;
+    XErrorEvent	*error_event UNUSED;
 {
     got_x_error = TRUE;
     return 0;
@@ -1431,15 +1448,12 @@
  */
 static int x_IOerror_check __ARGS((Display *dpy));
 
-/* ARGSUSED */
     static int
 x_IOerror_check(dpy)
-    Display *dpy;
+    Display *dpy UNUSED;
 {
     /* This function should not return, it causes exit().  Longjump instead. */
     LONGJMP(lc_jump_env, 1);
-    /*NOTREACHED*/
-    return 0;
 }
 # endif
 
@@ -1448,10 +1462,9 @@
  */
 static int x_IOerror_handler __ARGS((Display *dpy));
 
-/* ARGSUSED */
     static int
 x_IOerror_handler(dpy)
-    Display *dpy;
+    Display *dpy UNUSED;
 {
     xterm_dpy = NULL;
     x11_window = 0;
@@ -1460,8 +1473,6 @@
 
     /* This function should not return, it causes exit().  Longjump instead. */
     LONGJMP(x_jump_env, 1);
-    /*NOTREACHED*/
-    return 0;
 }
 #endif
 
@@ -1897,10 +1908,9 @@
 
 #else  /* FEAT_X11 */
 
-/*ARGSUSED*/
     static int
 get_x11_title(test_only)
-    int	    test_only;
+    int	    test_only UNUSED;
 {
     return FALSE;
 }
@@ -2438,7 +2448,7 @@
     }
 
     /* Catch file names which are too long. */
-    if (retval == FAIL || STRLEN(buf) + STRLEN(fname) >= len)
+    if (retval == FAIL || (int)(STRLEN(buf) + STRLEN(fname)) >= len)
 	return FAIL;
 
     /* Do not append ".", "/dir/." is equal to "/dir". */
@@ -2475,11 +2485,10 @@
  * file name to remain exactly the same.
  * Only required for file systems where case is ignored and preserved.
  */
-/*ARGSUSED*/
     void
 fname_case(name, len)
     char_u	*name;
-    int		len;	    /* buffer size, only used when name gets longer */
+    int		len UNUSED;  /* buffer size, only used when name gets longer */
 {
     struct stat st;
     char_u	*slash, *tail;
@@ -2657,7 +2666,7 @@
  */
     vim_acl_T
 mch_get_acl(fname)
-    char_u	*fname;
+    char_u	*fname UNUSED;
 {
     vim_acl_T	ret = NULL;
 #ifdef HAVE_POSIX_ACL
@@ -2717,7 +2726,7 @@
  */
     void
 mch_set_acl(fname, aclent)
-    char_u	*fname;
+    char_u	*fname UNUSED;
     vim_acl_T	aclent;
 {
     if (aclent == NULL)
@@ -2760,10 +2769,9 @@
 /*
  * Set hidden flag for "name".
  */
-/* ARGSUSED */
     void
 mch_hide(name)
-    char_u	*name;
+    char_u	*name UNUSED;
 {
     /* can't hide a file */
 }
@@ -2905,7 +2913,7 @@
      * Ignore any errors.
      */
 #if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)
-    signal_stack = malloc(SIGSTKSZ);
+    signal_stack = (char *)alloc(SIGSTKSZ);
     init_signal_stack();
 #endif
 }
@@ -2936,7 +2944,8 @@
     }
 #  endif
 # endif
-# ifdef FEAT_X11
+    /* Don't close the display for GTK 1, it is done in exit(). */
+# if defined(FEAT_X11) && (!defined(FEAT_GUI_GTK) || defined(HAVE_GTK2))
     if (x11_display != NULL
 #  ifdef FEAT_XCLIPBOARD
 	    && x11_display != xterm_dpy
@@ -3451,10 +3460,9 @@
 /*
  * set screen mode, always fails.
  */
-/* ARGSUSED */
     int
 mch_screenmode(arg)
-    char_u   *arg;
+    char_u   *arg UNUSED;
 {
     EMSG(_(e_screenmode));
     return FAIL;
@@ -3926,9 +3934,9 @@
 		 */
 		if (fd >= 0)
 		{
-		    dup(fd); /* To replace stdin  (file descriptor 0) */
-		    dup(fd); /* To replace stdout (file descriptor 1) */
-		    dup(fd); /* To replace stderr (file descriptor 2) */
+		    ignored = dup(fd); /* To replace stdin  (fd 0) */
+		    ignored = dup(fd); /* To replace stdout (fd 1) */
+		    ignored = dup(fd); /* To replace stderr (fd 2) */
 
 		    /* Don't need this now that we've duplicated it */
 		    close(fd);
@@ -3946,7 +3954,17 @@
 		 * children can be kill()ed.  Don't do this when using pipes,
 		 * because stdin is not a tty, we would lose /dev/tty. */
 		if (p_stmp)
+		{
 		    (void)setsid();
+#  if defined(SIGHUP)
+		    /* When doing "!xterm&" and 'shell' is bash: the shell
+		     * will exit and send SIGHUP to all processes in its
+		     * group, killing the just started process.  Ignore SIGHUP
+		     * to avoid that. (suggested by Simon Schubert)
+		     */
+		    signal(SIGHUP, SIG_IGN);
+#  endif
+		}
 # endif
 # ifdef FEAT_GUI
 		if (pty_slave_fd >= 0)
@@ -3996,13 +4014,13 @@
 
 		    /* set up stdin/stdout/stderr for the child */
 		    close(0);
-		    dup(pty_slave_fd);
+		    ignored = dup(pty_slave_fd);
 		    close(1);
-		    dup(pty_slave_fd);
+		    ignored = dup(pty_slave_fd);
 		    if (gui.in_use)
 		    {
 			close(2);
-			dup(pty_slave_fd);
+			ignored = dup(pty_slave_fd);
 		    }
 
 		    close(pty_slave_fd);    /* has been dupped, close it now */
@@ -4013,13 +4031,13 @@
 		    /* set up stdin for the child */
 		    close(fd_toshell[1]);
 		    close(0);
-		    dup(fd_toshell[0]);
+		    ignored = dup(fd_toshell[0]);
 		    close(fd_toshell[0]);
 
 		    /* set up stdout for the child */
 		    close(fd_fromshell[0]);
 		    close(1);
-		    dup(fd_fromshell[1]);
+		    ignored = dup(fd_fromshell[1]);
 		    close(fd_fromshell[1]);
 
 # ifdef FEAT_GUI
@@ -4027,7 +4045,7 @@
 		    {
 			/* set up stderr for the child */
 			close(2);
-			dup(1);
+			ignored = dup(1);
 		    }
 # endif
 		}
@@ -4078,6 +4096,9 @@
 		int	    fromshell_fd;
 		garray_T    ga;
 		int	    noread_cnt;
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		struct timeval  start_tv;
+# endif
 
 # ifdef FEAT_GUI
 		if (pty_master_fd >= 0)
@@ -4146,9 +4167,10 @@
 			    {
 				s = vim_strchr(lp + written, NL);
 				len = write(toshell_fd, (char *)lp + written,
-					   s == NULL ? l : s - (lp + written));
+					   s == NULL ? l
+					      : (size_t)(s - (lp + written)));
 			    }
-			    if (len == l)
+			    if (len == (int)l)
 			    {
 				/* Finished a line, add a NL, unless this line
 				 * should not have one. */
@@ -4158,7 +4180,8 @@
 					    && (lnum !=
 						    curbuf->b_ml.ml_line_count
 						    || curbuf->b_p_eol)))
-				    write(toshell_fd, "\n", (size_t)1);
+				    ignored = write(toshell_fd, "\n",
+								   (size_t)1);
 				++lnum;
 				if (lnum > curbuf->b_op_end.lnum)
 				{
@@ -4186,7 +4209,9 @@
 		    ga_init2(&ga, 1, BUFLEN);
 
 		noread_cnt = 0;
-
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		gettimeofday(&start_tv, NULL);
+# endif
 		for (;;)
 		{
 		    /*
@@ -4199,25 +4224,34 @@
 		     * that a typed password is echoed for ssh or gpg command.
 		     * Don't get characters when the child has already
 		     * finished (wait_pid == 0).
-		     * Don't get extra characters when we already have one.
 		     * Don't read characters unless we didn't get output for a
-		     * while, avoids that ":r !ls" eats typeahead.
+		     * while (noread_cnt > 4), avoids that ":r !ls" eats
+		     * typeahead.
 		     */
 		    len = 0;
 		    if (!(options & SHELL_EXPAND)
 			    && ((options &
 					 (SHELL_READ|SHELL_WRITE|SHELL_COOKED))
 				      != (SHELL_READ|SHELL_WRITE|SHELL_COOKED)
-#ifdef FEAT_GUI
+# ifdef FEAT_GUI
 						    || gui.in_use
-#endif
+# endif
 						    )
 			    && wait_pid == 0
-			    && (ta_len > 0
-				|| (noread_cnt > 4
-				    && (len = ui_inchar(ta_buf,
-						       BUFLEN, 10L, 0)) > 0)))
+			    && (ta_len > 0 || noread_cnt > 4))
 		    {
+		      if (ta_len == 0)
+		      {
+			  /* Get extra characters when we don't have any.
+			   * Reset the counter and timer. */
+			  noread_cnt = 0;
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+			  gettimeofday(&start_tv, NULL);
+# endif
+			  len = ui_inchar(ta_buf, BUFLEN, 10L, 0);
+		      }
+		      if (ta_len > 0 || len > 0)
+		      {
 			/*
 			 * For pipes:
 			 * Check for CTRL-C: send interrupt signal to child.
@@ -4319,9 +4353,9 @@
 			    {
 				ta_len -= len;
 				mch_memmove(ta_buf, ta_buf + len, ta_len);
-				noread_cnt = 0;
 			    }
 			}
+		      }
 		    }
 
 		    if (got_int)
@@ -4429,6 +4463,25 @@
 			out_flush();
 			if (got_int)
 			    break;
+
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+			{
+			    struct timeval  now_tv;
+			    long	    msec;
+
+			    /* Avoid that we keep looping here without
+			     * checking for a CTRL-C for a long time.  Don't
+			     * break out too often to avoid losing typeahead. */
+			    gettimeofday(&now_tv, NULL);
+			    msec = (now_tv.tv_sec - start_tv.tv_sec) * 1000L
+				+ (now_tv.tv_usec - start_tv.tv_usec) / 1000L;
+			    if (msec > 2000)
+			    {
+				noread_cnt = 5;
+				break;
+			    }
+			}
+# endif
 		    }
 
 		    /* If we already detected the child has finished break the
@@ -4672,7 +4725,6 @@
  * Returns also, when a request from Sniff is waiting -- toni.
  * Or when a Linux GPM mouse event is waiting.
  */
-/* ARGSUSED */
 #if defined(__BEOS__)
     int
 #else
@@ -4681,7 +4733,7 @@
 RealWaitForChar(fd, msec, check_for_gpm)
     int		fd;
     long	msec;
-    int		*check_for_gpm;
+    int		*check_for_gpm UNUSED;
 {
     int		ret;
 #if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)
@@ -5076,7 +5128,6 @@
 
 #define SHELL_SPECIAL (char_u *)"\t \"&'$;<>()\\|"
 
-/* ARGSUSED */
     int
 mch_expand_wildcards(num_pat, pat, num_file, file, flags)
     int		   num_pat;
@@ -5498,7 +5549,7 @@
     i = fread((char *)buffer, 1, len, fd);
     fclose(fd);
     mch_remove(tempname);
-    if (i != len)
+    if (i != (int)len)
     {
 	/* unexpected read error */
 	EMSG2(_(e_notread), tempname);
@@ -5559,7 +5610,7 @@
 	if (shell_style == STYLE_PRINT && !did_find_nul)
 	{
 	    /* If there is a NUL, set did_find_nul, else set check_spaces */
-	    if (len && (int)STRLEN(buffer) < len - 1)
+	    if (len && (int)STRLEN(buffer) < (int)len - 1)
 		did_find_nul = TRUE;
 	    else
 		check_spaces = TRUE;
@@ -5851,7 +5902,9 @@
 	     * we are going to suspend or starting an external process
 	     * so we shouldn't  have problem with this
 	     */
+# ifdef SIGTSTP
 	    signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);
+# endif
 	    return 1; /* succeed */
 	}
 	if (gpm_fd == -2)
@@ -6001,7 +6054,6 @@
 /*
  * Gets info from sysmouse and adds special keys to input buf.
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sig_sysmouse SIGDEFARG(sigarg)
 {
@@ -6565,11 +6617,10 @@
  * This is our chance to ask the user if they want to save,
  * or abort the logout
  */
-/*ARGSUSED*/
     static void
 xsmp_handle_interaction(smc_conn, client_data)
     SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmPointer	client_data UNUSED;
 {
     cmdmod_T	save_cmdmod;
     int		cancel_shutdown = False;
@@ -6602,16 +6653,15 @@
 /*
  * Callback that starts save-yourself.
  */
-/*ARGSUSED*/
     static void
 xsmp_handle_save_yourself(smc_conn, client_data, save_type,
 					       shutdown, interact_style, fast)
     SmcConn	smc_conn;
-    SmPointer	client_data;
-    int		save_type;
+    SmPointer	client_data UNUSED;
+    int		save_type UNUSED;
     Bool	shutdown;
-    int		interact_style;
-    Bool	fast;
+    int		interact_style UNUSED;
+    Bool	fast UNUSED;
 {
     /* Handle already being in saveyourself */
     if (xsmp.save_yourself)
@@ -6645,11 +6695,10 @@
 /*
  * Callback to warn us of imminent death.
  */
-/*ARGSUSED*/
     static void
 xsmp_die(smc_conn, client_data)
-    SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmcConn	smc_conn UNUSED;
+    SmPointer	client_data UNUSED;
 {
     xsmp_close();
 
@@ -6661,11 +6710,10 @@
 /*
  * Callback to tell us that save-yourself has completed.
  */
-/*ARGSUSED*/
     static void
 xsmp_save_complete(smc_conn, client_data)
-    SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmcConn	smc_conn UNUSED;
+    SmPointer	client_data UNUSED;
 {
     xsmp.save_yourself = False;
 }
@@ -6675,11 +6723,10 @@
  * Callback to tell us that an instigated shutdown was cancelled
  * (maybe even by us)
  */
-/*ARGSUSED*/
     static void
 xsmp_shutdown_cancelled(smc_conn, client_data)
     SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmPointer	client_data UNUSED;
 {
     if (xsmp.save_yourself)
 	SmcSaveYourselfDone(smc_conn, True);
@@ -6691,13 +6738,12 @@
 /*
  * Callback to tell us that a new ICE connection has been established.
  */
-/*ARGSUSED*/
     static void
 xsmp_ice_connection(iceConn, clientData, opening, watchData)
     IceConn	iceConn;
-    IcePointer	clientData;
+    IcePointer	clientData UNUSED;
     Bool	opening;
-    IcePointer	*watchData;
+    IcePointer	*watchData UNUSED;
 {
     /* Intercept creation of ICE connection fd */
     if (opening)
@@ -6814,7 +6860,8 @@
     if (xsmp_icefd != -1)
     {
 	SmcCloseConnection(xsmp.smcconn, 0, NULL);
-	vim_free(xsmp.clientid);
+	if (xsmp.clientid != NULL)
+	    free(xsmp.clientid);
 	xsmp.clientid = NULL;
 	xsmp_icefd = -1;
     }
diff -Naur vim72.orig/src/os_unix.h vim72/src/os_unix.h
--- vim72.orig/src/os_unix.h	2008-06-17 11:01:17.000000000 -0700
+++ vim72/src/os_unix.h	2009-06-05 14:24:58.000000000 -0700
@@ -124,7 +124,7 @@
 #  define SIGDUMMYARG	0, 0, (struct sigcontext *)0
 # else
 #  define SIGPROTOARG	(int)
-#  define SIGDEFARG(s)	(s) int s;
+#  define SIGDEFARG(s)	(s) int s UNUSED;
 #  define SIGDUMMYARG	0
 # endif
 #else
diff -Naur vim72.orig/src/proto/buffer.pro vim72/src/proto/buffer.pro
--- vim72.orig/src/proto/buffer.pro	2008-08-09 07:31:21.000000000 -0700
+++ vim72/src/proto/buffer.pro	2009-06-05 14:24:27.000000000 -0700
@@ -37,13 +37,12 @@
 int otherfile __ARGS((char_u *ffname));
 void buf_setino __ARGS((buf_T *buf));
 void fileinfo __ARGS((int fullname, int shorthelp, int dont_truncate));
-void col_print __ARGS((char_u *buf, int col, int vcol));
+void col_print __ARGS((char_u *buf, size_t buflen, int col, int vcol));
 void maketitle __ARGS((void));
 void resettitle __ARGS((void));
 void free_titles __ARGS((void));
 int build_stl_str_hl __ARGS((win_T *wp, char_u *out, size_t outlen, char_u *fmt, int use_sandbox, int fillchar, int maxwidth, struct stl_hlrec *hltab, struct stl_hlrec *tabtab));
-void get_rel_pos __ARGS((win_T *wp, char_u *str));
-int append_arg_number __ARGS((win_T *wp, char_u *buf, int add_file, int maxlen));
+void get_rel_pos __ARGS((win_T *wp, char_u *buf, int buflen));
 char_u *fix_fname __ARGS((char_u *fname));
 void fname_expand __ARGS((buf_T *buf, char_u **ffname, char_u **sfname));
 char_u *alist_name __ARGS((aentry_T *aep));
@@ -54,8 +53,8 @@
 void write_viminfo_bufferlist __ARGS((FILE *fp));
 char *buf_spname __ARGS((buf_T *buf));
 void buf_addsign __ARGS((buf_T *buf, int id, linenr_T lnum, int typenr));
-int buf_change_sign_type __ARGS((buf_T *buf, int markId, int typenr));
-int_u buf_getsigntype __ARGS((buf_T *buf, linenr_T lnum, int type));
+linenr_T buf_change_sign_type __ARGS((buf_T *buf, int markId, int typenr));
+int buf_getsigntype __ARGS((buf_T *buf, linenr_T lnum, int type));
 linenr_T buf_delsign __ARGS((buf_T *buf, int id));
 int buf_findsign __ARGS((buf_T *buf, int id));
 int buf_findsign_id __ARGS((buf_T *buf, linenr_T lnum));
diff -Naur vim72.orig/src/proto/edit.pro vim72/src/proto/edit.pro
--- vim72.orig/src/proto/edit.pro	2008-08-09 07:31:24.000000000 -0700
+++ vim72/src/proto/edit.pro	2009-06-05 14:24:27.000000000 -0700
@@ -8,7 +8,7 @@
 void backspace_until_column __ARGS((int col));
 int vim_is_ctrl_x_key __ARGS((int c));
 int ins_compl_add_infercase __ARGS((char_u *str, int len, int icase, char_u *fname, int dir, int flags));
-void set_completion __ARGS((int startcol, list_T *list));
+void set_completion __ARGS((colnr_T startcol, list_T *list));
 void ins_compl_show_pum __ARGS((void));
 char_u *find_word_start __ARGS((char_u *ptr));
 char_u *find_word_end __ARGS((char_u *ptr));
diff -Naur vim72.orig/src/proto/eval.pro vim72/src/proto/eval.pro
--- vim72.orig/src/proto/eval.pro	2008-08-09 07:31:25.000000000 -0700
+++ vim72/src/proto/eval.pro	2009-06-05 14:17:16.000000000 -0700
@@ -17,7 +17,7 @@
 int eval_to_bool __ARGS((char_u *arg, int *error, char_u **nextcmd, int skip));
 char_u *eval_to_string_skip __ARGS((char_u *arg, char_u **nextcmd, int skip));
 int skip_expr __ARGS((char_u **pp));
-char_u *eval_to_string __ARGS((char_u *arg, char_u **nextcmd, int dolist));
+char_u *eval_to_string __ARGS((char_u *arg, char_u **nextcmd, int convert));
 char_u *eval_to_string_safe __ARGS((char_u *arg, char_u **nextcmd, int use_sandbox));
 int eval_to_number __ARGS((char_u *expr));
 list_T *eval_spell_expr __ARGS((char_u *badword, char_u *expr));
@@ -46,7 +46,9 @@
 void list_unref __ARGS((list_T *l));
 void list_free __ARGS((list_T *l, int recurse));
 dictitem_T *dict_lookup __ARGS((hashitem_T *hi));
+char_u *list_find_str __ARGS((list_T *l, long idx));
 int list_append_dict __ARGS((list_T *list, dict_T *dict));
+int list_append_string __ARGS((list_T *l, char_u *str, int len));
 int garbage_collect __ARGS((void));
 dict_T *dict_alloc __ARGS((void));
 int dict_add_nr_str __ARGS((dict_T *d, char *key, long nr, char_u *str));
@@ -58,8 +60,10 @@
 void set_vim_var_nr __ARGS((int idx, long val));
 long get_vim_var_nr __ARGS((int idx));
 char_u *get_vim_var_str __ARGS((int idx));
-void set_vcount __ARGS((long count, long count1));
+list_T *get_vim_var_list __ARGS((int idx));
+void set_vcount __ARGS((long count, long count1, int set_prevcount));
 void set_vim_var_string __ARGS((int idx, char_u *val, int len));
+void set_vim_var_list __ARGS((int idx, list_T *val));
 void set_reg_var __ARGS((int c));
 char_u *v_exception __ARGS((char_u *oldval));
 char_u *v_throwpoint __ARGS((char_u *oldval));
@@ -94,6 +98,7 @@
 void write_viminfo_varlist __ARGS((FILE *fp));
 int store_session_globals __ARGS((FILE *fd));
 void last_set_msg __ARGS((scid_T scriptID));
+void ex_oldfiles __ARGS((exarg_T *eap));
 int modify_fname __ARGS((char_u *src, int *usedlen, char_u **fnamep, char_u **bufp, int *fnamelen));
 char_u *do_string_sub __ARGS((char_u *str, char_u *pat, char_u *sub, char_u *flags));
 /* vim: set ft=c : */
diff -Naur vim72.orig/src/proto/ex_cmds.pro vim72/src/proto/ex_cmds.pro
--- vim72.orig/src/proto/ex_cmds.pro	2008-08-09 07:31:25.000000000 -0700
+++ vim72/src/proto/ex_cmds.pro	2009-06-05 14:24:34.000000000 -0700
@@ -9,9 +9,9 @@
 void do_bang __ARGS((int addr_count, exarg_T *eap, int forceit, int do_in, int do_out));
 void do_shell __ARGS((char_u *cmd, int flags));
 char_u *make_filter_cmd __ARGS((char_u *cmd, char_u *itmp, char_u *otmp));
-void append_redir __ARGS((char_u *buf, char_u *opt, char_u *fname));
+void append_redir __ARGS((char_u *buf, int buflen, char_u *opt, char_u *fname));
 int viminfo_error __ARGS((char *errnum, char *message, char_u *line));
-int read_viminfo __ARGS((char_u *file, int want_info, int want_marks, int forceit));
+int read_viminfo __ARGS((char_u *file, int flags));
 void write_viminfo __ARGS((char_u *file, int forceit));
 int viminfo_readline __ARGS((vir_T *virp));
 char_u *viminfo_readstring __ARGS((vir_T *virp, int off, int convert));
@@ -55,5 +55,8 @@
 char_u *sign_get_text __ARGS((int typenr));
 void *sign_get_image __ARGS((int typenr));
 char_u *sign_typenr2name __ARGS((int typenr));
+void free_signs __ARGS((void));
+char_u *get_sign_name __ARGS((expand_T *xp, int idx));
+void set_context_in_sign_cmd __ARGS((expand_T *xp, char_u *arg));
 void ex_drop __ARGS((exarg_T *eap));
 /* vim: set ft=c : */
diff -Naur vim72.orig/src/proto/ex_getln.pro vim72/src/proto/ex_getln.pro
--- vim72.orig/src/proto/ex_getln.pro	2008-08-09 07:31:28.000000000 -0700
+++ vim72/src/proto/ex_getln.pro	2009-06-05 14:22:42.000000000 -0700
@@ -4,6 +4,7 @@
 int text_locked __ARGS((void));
 void text_locked_msg __ARGS((void));
 int curbuf_locked __ARGS((void));
+int allbuf_locked __ARGS((void));
 char_u *getexline __ARGS((int c, void *dummy, int indent));
 char_u *getexmodeline __ARGS((int promptc, void *dummy, int indent));
 int cmdline_overstrike __ARGS((void));
@@ -31,7 +32,7 @@
 void set_cmd_context __ARGS((expand_T *xp, char_u *str, int len, int col));
 int expand_cmdline __ARGS((expand_T *xp, char_u *str, int col, int *matchcount, char_u ***matches));
 int ExpandGeneric __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file, char_u *((*func)(expand_T *, int))));
-char_u *globpath __ARGS((char_u *path, char_u *file));
+char_u *globpath __ARGS((char_u *path, char_u *file, int expand_options));
 void init_history __ARGS((void));
 int get_histtype __ARGS((char_u *name));
 void add_to_history __ARGS((int histype, char_u *new_entry, int in_map, int sep));
diff -Naur vim72.orig/src/proto/if_cscope.pro vim72/src/proto/if_cscope.pro
--- vim72.orig/src/proto/if_cscope.pro	2008-08-09 07:31:33.000000000 -0700
+++ vim72/src/proto/if_cscope.pro	2009-06-05 14:23:53.000000000 -0700
@@ -1,4 +1,6 @@
 /* if_cscope.c */
+char_u *get_cscope_name __ARGS((expand_T *xp, int idx));
+void set_context_in_cscope_cmd __ARGS((expand_T *xp, char_u *arg, cmdidx_T cmdidx));
 void do_cscope __ARGS((exarg_T *eap));
 void do_scscope __ARGS((exarg_T *eap));
 void do_cstag __ARGS((exarg_T *eap));
diff -Naur vim72.orig/src/proto/mark.pro vim72/src/proto/mark.pro
--- vim72.orig/src/proto/mark.pro	2008-08-09 07:31:36.000000000 -0700
+++ vim72/src/proto/mark.pro	2009-06-05 14:16:09.000000000 -0700
@@ -26,5 +26,5 @@
 void write_viminfo_filemarks __ARGS((FILE *fp));
 int removable __ARGS((char_u *name));
 int write_viminfo_marks __ARGS((FILE *fp_out));
-void copy_viminfo_marks __ARGS((vir_T *virp, FILE *fp_out, int count, int eof));
+void copy_viminfo_marks __ARGS((vir_T *virp, FILE *fp_out, int count, int eof, int flags));
 /* vim: set ft=c : */
diff -Naur vim72.orig/src/proto/message.pro vim72/src/proto/message.pro
--- vim72.orig/src/proto/message.pro	2008-08-09 07:31:39.000000000 -0700
+++ vim72/src/proto/message.pro	2009-06-05 14:23:41.000000000 -0700
@@ -54,6 +54,7 @@
 void msg_clr_cmdline __ARGS((void));
 int msg_end __ARGS((void));
 void msg_check __ARGS((void));
+int redirecting __ARGS((void));
 void verbose_enter __ARGS((void));
 void verbose_leave __ARGS((void));
 void verbose_enter_scroll __ARGS((void));
diff -Naur vim72.orig/src/proto/misc2.pro vim72/src/proto/misc2.pro
--- vim72.orig/src/proto/misc2.pro	2008-08-09 07:31:40.000000000 -0700
+++ vim72/src/proto/misc2.pro	2009-06-05 14:19:07.000000000 -0700
@@ -59,7 +59,7 @@
 int handle_x_keys __ARGS((int key));
 char_u *get_special_key_name __ARGS((int c, int modifiers));
 int trans_special __ARGS((char_u **srcp, char_u *dst, int keycode));
-int find_special_key __ARGS((char_u **srcp, int *modp, int keycode));
+int find_special_key __ARGS((char_u **srcp, int *modp, int keycode, int keep_x_key));
 int extract_modifiers __ARGS((int key, int *modp));
 int find_special_key_in_table __ARGS((int c));
 int get_special_key_code __ARGS((char_u *name));
diff -Naur vim72.orig/src/proto/netbeans.pro vim72/src/proto/netbeans.pro
--- vim72.orig/src/proto/netbeans.pro	2008-08-09 07:31:56.000000000 -0700
+++ vim72/src/proto/netbeans.pro	2009-06-05 14:19:24.000000000 -0700
@@ -11,7 +11,7 @@
 void netbeans_frame_moved __ARGS((int new_x, int new_y));
 void netbeans_file_activated __ARGS((buf_T *bufp));
 void netbeans_file_opened __ARGS((buf_T *bufp));
-void netbeans_file_closed __ARGS((buf_T *bufp));
+void netbeans_file_killed __ARGS((buf_T *bufp));
 void netbeans_inserted __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, char_u *txt, int newlen));
 void netbeans_removed __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, long len));
 void netbeans_unmodified __ARGS((buf_T *bufp));
diff -Naur vim72.orig/src/proto/option.pro vim72/src/proto/option.pro
--- vim72.orig/src/proto/option.pro	2008-08-09 07:31:43.000000000 -0700
+++ vim72/src/proto/option.pro	2009-06-05 14:21:21.000000000 -0700
@@ -44,6 +44,7 @@
 void set_context_in_set_cmd __ARGS((expand_T *xp, char_u *arg, int opt_flags));
 int ExpandSettings __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file));
 int ExpandOldSetting __ARGS((int *num_file, char_u ***file));
+int langmap_adjust_mb __ARGS((int c));
 int has_format_option __ARGS((int x));
 int shortmess __ARGS((int x));
 void vimrc_found __ARGS((char_u *fname, char_u *envname));
diff -Naur vim72.orig/src/proto/spell.pro vim72/src/proto/spell.pro
--- vim72.orig/src/proto/spell.pro	2008-08-09 07:31:48.000000000 -0700
+++ vim72/src/proto/spell.pro	2009-06-05 14:24:34.000000000 -0700
@@ -22,5 +22,5 @@
 char_u *spell_to_word_end __ARGS((char_u *start, buf_T *buf));
 int spell_word_start __ARGS((int startcol));
 void spell_expand_check_cap __ARGS((colnr_T col));
-int expand_spelling __ARGS((linenr_T lnum, int col, char_u *pat, char_u ***matchp));
+int expand_spelling __ARGS((linenr_T lnum, char_u *pat, char_u ***matchp));
 /* vim: set ft=c : */
diff -Naur vim72.orig/src/pty.c vim72/src/pty.c
--- vim72.orig/src/pty.c	2008-06-21 11:52:58.000000000 -0700
+++ vim72/src/pty.c	2009-06-05 14:13:54.000000000 -0700
@@ -270,9 +270,10 @@
 }
 #endif
 
-#if defined(HAVE_SVR4_PTYS) && !defined(PTY_DONE) && !defined(hpux)
+#if defined(HAVE_SVR4_PTYS) && !defined(PTY_DONE) && !defined(hpux) && !defined(MACOS_X)
 
-/* NOTE: Even though HPUX can have /dev/ptmx, the code below doesn't work! */
+/* NOTE: Even though HPUX can have /dev/ptmx, the code below doesn't work!
+ * Same for Mac OS X Leopard. */
 #define PTY_DONE
     int
 OpenPTY(ttyn)
diff -Naur vim72.orig/src/quickfix.c vim72/src/quickfix.c
--- vim72.orig/src/quickfix.c	2008-07-18 05:53:02.000000000 -0700
+++ vim72/src/quickfix.c	2009-06-05 14:25:15.000000000 -0700
@@ -1419,6 +1419,7 @@
     int			opened_window = FALSE;
     win_T		*win;
     win_T		*altwin;
+    int			flags;
 #endif
     int			print_message = TRUE;
     int			len;
@@ -1530,7 +1531,6 @@
     if (qf_ptr->qf_type == 1 && (!curwin->w_buffer->b_help || cmdmod.tab != 0))
     {
 	win_T	*wp;
-	int	n;
 
 	if (cmdmod.tab != 0)
 	    wp = NULL;
@@ -1546,13 +1546,16 @@
 	     * Split off help window; put it at far top if no position
 	     * specified, the current window is vertically split and narrow.
 	     */
-	    n = WSP_HELP;
+	    flags = WSP_HELP;
 # ifdef FEAT_VERTSPLIT
 	    if (cmdmod.split == 0 && curwin->w_width != Columns
 						      && curwin->w_width < 80)
-		n |= WSP_TOP;
+		flags |= WSP_TOP;
 # endif
-	    if (win_split(0, n) == FAIL)
+	    if (qi != &ql_info)
+		flags |= WSP_NEWLOC;  /* don't copy the location list */
+
+	    if (win_split(0, flags) == FAIL)
 		goto theend;
 	    opened_window = TRUE;	/* close it when fail */
 
@@ -1562,7 +1565,6 @@
 	    if (qi != &ql_info)	    /* not a quickfix list */
 	    {
 		/* The new window should use the supplied location list */
-		qf_free_all(curwin);
 		curwin->w_llist = qi;
 		qi->qf_refcount++;
 	    }
@@ -1609,10 +1611,11 @@
 		{
 		    goto_tabpage_win(tp, wp);
 		    usable_win = 1;
-		    break;
+		    goto win_found;
 		}
 	    }
 	}
+win_found:
 
 	/*
 	 * If there is only one window and it is the quickfix window, create a
@@ -1622,7 +1625,10 @@
 	{
 	    ll_ref = curwin->w_llist_ref;
 
-	    if (win_split(0, WSP_ABOVE) == FAIL)
+	    flags = WSP_ABOVE;
+	    if (ll_ref != NULL)
+		flags |= WSP_NEWLOC;
+	    if (win_split(0, flags) == FAIL)
 		goto failed;		/* not enough room for window */
 	    opened_window = TRUE;	/* close it when fail */
 	    p_swb = empty_option;	/* don't split again */
@@ -1634,7 +1640,6 @@
 	    {
 		/* The new window should use the location list from the
 		 * location list window */
-		qf_free_all(curwin);
 		curwin->w_llist = ll_ref;
 		ll_ref->qf_refcount++;
 	    }
@@ -2233,7 +2238,6 @@
  * ":cclose": close the window showing the list of errors.
  * ":lclose": close the window showing the location list
  */
-/*ARGSUSED*/
     void
 ex_cclose(eap)
     exarg_T	*eap;
@@ -2307,15 +2311,12 @@
 	if (eap->cmdidx == CMD_copen || eap->cmdidx == CMD_cwindow)
 	    /* Create the new window at the very bottom. */
 	    win_goto(lastwin);
-	if (win_split(height, WSP_BELOW) == FAIL)
+	if (win_split(height, WSP_BELOW | WSP_NEWLOC) == FAIL)
 	    return;		/* not enough room for window */
 #ifdef FEAT_SCROLLBIND
 	curwin->w_p_scb = FALSE;
 #endif
 
-	/* Remove the location list for the quickfix window */
-	qf_free_all(curwin);
-
 	if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
 	{
 	    /*
@@ -2339,7 +2340,13 @@
 	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
 								   OPT_LOCAL);
 	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
-	    set_option_value((char_u *)"diff", 0L, NULL, OPT_LOCAL);
+#ifdef FEAT_DIFF
+	    curwin->w_p_diff = FALSE;
+#endif
+#ifdef FEAT_FOLDING
+	    set_option_value((char_u *)"fdm", 0L, (char_u *)"manual",
+								   OPT_LOCAL);
+#endif
 	}
 
 	/* Only set the height when still in the same tab page and there is no
@@ -2600,10 +2607,12 @@
     curbuf->b_p_ma = FALSE;
 
 #ifdef FEAT_AUTOCMD
+    keep_filetype = TRUE;		/* don't detect 'filetype' */
     apply_autocmds(EVENT_BUFREADPOST, (char_u *)"quickfix", NULL,
 							       FALSE, curbuf);
     apply_autocmds(EVENT_BUFWINENTER, (char_u *)"quickfix", NULL,
 							       FALSE, curbuf);
+    keep_filetype = FALSE;
 #endif
 
     /* make sure it will be redrawn */
@@ -2759,7 +2768,7 @@
     sprintf((char *)cmd, "%s%s%s", (char *)p_shq, (char *)eap->arg,
 							       (char *)p_shq);
     if (*p_sp != NUL)
-	append_redir(cmd, p_sp, fname);
+	append_redir(cmd, len, p_sp, fname);
     /*
      * Output a newline if there's something else than the :make command that
      * was typed (in which case the cursor is in column 0).
@@ -3196,7 +3205,7 @@
 			break;
 		    col = regmatch.endpos[0].col
 					    + (col == regmatch.endpos[0].col);
-		    if (col > STRLEN(ml_get_buf(buf, lnum, FALSE)))
+		    if (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))
 			break;
 		}
 		line_breakcheck();
diff -Naur vim72.orig/src/regexp.c vim72/src/regexp.c
--- vim72.orig/src/regexp.c	2008-08-07 12:58:50.000000000 -0700
+++ vim72/src/regexp.c	2009-06-05 14:24:51.000000000 -0700
@@ -471,7 +471,7 @@
 
     if ((*pp)[1] == ':')
     {
-	for (i = 0; i < sizeof(class_names) / sizeof(*class_names); ++i)
+	for (i = 0; i < (int)(sizeof(class_names) / sizeof(*class_names)); ++i)
 	    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)
 	    {
 		*pp += STRLEN(class_names[i]) + 2;
@@ -3362,12 +3362,11 @@
  * Match a regexp against a string ("line" points to the string) or multiple
  * lines ("line" is NULL, use reg_getline()).
  */
-/*ARGSUSED*/
     static long
 vim_regexec_both(line, col, tm)
     char_u	*line;
     colnr_T	col;		/* column to start looking for match */
-    proftime_T	*tm;		/* timeout limit or NULL */
+    proftime_T	*tm UNUSED;	/* timeout limit or NULL */
 {
     regprog_T	*prog;
     char_u	*s;
@@ -4532,7 +4531,7 @@
 		cleanup_subexpr();
 		if (!REG_MULTI)		/* Single-line regexp */
 		{
-		    if (reg_endp[no] == NULL)
+		    if (reg_startp[no] == NULL || reg_endp[no] == NULL)
 		    {
 			/* Backref was not set: Match an empty string. */
 			len = 0;
@@ -4548,7 +4547,7 @@
 		}
 		else				/* Multi-line regexp */
 		{
-		    if (reg_endpos[no].lnum < 0)
+		    if (reg_startpos[no].lnum < 0 || reg_endpos[no].lnum < 0)
 		    {
 			/* Backref was not set: Match an empty string. */
 			len = 0;
@@ -7279,13 +7278,11 @@
     }
     else
     {
-	if (submatch_match->endp[no] == NULL)
+	s = submatch_match->startp[no];
+	if (s == NULL || submatch_match->endp[no] == NULL)
 	    retval = NULL;
 	else
-	{
-	    s = submatch_match->startp[no];
 	    retval = vim_strnsave(s, (int)(submatch_match->endp[no] - s));
-	}
     }
 
     return retval;
diff -Naur vim72.orig/src/screen.c vim72/src/screen.c
--- vim72.orig/src/screen.c	2008-07-24 07:45:07.000000000 -0700
+++ vim72/src/screen.c	2009-06-05 14:25:15.000000000 -0700
@@ -270,11 +270,10 @@
  * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
  * may become invalid and the whole window will have to be redrawn.
  */
-/*ARGSUSED*/
     void
 redrawWinline(lnum, invalid)
     linenr_T	lnum;
-    int		invalid;	/* window line height is invalid now */
+    int		invalid UNUSED;	/* window line height is invalid now */
 {
 #ifdef FEAT_FOLDING
     int		i;
@@ -2413,7 +2412,7 @@
 			&& (lnume < bot->lnum
 			    || (lnume == bot->lnum
 				&& (bot->col - (*p_sel == 'e'))
-		>= STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
+		>= (colnr_T)STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
 	{
 	    if (VIsual_mode == Ctrl_V)
 	    {
@@ -2439,9 +2438,17 @@
 
 #ifdef FEAT_SYN_HL
     /* Show 'cursorcolumn' in the fold line. */
-    if (wp->w_p_cuc && (int)wp->w_virtcol + txtcol < W_WIDTH(wp))
-	ScreenAttrs[off + wp->w_virtcol + txtcol] = hl_combine_attr(
-		 ScreenAttrs[off + wp->w_virtcol + txtcol], hl_attr(HLF_CUC));
+    if (wp->w_p_cuc)
+    {
+	txtcol += wp->w_virtcol;
+	if (wp->w_p_wrap)
+	    txtcol -= wp->w_skipcol;
+	else
+	    txtcol -= wp->w_leftcol;
+	if (txtcol >= 0 && txtcol < W_WIDTH(wp))
+	    ScreenAttrs[off + txtcol] = hl_combine_attr(
+				 ScreenAttrs[off + txtcol], hl_attr(HLF_CUC));
+    }
 #endif
 
     SCREEN_LINE(row + W_WINROW(wp), W_WINCOL(wp), (int)W_WIDTH(wp),
@@ -2541,14 +2548,13 @@
  *
  * Return the number of last row the line occupies.
  */
-/* ARGSUSED */
     static int
 win_line(wp, lnum, startrow, endrow, nochange)
     win_T	*wp;
     linenr_T	lnum;
     int		startrow;
     int		endrow;
-    int		nochange;		/* not updating for changed text */
+    int		nochange UNUSED;	/* not updating for changed text */
 {
     int		col;			/* visual column on screen */
     unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
@@ -2588,6 +2594,7 @@
     int		noinvcur = FALSE;	/* don't invert the cursor */
 #ifdef FEAT_VISUAL
     pos_T	*top, *bot;
+    int		lnum_in_visual_area = FALSE;
 #endif
     pos_T	pos;
     long	v;
@@ -2784,9 +2791,10 @@
 	    top = &VIsual;
 	    bot = &curwin->w_cursor;
 	}
+	lnum_in_visual_area = (lnum >= top->lnum && lnum <= bot->lnum);
 	if (VIsual_mode == Ctrl_V)	/* block mode */
 	{
-	    if (lnum >= top->lnum && lnum <= bot->lnum)
+	    if (lnum_in_visual_area)
 	    {
 		fromcol = wp->w_old_cursor_fcol;
 		tocol = wp->w_old_cursor_lcol;
@@ -2879,8 +2887,9 @@
 	}
 	else
 	    tocol = MAXCOL;
-	if (fromcol == tocol)		/* do at least one character */
-	    tocol = fromcol + 1;	/* happens when past end of line */
+	/* do at least one character; happens when past end of line */
+	if (fromcol == tocol)
+	    tocol = fromcol + 1;
 	area_highlighting = TRUE;
 	attr = hl_attr(HLF_I);
     }
@@ -3412,6 +3421,7 @@
 			&& (*mb_ptr2cells)(ptr) > 1)
 #endif
 		    || ((int)vcol_prev == fromcol_prev
+			&& vcol_prev < vcol	/* not at margin */
 			&& vcol < tocol))
 		area_attr = attr;		/* start highlighting */
 	    else if (area_attr != 0
@@ -3544,7 +3554,8 @@
 		/* Use line_attr when not in the Visual or 'incsearch' area
 		 * (area_attr may be 0 when "noinvcur" is set). */
 	    else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)
-					|| (vcol < fromcol || vcol >= tocol)))
+				|| vcol < fromcol || vcol_prev < fromcol_prev
+				|| vcol >= tocol))
 		char_attr = line_attr;
 #endif
 	    else
@@ -4106,6 +4117,7 @@
 # endif
 				    (col < W_WIDTH(wp)))
 				&& !(noinvcur
+				    && lnum == wp->w_cursor.lnum
 				    && (colnr_T)vcol == wp->w_virtcol)))
 			&& lcs_eol_one >= 0)
 		{
@@ -4247,7 +4259,7 @@
 	 * preedit_changed and commit.  Thus Vim can't set "im_is_active", use
 	 * im_is_preediting() here. */
 	if (xic != NULL
-		&& lnum == curwin->w_cursor.lnum
+		&& lnum == wp->w_cursor.lnum
 		&& (State & INSERT)
 		&& !p_imdisable
 		&& im_is_preediting()
@@ -4256,7 +4268,7 @@
 	    colnr_T tcol;
 
 	    if (preedit_end_col == MAXCOL)
-		getvcol(curwin, &(curwin->w_cursor), &tcol, NULL, NULL);
+		getvcol(curwin, &(wp->w_cursor), &tcol, NULL, NULL);
 	    else
 		tcol = preedit_end_col;
 	    if ((long)preedit_start_col <= vcol && vcol < (long)tcol)
@@ -4353,7 +4365,13 @@
 	    }
 #endif
 	    if (lcs_eol == lcs_eol_one
-		    && ((area_attr != 0 && vcol == fromcol && c == NUL)
+		    && ((area_attr != 0 && vcol == fromcol
+#ifdef FEAT_VISUAL
+			    && (VIsual_mode != Ctrl_V
+				|| lnum == VIsual.lnum
+				|| lnum == curwin->w_cursor.lnum)
+#endif
+			    && c == NUL)
 #ifdef FEAT_SEARCH_EXTRA
 			/* highlight 'hlsearch' match at end of line */
 			|| (prevcol_hl_flag == TRUE
@@ -4447,7 +4465,8 @@
 	if (c == NUL)
 	{
 #ifdef FEAT_SYN_HL
-	    if (eol_hl_off > 0 && vcol - eol_hl_off == (long)wp->w_virtcol)
+	    if (eol_hl_off > 0 && vcol - eol_hl_off == (long)wp->w_virtcol
+		    && lnum == wp->w_cursor.lnum)
 	    {
 		/* highlight last char after line */
 		--col;
@@ -4549,7 +4568,8 @@
 	 * highlight the cursor position itself. */
 	if (wp->w_p_cuc && vcol == (long)wp->w_virtcol
 		&& lnum != wp->w_cursor.lnum
-		&& draw_state == WL_LINE)
+		&& draw_state == WL_LINE
+		&& !lnum_in_visual_area)
 	{
 	    vcol_save_attr = char_attr;
 	    char_attr = hl_combine_attr(char_attr, hl_attr(HLF_CUC));
@@ -4652,7 +4672,7 @@
 	    --n_skip;
 
 	/* Only advance the "vcol" when after the 'number' column. */
-	if (draw_state >= WL_SBR
+	if (draw_state > WL_NR
 #ifdef FEAT_DIFF
 		&& filler_todo <= 0
 #endif
@@ -5119,8 +5139,8 @@
 #endif
 
 #if defined(FEAT_GUI) || defined(UNIX)
-	    /* The bold trick makes a single row of pixels appear in the next
-	     * character.  When a bold character is removed, the next
+	    /* The bold trick makes a single column of pixels appear in the
+	     * next character.  When a bold character is removed, the next
 	     * character should be redrawn too.  This happens for our own GUI
 	     * and for some xterms. */
 	    if (
@@ -6076,7 +6096,7 @@
 				fillchar, maxwidth, hltab, tabtab);
     len = (int)STRLEN(buf);
 
-    while (width < maxwidth && len < sizeof(buf) - 1)
+    while (width < maxwidth && len < (int)sizeof(buf) - 1)
     {
 #ifdef FEAT_MBYTE
 	len += (*mb_char2bytes)(fillchar, buf + len);
@@ -6263,9 +6283,15 @@
     int		pcc[MAX_MCO];
 # endif
 #endif
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+    int		force_redraw_this;
+    int		force_redraw_next = FALSE;
+#endif
+    int		need_redraw;
 
     if (ScreenLines == NULL || row >= screen_Rows)	/* safety check */
 	return;
+    off = LineOffset[row] + col;
 
 #ifdef FEAT_MBYTE
     /* When drawing over the right halve of a double-wide char clear out the
@@ -6275,10 +6301,21 @@
 	    && !gui.in_use
 # endif
 	    && mb_fix_col(col, row) != col)
-	screen_puts_len((char_u *)" ", 1, row, col - 1, 0);
+    {
+	ScreenLines[off - 1] = ' ';
+	ScreenAttrs[off - 1] = 0;
+	if (enc_utf8)
+	{
+	    ScreenLinesUC[off - 1] = 0;
+	    ScreenLinesC[0][off - 1] = 0;
+	}
+	/* redraw the previous cell, make it empty */
+	screen_char(off - 1, row, col - 1);
+	/* force the cell at "col" to be redrawn */
+	force_redraw_next = TRUE;
+    }
 #endif
 
-    off = LineOffset[row] + col;
 #ifdef FEAT_MBYTE
     max_off = LineOffset[row] + screen_Columns;
 #endif
@@ -6342,7 +6379,12 @@
 	}
 #endif
 
-	if (ScreenLines[off] != c
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+	force_redraw_this = force_redraw_next;
+	force_redraw_next = FALSE;
+#endif
+
+	need_redraw = ScreenLines[off] != c
 #ifdef FEAT_MBYTE
 		|| (mbyte_cells == 2
 		    && ScreenLines[off + 1] != (enc_dbcs ? ptr[1] : 0))
@@ -6350,24 +6392,24 @@
 		    && c == 0x8e
 		    && ScreenLines2[off] != ptr[1])
 		|| (enc_utf8
-		    && (ScreenLinesUC[off] != (u8char_T)u8c
+		    && (ScreenLinesUC[off] != (u8char_T)(c >= 0x80 ? u8c : 0)
 			|| screen_comp_differs(off, u8cc)))
 #endif
 		|| ScreenAttrs[off] != attr
-		|| exmode_active
+		|| exmode_active;
+
+	if (need_redraw
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+		|| force_redraw_this
+#endif
 		)
 	{
 #if defined(FEAT_GUI) || defined(UNIX)
 	    /* The bold trick makes a single row of pixels appear in the next
 	     * character.  When a bold character is removed, the next
 	     * character should be redrawn too.  This happens for our own GUI
-	     * and for some xterms.
-	     * Force the redraw by setting the attribute to a different value
-	     * than "attr", the contents of ScreenLines[] may be needed by
-	     * mb_off2cells() further on.
-	     * Don't do this for the last drawn character, because the next
-	     * character may not be redrawn. */
-	    if (
+	     * and for some xterms. */
+	    if (need_redraw && ScreenLines[off] != ' ' && (
 # ifdef FEAT_GUI
 		    gui.in_use
 # endif
@@ -6377,23 +6419,14 @@
 # ifdef UNIX
 		    term_is_xterm
 # endif
-	       )
+		    ))
 	    {
-		int		n;
+		int	n = ScreenAttrs[off];
 
-		n = ScreenAttrs[off];
-# ifdef FEAT_MBYTE
-		if (col + mbyte_cells < screen_Columns
-			&& (n > HL_ALL || (n & HL_BOLD))
-			&& (len < 0 ? ptr[mbyte_blen] != NUL
-					     : ptr + mbyte_blen < text + len))
-		    ScreenAttrs[off + mbyte_cells] = attr + 1;
-# else
-		if (col + 1 < screen_Columns
-			&& (n > HL_ALL || (n & HL_BOLD))
-			&& (len < 0 ? ptr[1] != NUL : ptr + 1 < text + len))
-		    ScreenLines[off + 1] = 0;
-# endif
+		if (n > HL_ALL)
+		    n = syn_attr2attr(n);
+		if (n & HL_BOLD)
+		    force_redraw_next = TRUE;
 	    }
 #endif
 #ifdef FEAT_MBYTE
@@ -6480,6 +6513,20 @@
 	    ++ptr;
 	}
     }
+
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+    /* If we detected the next character needs to be redrawn, but the text
+     * doesn't extend up to there, update the character here. */
+    if (force_redraw_next && col < screen_Columns)
+    {
+# ifdef FEAT_MBYTE
+	if (enc_dbcs != 0 && dbcs_off2cells(off, max_off) > 1)
+	    screen_char_2(off, row, col);
+	else
+# endif
+	    screen_char(off, row, col);
+    }
+#endif
 }
 
 #ifdef FEAT_SEARCH_EXTRA
@@ -7356,7 +7403,11 @@
 #endif
     static int	    entered = FALSE;		/* avoid recursiveness */
     static int	    done_outofmem_msg = FALSE;	/* did outofmem message */
+#ifdef FEAT_AUTOCMD
+    int		    retry_count = 0;
 
+retry:
+#endif
     /*
      * Allocation of the screen buffers is done only when the size changes and
      * when Rows and Columns have been set and we have started doing full
@@ -7440,10 +7491,13 @@
 	{
 	    outofmem = TRUE;
 #ifdef FEAT_WINDOWS
-	    break;
+	    goto give_up;
 #endif
 	}
     }
+#ifdef FEAT_WINDOWS
+give_up:
+#endif
 
 #ifdef FEAT_MBYTE
     for (i = 0; i < p_mco; ++i)
@@ -7628,8 +7682,17 @@
     --RedrawingDisabled;
 
 #ifdef FEAT_AUTOCMD
-    if (starting == 0)
+    /*
+     * Do not apply autocommands more than 3 times to avoid an endless loop
+     * in case applying autocommands always changes Rows or Columns.
+     */
+    if (starting == 0 && ++retry_count <= 3)
+    {
 	apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);
+	/* In rare cases, autocommands may have altered Rows or Columns,
+	 * jump back to check if we need to allocate the screen again. */
+	goto retry;
+    }
 #endif
 }
 
@@ -8590,7 +8653,6 @@
  *
  * Return OK for success, FAIL if the lines are not deleted.
  */
-/*ARGSUSED*/
     int
 screen_del_lines(off, row, line_count, end, force, wp)
     int		off;
@@ -8598,7 +8660,7 @@
     int		line_count;
     int		end;
     int		force;		/* even when line_count > p_ttyscroll */
-    win_T	*wp;		/* NULL or window to use width from */
+    win_T	*wp UNUSED;	/* NULL or window to use width from */
 {
     int		j;
     int		i;
@@ -9416,13 +9478,15 @@
     win_T	*wp;
     int		always;
 {
-    char_u	buffer[70];
+#define RULER_BUF_LEN 70
+    char_u	buffer[RULER_BUF_LEN];
     int		row;
     int		fillchar;
     int		attr;
     int		empty_line = FALSE;
     colnr_T	virtcol;
     int		i;
+    size_t	len;
     int		o;
 #ifdef FEAT_VERTSPLIT
     int		this_ru_col;
@@ -9537,11 +9601,12 @@
 	 * Some sprintfs return the length, some return a pointer.
 	 * To avoid portability problems we use strlen() here.
 	 */
-	sprintf((char *)buffer, "%ld,",
+	vim_snprintf((char *)buffer, RULER_BUF_LEN, "%ld,",
 		(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)
 		    ? 0L
 		    : (long)(wp->w_cursor.lnum));
-	col_print(buffer + STRLEN(buffer),
+	len = STRLEN(buffer);
+	col_print(buffer + len, RULER_BUF_LEN - len,
 			empty_line ? 0 : (int)wp->w_cursor.col + 1,
 			(int)virtcol + 1);
 
@@ -9551,7 +9616,7 @@
 	 * screen up on some terminals).
 	 */
 	i = (int)STRLEN(buffer);
-	get_rel_pos(wp, buffer + i + 1);
+	get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);
 	o = i + vim_strsize(buffer + i + 1);
 #ifdef FEAT_WINDOWS
 	if (wp->w_status_height == 0)	/* can't use last char of screen */
@@ -9578,7 +9643,7 @@
 		    buffer[i++] = fillchar;
 		++o;
 	    }
-	    get_rel_pos(wp, buffer + i);
+	    get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);
 	}
 	/* Truncate at window boundary. */
 #ifdef FEAT_MBYTE
diff -Naur vim72.orig/src/search.c vim72/src/search.c
--- vim72.orig/src/search.c	2008-07-13 11:18:27.000000000 -0700
+++ vim72/src/search.c	2009-06-05 14:25:15.000000000 -0700
@@ -345,6 +345,15 @@
 {
     vim_free(spats[0].pat);
     vim_free(spats[1].pat);
+
+# ifdef FEAT_RIGHTLEFT
+    if (mr_pattern_alloced)
+    {
+        vim_free(mr_pattern);
+        mr_pattern_alloced = FALSE;
+        mr_pattern = NULL;
+    }
+# endif
 }
 #endif
 
@@ -513,7 +522,6 @@
  * When FEAT_EVAL is defined, returns the index of the first matching
  * subpattern plus one; one if there was none.
  */
-/*ARGSUSED*/
     int
 searchit(win, buf, pos, dir, pat, count, options, pat_use, stop_lnum, tm)
     win_T	*win;		/* window to search in; can be NULL for a
@@ -526,7 +534,7 @@
     int		options;
     int		pat_use;	/* which pattern to use when "pat" is empty */
     linenr_T	stop_lnum;	/* stop after this line number when != 0 */
-    proftime_T	*tm;		/* timeout limit or NULL */
+    proftime_T	*tm UNUSED;	/* timeout limit or NULL */
 {
     int		found;
     linenr_T	lnum;		/* no init to shut up Apollo cc */
@@ -545,8 +553,6 @@
     int		save_called_emsg = called_emsg;
 #ifdef FEAT_SEARCH_EXTRA
     int		break_loop = FALSE;
-#else
-# define break_loop FALSE
 #endif
 
     if (search_regcomp(pat, RE_SEARCH, pat_use,
@@ -931,7 +937,10 @@
 	     * twice.
 	     */
 	    if (!p_ws || stop_lnum != 0 || got_int || called_emsg
-					       || break_loop || found || loop)
+#ifdef FEAT_SEARCH_EXTRA
+					       || break_loop
+#endif
+					       || found || loop)
 		break;
 
 	    /*
@@ -949,7 +958,11 @@
 		give_warning((char_u *)_(dir == BACKWARD
 					  ? top_bot_msg : bot_top_msg), TRUE);
 	}
-	if (got_int || called_emsg || break_loop)
+	if (got_int || called_emsg
+#ifdef FEAT_SEARCH_EXTRA
+		|| break_loop
+#endif
+		)
 	    break;
     }
     while (--count > 0 && found);   /* stop after count matches or no match */
@@ -2327,8 +2340,8 @@
 		    for (col = pos.col; check_prevcol(linep, col, '\\', &col);)
 			bslcnt++;
 		}
-		/* Only accept a match when 'M' is in 'cpo' or when ecaping is
-		 * what we expect. */
+		/* Only accept a match when 'M' is in 'cpo' or when escaping
+		 * is what we expect. */
 		if (cpo_bsl || (bslcnt & 1) == match_escaped)
 		{
 		    if (c == initc)
@@ -4514,12 +4527,11 @@
  * Find identifiers or defines in included files.
  * if p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.
  */
-/*ARGSUSED*/
     void
 find_pattern_in_path(ptr, dir, len, whole, skip_comments,
 				    type, count, action, start_lnum, end_lnum)
     char_u	*ptr;		/* pointer to search pattern */
-    int		dir;		/* direction of expansion */
+    int		dir UNUSED;	/* direction of expansion */
     int		len;		/* length of search pattern */
     int		whole;		/* match whole words only */
     int		skip_comments;	/* don't match inside comments */
@@ -4663,7 +4675,7 @@
 			    msg_putchar('\n');	    /* cursor below last one */
 			    if (!got_int)	    /* don't display if 'q'
 						       typed at "--more--"
-						       mesage */
+						       message */
 			    {
 				msg_home_replace_hl(new_fname);
 				MSG_PUTS(_(" (includes previously listed match)"));
@@ -4975,7 +4987,7 @@
 					    || IObuff[i-2] == '!'))))
 				IObuff[i++] = ' ';
 			}
-			/* copy as much as posible of the new word */
+			/* copy as much as possible of the new word */
 			if (p - aux >= IOSIZE - i)
 			    p = aux + IOSIZE - i - 1;
 			STRNCPY(IObuff + i, aux, p - aux);
@@ -5010,7 +5022,7 @@
 		    if (did_show)
 			msg_putchar('\n');	/* cursor below last one */
 		    if (!got_int)		/* don't display if 'q' typed
-						    at "--more--" mesage */
+						    at "--more--" message */
 			msg_home_replace_hl(curr_fname);
 		    prev_fname = curr_fname;
 		}
@@ -5092,7 +5104,7 @@
 		}
 		if (action != ACTION_SHOW)
 		{
-		    curwin->w_cursor.col = (colnr_T) (startp - line);
+		    curwin->w_cursor.col = (colnr_T)(startp - line);
 		    curwin->w_set_curswant = TRUE;
 		}
 
@@ -5119,7 +5131,8 @@
 		    && action == ACTION_EXPAND
 		    && !(compl_cont_status & CONT_SOL)
 #endif
-		    && *(p = startp + 1))
+		    && *startp != NUL
+		    && *(p = startp + 1) != NUL)
 		goto search_line;
 	}
 	line_breakcheck();
diff -Naur vim72.orig/src/spell.c vim72/src/spell.c
--- vim72.orig/src/spell.c	2008-07-12 12:20:55.000000000 -0700
+++ vim72/src/spell.c	2009-06-05 14:25:15.000000000 -0700
@@ -77,7 +77,7 @@
 
 /*
  * Do the opposite: based on a maximum end score and a known sound score,
- * compute the the maximum word score that can be used.
+ * compute the maximum word score that can be used.
  */
 #define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)
 
@@ -469,6 +469,7 @@
     garray_T	sl_comppat;	/* CHECKCOMPOUNDPATTERN items */
     regprog_T	*sl_compprog;	/* COMPOUNDRULE turned into a regexp progrm
 				 * (NULL when no compounding) */
+    char_u	*sl_comprules;	/* all COMPOUNDRULE concatenated (or NULL) */
     char_u	*sl_compstartflags; /* flags for first compound word */
     char_u	*sl_compallflags; /* all flags for compound words */
     char_u	sl_nobreak;	/* When TRUE: no spaces between words */
@@ -625,7 +626,7 @@
 /* TRUE if a word appears in the list of banned words.  */
 #define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&su->su_banned, word)))
 
-/* Number of suggestions kept when cleaning up.  we need to keep more than
+/* Number of suggestions kept when cleaning up.  We need to keep more than
  * what is displayed, because when rescore_suggestions() is called the score
  * may change and wrong suggestions may be removed later. */
 #define SUG_CLEAN_COUNT(su)    ((su)->su_maxcount < 130 ? 150 : (su)->su_maxcount + 20)
@@ -839,7 +840,10 @@
 static void slang_clear __ARGS((slang_T *lp));
 static void slang_clear_sug __ARGS((slang_T *lp));
 static void find_word __ARGS((matchinf_T *mip, int mode));
+static int match_checkcompoundpattern __ARGS((char_u *ptr, int wlen, garray_T *gap));
 static int can_compound __ARGS((slang_T *slang, char_u *word, char_u *flags));
+static int can_be_compound __ARGS((trystate_T *sp, slang_T *slang, char_u *compflags, int flag));
+static int match_compoundrule __ARGS((slang_T *slang, char_u *compflags));
 static int valid_word_prefix __ARGS((int totprefcnt, int arridx, int flags, char_u *word, slang_T *slang, int cond_req));
 static void find_prefix __ARGS((matchinf_T *mip, int mode));
 static int fold_more __ARGS((matchinf_T *mip));
@@ -946,8 +950,8 @@
  */
 #ifndef FEAT_MBYTE
 /* Non-multi-byte implementation. */
-# define SPELL_TOFOLD(c) ((c) < 256 ? spelltab.st_fold[c] : (c))
-# define SPELL_TOUPPER(c) ((c) < 256 ? spelltab.st_upper[c] : (c))
+# define SPELL_TOFOLD(c) ((c) < 256 ? (int)spelltab.st_fold[c] : (c))
+# define SPELL_TOUPPER(c) ((c) < 256 ? (int)spelltab.st_upper[c] : (c))
 # define SPELL_ISUPPER(c) ((c) < 256 ? spelltab.st_isu[c] : FALSE)
 #else
 # if defined(HAVE_WCHAR_H)
@@ -958,18 +962,18 @@
  * the "w" library function for characters above 255 if available. */
 # ifdef HAVE_TOWLOWER
 #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
-	    : (c) < 256 ? spelltab.st_fold[c] : towlower(c))
+	    : (c) < 256 ? (int)spelltab.st_fold[c] : (int)towlower(c))
 # else
 #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
-	    : (c) < 256 ? spelltab.st_fold[c] : (c))
+	    : (c) < 256 ? (int)spelltab.st_fold[c] : (c))
 # endif
 
 # ifdef HAVE_TOWUPPER
 #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
-	    : (c) < 256 ? spelltab.st_upper[c] : towupper(c))
+	    : (c) < 256 ? (int)spelltab.st_upper[c] : (int)towupper(c))
 # else
 #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
-	    : (c) < 256 ? spelltab.st_upper[c] : (c))
+	    : (c) < 256 ? (int)spelltab.st_upper[c] : (c))
 # endif
 
 # ifdef HAVE_ISWUPPER
@@ -1519,6 +1523,11 @@
 					    ((unsigned)flags >> 24)))
 		    continue;
 
+		/* If there is a match with a CHECKCOMPOUNDPATTERN rule
+		 * discard the compound word. */
+		if (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))
+		    continue;
+
 		if (mode == FIND_COMPOUND)
 		{
 		    int	    capflags;
@@ -1577,6 +1586,11 @@
 		    if (!can_compound(slang, fword, mip->mi_compflags))
 			continue;
 		}
+		else if (slang->sl_comprules != NULL
+			     && !match_compoundrule(slang, mip->mi_compflags))
+		    /* The compound flags collected so far do not match any
+		     * COMPOUNDRULE, discard the compounded word. */
+		    continue;
 	    }
 
 	    /* Check NEEDCOMPOUND: can't use word without compounding. */
@@ -1727,6 +1741,39 @@
 }
 
 /*
+ * Return TRUE if there is a match between the word ptr[wlen] and
+ * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another
+ * word.
+ * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the
+ * end of ptr[wlen] and the second part matches after it.
+ */
+    static int
+match_checkcompoundpattern(ptr, wlen, gap)
+    char_u	*ptr;
+    int		wlen;
+    garray_T	*gap;  /* &sl_comppat */
+{
+    int		i;
+    char_u	*p;
+    int		len;
+
+    for (i = 0; i + 1 < gap->ga_len; i += 2)
+    {
+	p = ((char_u **)gap->ga_data)[i + 1];
+	if (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)
+	{
+	    /* Second part matches at start of following compound word, now
+	     * check if first part matches at end of previous word. */
+	    p = ((char_u **)gap->ga_data)[i];
+	    len = (int)STRLEN(p);
+	    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)
+		return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+/*
  * Return TRUE if "flags" is a valid sequence of compound flags and "word"
  * does not have too many syllables.
  */
@@ -1773,6 +1820,98 @@
 }
 
 /*
+ * Return TRUE when the sequence of flags in "compflags" plus "flag" can
+ * possibly form a valid compounded word.  This also checks the COMPOUNDRULE
+ * lines if they don't contain wildcards.
+ */
+    static int
+can_be_compound(sp, slang, compflags, flag)
+    trystate_T	*sp;
+    slang_T	*slang;
+    char_u	*compflags;
+    int		flag;
+{
+    /* If the flag doesn't appear in sl_compstartflags or sl_compallflags
+     * then it can't possibly compound. */
+    if (!byte_in_str(sp->ts_complen == sp->ts_compsplit
+		? slang->sl_compstartflags : slang->sl_compallflags, flag))
+	return FALSE;
+
+    /* If there are no wildcards, we can check if the flags collected so far
+     * possibly can form a match with COMPOUNDRULE patterns.  This only
+     * makes sense when we have two or more words. */
+    if (slang->sl_comprules != NULL && sp->ts_complen > sp->ts_compsplit)
+    {
+	int v;
+
+	compflags[sp->ts_complen] = flag;
+	compflags[sp->ts_complen + 1] = NUL;
+	v = match_compoundrule(slang, compflags + sp->ts_compsplit);
+	compflags[sp->ts_complen] = NUL;
+	return v;
+    }
+
+    return TRUE;
+}
+
+
+/*
+ * Return TRUE if the compound flags in compflags[] match the start of any
+ * compound rule.  This is used to stop trying a compound if the flags
+ * collected so far can't possibly match any compound rule.
+ * Caller must check that slang->sl_comprules is not NULL.
+ */
+    static int
+match_compoundrule(slang, compflags)
+    slang_T	*slang;
+    char_u	*compflags;
+{
+    char_u	*p;
+    int		i;
+    int		c;
+
+    /* loop over all the COMPOUNDRULE entries */
+    for (p = slang->sl_comprules; *p != NUL; ++p)
+    {
+	/* loop over the flags in the compound word we have made, match
+	 * them against the current rule entry */
+	for (i = 0; ; ++i)
+	{
+	    c = compflags[i];
+	    if (c == NUL)
+		/* found a rule that matches for the flags we have so far */
+		return TRUE;
+	    if (*p == '/' || *p == NUL)
+		break;  /* end of rule, it's too short */
+	    if (*p == '[')
+	    {
+		int match = FALSE;
+
+		/* compare against all the flags in [] */
+		++p;
+		while (*p != ']' && *p != NUL)
+		    if (*p++ == c)
+			match = TRUE;
+		if (!match)
+		    break;  /* none matches */
+	    }
+	    else if (*p != c)
+		break;  /* flag of word doesn't match flag in pattern */
+	    ++p;
+	}
+
+	/* Skip to the next "/", where the next pattern starts. */
+	p = vim_strchr(p, '/');
+	if (p == NULL)
+	    break;
+    }
+
+    /* Checked all the rules and none of them match the flags, so there
+     * can't possibly be a compound starting with these flags. */
+    return FALSE;
+}
+
+/*
  * Return non-zero if the prefix indicated by "arridx" matches with the prefix
  * ID in "flags" for the word "word".
  * The WF_RAREPFX flag is included in the return value for a rare prefix.
@@ -2237,7 +2376,7 @@
 
 	    /* If we are back at the starting line and there is no match then
 	     * give up. */
-	    if (lnum == wp->w_cursor.lnum && !found_one)
+	    if (lnum == wp->w_cursor.lnum && (!found_one || wrapped))
 		break;
 
 	    /* Skip the characters at the start of the next line that were
@@ -2513,9 +2652,11 @@
     lp->sl_midword = NULL;
 
     vim_free(lp->sl_compprog);
+    vim_free(lp->sl_comprules);
     vim_free(lp->sl_compstartflags);
     vim_free(lp->sl_compallflags);
     lp->sl_compprog = NULL;
+    lp->sl_comprules = NULL;
     lp->sl_compstartflags = NULL;
     lp->sl_compallflags = NULL;
 
@@ -3460,6 +3601,7 @@
     char_u	*pp;
     char_u	*cp;
     char_u	*ap;
+    char_u	*crp;
     int		cnt;
     garray_T	*gap;
 
@@ -3545,6 +3687,12 @@
     slang->sl_compallflags = ap;
     *ap = NUL;
 
+    /* And a list of all patterns in their original form, for checking whether
+     * compounding may work in match_compoundrule().  This is freed when we
+     * encounter a wildcard, the check doesn't work then. */
+    crp = alloc(todo + 1);
+    slang->sl_comprules = crp;
+
     pp = pat;
     *pp++ = '^';
     *pp++ = '\\';
@@ -3587,6 +3735,20 @@
 		    atstart = 0;
 	    }
 	}
+
+	/* Copy flag to "sl_comprules", unless we run into a wildcard. */
+	if (crp != NULL)
+	{
+	    if (c == '+' || c == '*')
+	    {
+		vim_free(slang->sl_comprules);
+		slang->sl_comprules = NULL;
+		crp = NULL;
+	    }
+	    else
+		*crp++ = c;
+	}
+
 	if (c == '/')	    /* slash separates two items */
 	{
 	    *pp++ = '\\';
@@ -3611,6 +3773,9 @@
     *pp++ = '$';
     *pp = NUL;
 
+    if (crp != NULL)
+	*crp = NUL;
+
     slang->sl_compprog = vim_regcomp(pat, RE_MAGIC + RE_STRING + RE_STRICT);
     vim_free(pat);
     if (slang->sl_compprog == NULL)
@@ -4791,13 +4956,16 @@
  * Structure that is used to store the items in the word tree.  This avoids
  * the need to keep track of each allocated thing, everything is freed all at
  * once after ":mkspell" is done.
+ * Note: "sb_next" must be just before "sb_data" to make sure the alignment of
+ * "sb_data" is correct for systems where pointers must be aligned on
+ * pointer-size boundaries and sizeof(pointer) > sizeof(int) (e.g., Sparc).
  */
 #define  SBLOCKSIZE 16000	/* size of sb_data */
 typedef struct sblock_S sblock_T;
 struct sblock_S
 {
-    sblock_T	*sb_next;	/* next block in list */
     int		sb_used;	/* nr of bytes already in use */
+    sblock_T	*sb_next;	/* next block in list */
     char_u	sb_data[1];	/* data, actually longer */
 };
 
@@ -4915,6 +5083,7 @@
 } spellinfo_T;
 
 static afffile_T *spell_read_aff __ARGS((spellinfo_T *spin, char_u *fname));
+static int is_aff_rule __ARGS((char_u **items, int itemcnt, char *rulename, int	 mincount));
 static void aff_process_flags __ARGS((afffile_T *affile, affentry_T *entry));
 static int spell_info_item __ARGS((char_u *s));
 static unsigned affitem2flag __ARGS((int flagtype, char_u *item, char_u	*fname, int lnum));
@@ -4950,7 +5119,7 @@
 static void put_sugtime __ARGS((spellinfo_T *spin, FILE *fd));
 static int write_vim_spell __ARGS((spellinfo_T *spin, char_u *fname));
 static void clear_node __ARGS((wordnode_T *node));
-static int put_node __ARGS((FILE *fd, wordnode_T *node, int index, int regionmask, int prefixtree));
+static int put_node __ARGS((FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree));
 static void spell_make_sugfile __ARGS((spellinfo_T *spin, char_u *wfname));
 static int sug_filltree __ARGS((spellinfo_T *spin, slang_T *slang));
 static int sug_maketable __ARGS((spellinfo_T *spin));
@@ -5223,8 +5392,7 @@
 	/* Handle non-empty lines. */
 	if (itemcnt > 0)
 	{
-	    if (STRCMP(items[0], "SET") == 0 && itemcnt == 2
-						       && aff->af_enc == NULL)
+	    if (is_aff_rule(items, itemcnt, "SET", 2) && aff->af_enc == NULL)
 	    {
 #ifdef FEAT_MBYTE
 		/* Setup for conversion from "ENC" to 'encoding'. */
@@ -5239,7 +5407,7 @@
 		    smsg((char_u *)_("Conversion in %s not supported"), fname);
 #endif
 	    }
-	    else if (STRCMP(items[0], "FLAG") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "FLAG", 2)
 					      && aff->af_flagtype == AFT_CHAR)
 	    {
 		if (STRCMP(items[1], "long") == 0)
@@ -5284,69 +5452,71 @@
 			spin->si_info = p;
 		    }
 	    }
-	    else if (STRCMP(items[0], "MIDWORD") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "MIDWORD", 2)
 							   && midword == NULL)
 	    {
 		midword = getroom_save(spin, items[1]);
 	    }
-	    else if (STRCMP(items[0], "TRY") == 0 && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "TRY", 2))
 	    {
 		/* ignored, we look in the tree for what chars may appear */
 	    }
 	    /* TODO: remove "RAR" later */
-	    else if ((STRCMP(items[0], "RAR") == 0
-			|| STRCMP(items[0], "RARE") == 0) && itemcnt == 2
-						       && aff->af_rare == 0)
+	    else if ((is_aff_rule(items, itemcnt, "RAR", 2)
+			|| is_aff_rule(items, itemcnt, "RARE", 2))
+							 && aff->af_rare == 0)
 	    {
 		aff->af_rare = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
 	    /* TODO: remove "KEP" later */
-	    else if ((STRCMP(items[0], "KEP") == 0
-		    || STRCMP(items[0], "KEEPCASE") == 0) && itemcnt == 2
+	    else if ((is_aff_rule(items, itemcnt, "KEP", 2)
+			|| is_aff_rule(items, itemcnt, "KEEPCASE", 2))
 						     && aff->af_keepcase == 0)
 	    {
 		aff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "BAD") == 0 && itemcnt == 2
-						       && aff->af_bad == 0)
+	    else if ((is_aff_rule(items, itemcnt, "BAD", 2)
+			|| is_aff_rule(items, itemcnt, "FORBIDDENWORD", 2))
+							  && aff->af_bad == 0)
 	    {
 		aff->af_bad = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "NEEDAFFIX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "NEEDAFFIX", 2)
 						    && aff->af_needaffix == 0)
 	    {
 		aff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "CIRCUMFIX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "CIRCUMFIX", 2)
 						    && aff->af_circumfix == 0)
 	    {
 		aff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "NOSUGGEST") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "NOSUGGEST", 2)
 						    && aff->af_nosuggest == 0)
 	    {
 		aff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "NEEDCOMPOUND") == 0 && itemcnt == 2
+	    else if ((is_aff_rule(items, itemcnt, "NEEDCOMPOUND", 2)
+			|| is_aff_rule(items, itemcnt, "ONLYINCOMPOUND", 2))
 						     && aff->af_needcomp == 0)
 	    {
 		aff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDROOT") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDROOT", 2)
 						     && aff->af_comproot == 0)
 	    {
 		aff->af_comproot = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDFORBIDFLAG") == 0
-				   && itemcnt == 2 && aff->af_compforbid == 0)
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFORBIDFLAG", 2)
+						   && aff->af_compforbid == 0)
 	    {
 		aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
@@ -5354,8 +5524,8 @@
 		    smsg((char_u *)_("Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d"),
 			    fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDPERMITFLAG") == 0
-				   && itemcnt == 2 && aff->af_comppermit == 0)
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDPERMITFLAG", 2)
+						   && aff->af_comppermit == 0)
 	    {
 		aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
@@ -5363,7 +5533,7 @@
 		    smsg((char_u *)_("Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d"),
 			    fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDFLAG") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFLAG", 2)
 							 && compflags == NULL)
 	    {
 		/* Turn flag "c" into COMPOUNDRULE compatible string "c+",
@@ -5376,7 +5546,15 @@
 		    compflags = p;
 		}
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDRULE") == 0 && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULES", 2))
+	    {
+		/* We don't use the count, but do check that it's a number and
+		 * not COMPOUNDRULE mistyped. */
+		if (atoi((char *)items[1]) == 0)
+		    smsg((char_u *)_("Wrong COMPOUNDRULES value in %s line %d: %s"),
+						       fname, lnum, items[1]);
+	    }
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULE", 2))
 	    {
 		/* Concatenate this string to previously defined ones, using a
 		 * slash to separate them. */
@@ -5395,7 +5573,7 @@
 		    compflags = p;
 		}
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDWORDMAX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDWORDMAX", 2)
 							      && compmax == 0)
 	    {
 		compmax = atoi((char *)items[1]);
@@ -5403,7 +5581,7 @@
 		    smsg((char_u *)_("Wrong COMPOUNDWORDMAX value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDMIN") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDMIN", 2)
 							   && compminlen == 0)
 	    {
 		compminlen = atoi((char *)items[1]);
@@ -5411,7 +5589,7 @@
 		    smsg((char_u *)_("Wrong COMPOUNDMIN value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDSYLMAX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDSYLMAX", 2)
 							   && compsylmax == 0)
 	    {
 		compsylmax = atoi((char *)items[1]);
@@ -5419,32 +5597,29 @@
 		    smsg((char_u *)_("Wrong COMPOUNDSYLMAX value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDDUP") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDDUP", 1))
 	    {
 		compoptions |= COMP_CHECKDUP;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDREP") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDREP", 1))
 	    {
 		compoptions |= COMP_CHECKREP;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDCASE") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDCASE", 1))
 	    {
 		compoptions |= COMP_CHECKCASE;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDTRIPLE") == 0
-							      && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDTRIPLE", 1))
 	    {
 		compoptions |= COMP_CHECKTRIPLE;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDPATTERN") == 0
-							      && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 2))
 	    {
 		if (atoi((char *)items[1]) == 0)
 		    smsg((char_u *)_("Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDPATTERN") == 0
-							      && itemcnt == 3)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 3))
 	    {
 		garray_T    *gap = &spin->si_comppat;
 		int	    i;
@@ -5463,24 +5638,24 @@
 					       = getroom_save(spin, items[2]);
 		}
 	    }
-	    else if (STRCMP(items[0], "SYLLABLE") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "SYLLABLE", 2)
 							  && syllable == NULL)
 	    {
 		syllable = getroom_save(spin, items[1]);
 	    }
-	    else if (STRCMP(items[0], "NOBREAK") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "NOBREAK", 1))
 	    {
 		spin->si_nobreak = TRUE;
 	    }
-	    else if (STRCMP(items[0], "NOSPLITSUGS") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "NOSPLITSUGS", 1))
 	    {
 		spin->si_nosplitsugs = TRUE;
 	    }
-	    else if (STRCMP(items[0], "NOSUGFILE") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "NOSUGFILE", 1))
 	    {
 		spin->si_nosugfile = TRUE;
 	    }
-	    else if (STRCMP(items[0], "PFXPOSTPONE") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "PFXPOSTPONE", 1))
 	    {
 		aff->af_pfxpostpone = TRUE;
 	    }
@@ -5771,24 +5946,20 @@
 		    }
 		}
 	    }
-	    else if (STRCMP(items[0], "FOL") == 0 && itemcnt == 2
-							       && fol == NULL)
+	    else if (is_aff_rule(items, itemcnt, "FOL", 2) && fol == NULL)
 	    {
 		fol = vim_strsave(items[1]);
 	    }
-	    else if (STRCMP(items[0], "LOW") == 0 && itemcnt == 2
-							       && low == NULL)
+	    else if (is_aff_rule(items, itemcnt, "LOW", 2) && low == NULL)
 	    {
 		low = vim_strsave(items[1]);
 	    }
-	    else if (STRCMP(items[0], "UPP") == 0 && itemcnt == 2
-							       && upp == NULL)
+	    else if (is_aff_rule(items, itemcnt, "UPP", 2) && upp == NULL)
 	    {
 		upp = vim_strsave(items[1]);
 	    }
-	    else if ((STRCMP(items[0], "REP") == 0
-			|| STRCMP(items[0], "REPSAL") == 0)
-		    && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "REP", 2)
+		     || is_aff_rule(items, itemcnt, "REPSAL", 2))
 	    {
 		/* Ignore REP/REPSAL count */;
 		if (!isdigit(*items[1]))
@@ -5819,7 +5990,7 @@
 					 : &spin->si_rep, items[1], items[2]);
 		}
 	    }
-	    else if (STRCMP(items[0], "MAP") == 0 && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "MAP", 2))
 	    {
 		/* MAP item or count */
 		if (!found_map)
@@ -5856,9 +6027,8 @@
 		    ga_append(&spin->si_map, '/');
 		}
 	    }
-	    /* Accept "SAL from to" and "SAL from to # comment". */
-	    else if (STRCMP(items[0], "SAL") == 0
-		    && (itemcnt == 3 || (itemcnt > 3 && items[3][0] == '#')))
+	    /* Accept "SAL from to" and "SAL from to  #comment". */
+	    else if (is_aff_rule(items, itemcnt, "SAL", 3))
 	    {
 		if (do_sal)
 		{
@@ -5877,12 +6047,12 @@
 								: items[2]);
 		}
 	    }
-	    else if (STRCMP(items[0], "SOFOFROM") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "SOFOFROM", 2)
 							  && sofofrom == NULL)
 	    {
 		sofofrom = getroom_save(spin, items[1]);
 	    }
-	    else if (STRCMP(items[0], "SOFOTO") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "SOFOTO", 2)
 							    && sofoto == NULL)
 	    {
 		sofoto = getroom_save(spin, items[1]);
@@ -5980,7 +6150,7 @@
 	else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)
 	    MSG(_("Too many compound flags"));
 	else
-	    MSG(_("Too many posponed prefixes and/or compound flags"));
+	    MSG(_("Too many postponed prefixes and/or compound flags"));
     }
 
     if (syllable != NULL)
@@ -6017,6 +6187,22 @@
 }
 
 /*
+ * Return TRUE when items[0] equals "rulename", there are "mincount" items or
+ * a comment is following after item "mincount".
+ */
+    static int
+is_aff_rule(items, itemcnt, rulename, mincount)
+    char_u	**items;
+    int		itemcnt;
+    char	*rulename;
+    int		mincount;
+{
+    return (STRCMP(items[0], rulename) == 0
+	    && (itemcnt == mincount
+		|| (itemcnt > mincount && items[mincount][0] == '#')));
+}
+
+/*
  * For affix "entry" move COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG from
  * ae_flags to ae_comppermit and ae_compforbid.
  */
@@ -7866,7 +8052,7 @@
     /* time_t can be up to 8 bytes in size, more than long_u, thus we
      * can't use put_bytes() here. */
     for (i = 7; i >= 0; --i)
-	if (i + 1 > sizeof(time_t))
+	if (i + 1 > (int)sizeof(time_t))
 	    /* ">>" doesn't work well when shifting more bits than avail */
 	    putc(0, fd);
 	else
@@ -7926,6 +8112,8 @@
     char_u	*p;
     int		rr;
     int		retval = OK;
+    size_t	fwv = 1;  /* collect return value of fwrite() to avoid
+			     warnings from picky compiler */
 
     fd = mch_fopen((char *)fname, "w");
     if (fd == NULL)
@@ -7936,11 +8124,11 @@
 
     /* <HEADER>: <fileID> <versionnr> */
 							    /* <fileID> */
-    if (fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd) != 1)
-    {
-	EMSG(_(e_write));
-	retval = FAIL;
-    }
+    fwv &= fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd);
+    if (fwv != (size_t)1)
+	/* Catch first write error, don't try writing more. */
+	goto theend;
+
     putc(VIMSPELLVERSION, fd);				    /* <versionnr> */
 
     /*
@@ -7955,7 +8143,7 @@
 
 	i = (int)STRLEN(spin->si_info);
 	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
-	fwrite(spin->si_info, (size_t)i, (size_t)1, fd); /* <infotext> */
+	fwv &= fwrite(spin->si_info, (size_t)i, (size_t)1, fd); /* <infotext> */
     }
 
     /* SN_REGION: <regionname> ...
@@ -7966,7 +8154,7 @@
 	putc(SNF_REQUIRED, fd);				/* <sectionflags> */
 	l = spin->si_region_count * 2;
 	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
-	fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);
+	fwv &= fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);
 							/* <regionname> ... */
 	regionmask = (1 << spin->si_region_count) - 1;
     }
@@ -8016,7 +8204,7 @@
 	}
 
 	put_bytes(fd, (long_u)l, 2);			/* <folcharslen> */
-	fwrite(folchars, (size_t)l, (size_t)1, fd);	/* <folchars> */
+	fwv &= fwrite(folchars, (size_t)l, (size_t)1, fd); /* <folchars> */
     }
 
     /* SN_MIDWORD: <midword> */
@@ -8027,7 +8215,8 @@
 
 	i = (int)STRLEN(spin->si_midword);
 	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
-	fwrite(spin->si_midword, (size_t)i, (size_t)1, fd); /* <midword> */
+	fwv &= fwrite(spin->si_midword, (size_t)i, (size_t)1, fd);
+							/* <midword> */
     }
 
     /* SN_PREFCOND: <prefcondcnt> <prefcond> ... */
@@ -8113,7 +8302,8 @@
 		p = rr == 1 ? ftp->ft_from : ftp->ft_to;
 		l = (int)STRLEN(p);
 		putc(l, fd);
-		fwrite(p, l, (size_t)1, fd);
+		if (l > 0)
+		    fwv &= fwrite(p, l, (size_t)1, fd);
 	    }
 	}
 
@@ -8131,11 +8321,11 @@
 							/* <sectionlen> */
 
 	put_bytes(fd, (long_u)l, 2);			/* <sofofromlen> */
-	fwrite(spin->si_sofofr, l, (size_t)1, fd);	/* <sofofrom> */
+	fwv &= fwrite(spin->si_sofofr, l, (size_t)1, fd); /* <sofofrom> */
 
 	l = (int)STRLEN(spin->si_sofoto);
 	put_bytes(fd, (long_u)l, 2);			/* <sofotolen> */
-	fwrite(spin->si_sofoto, l, (size_t)1, fd);	/* <sofoto> */
+	fwv &= fwrite(spin->si_sofoto, l, (size_t)1, fd); /* <sofoto> */
     }
 
     /* SN_WORDS: <word> ...
@@ -8160,7 +8350,7 @@
 		    l = (int)STRLEN(hi->hi_key) + 1;
 		    len += l;
 		    if (round == 2)			/* <word> */
-			fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);
+			fwv &= fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);
 		    --todo;
 		}
 	    if (round == 1)
@@ -8176,7 +8366,7 @@
 	putc(0, fd);					/* <sectionflags> */
 	l = spin->si_map.ga_len;
 	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
-	fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);
+	fwv &= fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);
 							/* <mapstr> */
     }
 
@@ -8232,10 +8422,11 @@
 	{
 	    p = ((char_u **)(spin->si_comppat.ga_data))[i];
 	    putc((int)STRLEN(p), fd);			/* <comppatlen> */
-	    fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);/* <comppattext> */
+	    fwv &= fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);
+							/* <comppattext> */
 	}
 							/* <compflags> */
-	fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),
+	fwv &= fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),
 							       (size_t)1, fd);
     }
 
@@ -8259,7 +8450,8 @@
 
 	l = (int)STRLEN(spin->si_syllable);
 	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
-	fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd); /* <syllable> */
+	fwv &= fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd);
+							/* <syllable> */
     }
 
     /* end of <SECTIONS> */
@@ -8295,13 +8487,18 @@
 	(void)put_node(fd, tree, 0, regionmask, round == 3);
     }
 
-    /* Write another byte to check for errors. */
+    /* Write another byte to check for errors (file system full). */
     if (putc(0, fd) == EOF)
 	retval = FAIL;
-
+theend:
     if (fclose(fd) == EOF)
 	retval = FAIL;
 
+    if (fwv != (size_t)1)
+	retval = FAIL;
+    if (retval == FAIL)
+	EMSG(_(e_write));
+
     return retval;
 }
 
@@ -9890,6 +10087,7 @@
     char_u	*p;
     int		len;
     int		totlen;
+    size_t	x = 1;  /* collect return value of fwrite() */
 
     if (fd != NULL)
 	put_bytes(fd, (long_u)gap->ga_len, 2);	    /* <prefcondcnt> */
@@ -9906,7 +10104,7 @@
 	    if (fd != NULL)
 	    {
 		fputc(len, fd);
-		fwrite(p, (size_t)len, (size_t)1, fd);
+		x &= fwrite(p, (size_t)len, (size_t)1, fd);
 	    }
 	    totlen += len;
 	}
@@ -10343,10 +10541,9 @@
 /*
  * ":spellrepall"
  */
-/*ARGSUSED*/
     void
 ex_spellrepall(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     pos_T	pos = curwin->w_cursor;
     char_u	*frompat;
@@ -11480,15 +11677,24 @@
 		    vim_strncpy(preword + sp->ts_prewordlen,
 			    tword + sp->ts_splitoff,
 			    sp->ts_twordlen - sp->ts_splitoff);
-		    p = preword;
-		    while (*skiptowhite(p) != NUL)
-			p = skipwhite(skiptowhite(p));
-		    if (fword_ends && !can_compound(slang, p,
-						compflags + sp->ts_compsplit))
-			/* Compound is not allowed.  But it may still be
-			 * possible if we add another (short) word. */
+
+		    /* Verify CHECKCOMPOUNDPATTERN  rules. */
+		    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,
+							  &slang->sl_comppat))
 			compound_ok = FALSE;
 
+		    if (compound_ok)
+		    {
+			p = preword;
+			while (*skiptowhite(p) != NUL)
+			    p = skipwhite(skiptowhite(p));
+			if (fword_ends && !can_compound(slang, p,
+						compflags + sp->ts_compsplit))
+			    /* Compound is not allowed.  But it may still be
+			     * possible if we add another (short) word. */
+			    compound_ok = FALSE;
+		    }
+
 		    /* Get pointer to last char of previous word. */
 		    p = preword + sp->ts_prewordlen;
 		    mb_ptr_back(preword, p);
@@ -11685,10 +11891,9 @@
 			&& (slang->sl_compsylmax < MAXWLEN
 			    || sp->ts_complen + 1 - sp->ts_compsplit
 							  < slang->sl_compmax)
-			&& (byte_in_str(sp->ts_complen == sp->ts_compsplit
-					    ? slang->sl_compstartflags
-					    : slang->sl_compallflags,
-						    ((unsigned)flags >> 24))))
+			&& (can_be_compound(sp, slang,
+					 compflags, ((unsigned)flags >> 24))))
+
 		{
 		    try_compound = TRUE;
 		    compflags[sp->ts_complen] = ((unsigned)flags >> 24);
@@ -14808,7 +15013,7 @@
 
 	case 0:
 	    /*
-	     * Lenghts are equal, thus changes must result in same length: An
+	     * Lengths are equal, thus changes must result in same length: An
 	     * insert is only possible in combination with a delete.
 	     * 1: check if for identical strings
 	     */
@@ -15398,10 +15603,9 @@
 /*
  * ":spellinfo"
  */
-/*ARGSUSED*/
     void
 ex_spellinfo(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     int		lpi;
     langp_T	*lp;
@@ -15945,11 +16149,9 @@
  * Returns the number of matches.  The matches are in "matchp[]", array of
  * allocated strings.
  */
-/*ARGSUSED*/
     int
-expand_spelling(lnum, col, pat, matchp)
-    linenr_T	lnum;
-    int		col;
+expand_spelling(lnum, pat, matchp)
+    linenr_T	lnum UNUSED;
     char_u	*pat;
     char_u	***matchp;
 {
diff -Naur vim72.orig/src/structs.h vim72/src/structs.h
--- vim72.orig/src/structs.h	2008-07-30 13:02:50.000000000 -0700
+++ vim72/src/structs.h	2009-06-05 14:24:58.000000000 -0700
@@ -16,7 +16,7 @@
  */
 #if defined(SASC) && SASC < 658
 typedef long		linenr_T;
-typedef unsigned	colnr_T;
+typedef int		colnr_T;
 typedef unsigned short	short_u;
 #endif
 
@@ -33,9 +33,9 @@
 } pos_T;
 
 #ifdef FEAT_VIRTUALEDIT
-# define INIT_POS_T {0, 0, 0}
+# define INIT_POS_T(l, c, ca) {l, c, ca}
 #else
-# define INIT_POS_T {0, 0}
+# define INIT_POS_T(l, c, ca) {l, c}
 #endif
 
 /*
@@ -459,7 +459,7 @@
 typedef struct
 {
     int		hide;			/* TRUE when ":hide" was used */
-# ifdef FEAT_BROWSE
+# ifdef FEAT_BROWSE_CMD
     int		browse;			/* TRUE to invoke file dialog */
 # endif
 # ifdef FEAT_WINDOWS
@@ -1166,7 +1166,8 @@
     char_u	*b_fname;	/* current file name */
 
 #ifdef UNIX
-    int		b_dev;		/* device number (-1 if not set) */
+    int		b_dev_valid;	/* TRUE when b_dev has a valid number */
+    dev_t	b_dev;		/* device number */
     ino_t	b_ino;		/* inode number */
 #endif
 #ifdef FEAT_CW_EDITOR
@@ -1784,10 +1785,15 @@
 #endif
 
     /*
-     * The next three specify the offsets for displaying the buffer:
+     * "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for
+     * displaying the buffer.
      */
     linenr_T	w_topline;	    /* buffer line number of the line at the
 				       top of the window */
+#ifdef FEAT_AUTOCMD
+    char	w_topline_was_set;  /* flag set to TRUE when topline is set,
+				       e.g. by winrestview() */
+#endif
 #ifdef FEAT_DIFF
     int		w_topfill;	    /* number of filler lines above w_topline */
     int		w_old_topfill;	    /* w_topfill at last redraw */
diff -Naur vim72.orig/src/syntax.c vim72/src/syntax.c
--- vim72.orig/src/syntax.c	2008-08-08 14:47:48.000000000 -0700
+++ vim72/src/syntax.c	2009-06-05 14:25:15.000000000 -0700
@@ -3224,11 +3224,10 @@
 /*
  * Handle ":syntax case" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_case(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*next;
@@ -3249,11 +3248,10 @@
 /*
  * Handle ":syntax spell" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_spell(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*next;
@@ -3517,11 +3515,10 @@
 /*
  * Handle ":syntax on" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_on(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     syn_cmd_onoff(eap, "syntax");
 }
@@ -3529,11 +3526,10 @@
 /*
  * Handle ":syntax enable" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_enable(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     set_internal_string_var((char_u *)"syntax_cmd", (char_u *)"enable");
     syn_cmd_onoff(eap, "syntax");
@@ -3543,11 +3539,10 @@
 /*
  * Handle ":syntax reset" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_reset(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     eap->nextcmd = check_nextcmd(eap->arg);
     if (!eap->skip)
@@ -3561,11 +3556,10 @@
 /*
  * Handle ":syntax manual" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_manual(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     syn_cmd_onoff(eap, "manual");
 }
@@ -3573,11 +3567,10 @@
 /*
  * Handle ":syntax off" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_off(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     syn_cmd_onoff(eap, "nosyntax");
 }
@@ -4461,11 +4454,10 @@
 /*
  * Handle ":syntax include [@{group-name}] filename" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_include(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     int		sgl_id = 1;
@@ -4532,11 +4524,10 @@
 /*
  * Handle ":syntax keyword {group-name} [{option}] keyword .." command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_keyword(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*group_name_end;
@@ -5275,11 +5266,10 @@
  * Handle ":syntax cluster {cluster-name} [contains={groupname},..]
  *		[add={groupname},..] [remove={groupname},..]".
  */
-/* ARGSUSED */
     static void
 syn_cmd_cluster(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*group_name_end;
@@ -5464,11 +5454,10 @@
 /*
  * Handle ":syntax sync .." command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_sync(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg_start = eap->arg;
     char_u	*arg_end;
@@ -6099,10 +6088,9 @@
  * Function given to ExpandGeneric() to obtain the list syntax names for
  * expansion.
  */
-/*ARGSUSED*/
     char_u *
 get_syntax_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (expand_what == EXP_SUBCMD)
@@ -7744,14 +7732,13 @@
 /*
  * Get the font or fontset for one highlight group.
  */
-/*ARGSUSED*/
     static void
 hl_do_font(idx, arg, do_normal, do_menu, do_tooltip)
     int		idx;
     char_u	*arg;
-    int		do_normal;	/* set normal font */
-    int		do_menu;	/* set menu font */
-    int		do_tooltip;	/* set tooltip font */
+    int		do_normal;		/* set normal font */
+    int		do_menu UNUSED;		/* set menu font */
+    int		do_tooltip UNUSED;	/* set tooltip font */
 {
 # ifdef FEAT_XFONTSET
     /* If 'guifontset' is not empty, first try using the name as a
@@ -9150,10 +9137,9 @@
  * Function given to ExpandGeneric() to obtain the list of group names.
  * Also used for synIDattr() function.
  */
-/*ARGSUSED*/
     char_u *
 get_highlight_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
 #ifdef FEAT_CMDL_COMPL
diff -Naur vim72.orig/src/tag.c vim72/src/tag.c
--- vim72.orig/src/tag.c	2008-07-16 14:31:30.000000000 -0700
+++ vim72/src/tag.c	2009-06-05 14:25:15.000000000 -0700
@@ -100,7 +100,7 @@
  * Tag for preview window is remembered separately, to avoid messing up the
  * normal tagstack.
  */
-static taggy_T ptag_entry = {NULL};
+static taggy_T ptag_entry = {NULL, {INIT_POS_T(0, 0, 0), 0}, 0, 0};
 #endif
 
 /*
@@ -515,7 +515,7 @@
 	     * If a count is supplied to the ":tag <name>" command, then
 	     * jump to count'th matching tag.
 	     */
-	    if (type == DT_TAG && count > 0)
+	    if (type == DT_TAG && *tag != NUL && count > 0)
 		cur_match = count - 1;
 
 	    if (type == DT_SELECT || type == DT_JUMP
@@ -618,7 +618,7 @@
 		taglen_advance(taglen);
 		MSG_PUTS_ATTR(_("file\n"), hl_attr(HLF_T));
 
-		for (i = 0; i < num_matches; ++i)
+		for (i = 0; i < num_matches && !got_int; ++i)
 		{
 		    parse_match(matches[i], &tagp);
 		    if (!new_tag && (
@@ -655,6 +655,8 @@
 		    }
 		    if (msg_col > 0)
 			msg_putchar('\n');
+		    if (got_int)
+			break;
 		    msg_advance(15);
 
 		    /* print any extra fields */
@@ -689,6 +691,8 @@
 				if (msg_col + ptr2cells(p) >= Columns)
 				{
 				    msg_putchar('\n');
+				    if (got_int)
+					break;
 				    msg_advance(15);
 				}
 				p = msg_outtrans_one(p, attr);
@@ -704,6 +708,8 @@
 			if (msg_col > 15)
 			{
 			    msg_putchar('\n');
+			    if (got_int)
+				break;
 			    msg_advance(15);
 			}
 		    }
@@ -734,6 +740,8 @@
 		    {
 			if (msg_col + (*p == TAB ? 1 : ptr2cells(p)) > Columns)
 			    msg_putchar('\n');
+			if (got_int)
+			    break;
 			msg_advance(15);
 
 			/* skip backslash used for escaping command char */
@@ -760,12 +768,9 @@
 		    if (msg_col)
 			msg_putchar('\n');
 		    ui_breakcheck();
-		    if (got_int)
-		    {
-			got_int = FALSE;	/* only stop the listing */
-			break;
-		    }
 		}
+		if (got_int)
+		    got_int = FALSE;	/* only stop the listing */
 		ask_for_selection = TRUE;
 	    }
 #if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)
@@ -1100,10 +1105,9 @@
 /*
  * Print the tag stack
  */
-/*ARGSUSED*/
     void
 do_tags(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		i;
     char_u	*name;
@@ -2525,11 +2529,10 @@
  * Callback function for finding all "tags" and "tags-??" files in
  * 'runtimepath' doc directories.
  */
-/*ARGSUSED*/
     static void
 found_tagfile_cb(fname, cookie)
     char_u	*fname;
-    void	*cookie;
+    void	*cookie UNUSED;
 {
     if (ga_grow(&tag_fnames, 1) == OK)
 	((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] =
@@ -2542,6 +2545,15 @@
 {
     ga_clear_strings(&tag_fnames);
     do_tag(NULL, DT_FREE, 0, 0, 0);
+    tag_freematch();
+
+# if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
+    if (ptag_entry.tagname)
+    {
+        vim_free(ptag_entry.tagname);
+        ptag_entry.tagname = NULL;
+    }
+# endif
 }
 #endif
 
@@ -2725,7 +2737,24 @@
 	 */
 	p_7f = vim_strchr(lbuf, 0x7f);
 	if (p_7f == NULL)
+	{
+etag_fail:
+	    if (vim_strchr(lbuf, '\n') == NULL)
+	    {
+		/* Truncated line.  Ignore it. */
+		if (p_verbose >= 5)
+		{
+		    verbose_enter();
+		    MSG(_("Ignoring long line in tags file"));
+		    verbose_leave();
+		}
+		tagp->command = lbuf;
+		tagp->tagname = lbuf;
+		tagp->tagname_end = lbuf;
+		return OK;
+	    }
 	    return FAIL;
+	}
 
 	/* Find ^A.  If not found the line number is after the 0x7f */
 	p = vim_strchr(p_7f, Ctrl_A);
@@ -2735,7 +2764,7 @@
 	    ++p;
 
 	if (!VIM_ISDIGIT(*p))	    /* check for start of line number */
-	    return FAIL;
+	    goto etag_fail;
 	tagp->command = p;
 
 
@@ -2749,7 +2778,7 @@
 	    /* find end of tagname */
 	    for (p = p_7f - 1; !vim_iswordc(*p); --p)
 		if (p == lbuf)
-		    return FAIL;
+		    goto etag_fail;
 	    tagp->tagname_end = p + 1;
 	    while (p >= lbuf && vim_iswordc(*p))
 		--p;
@@ -3762,7 +3791,7 @@
 		--end;
 	}
 	len = (int)(end - start);
-	if (len > sizeof(buf) - 1)
+	if (len > (int)sizeof(buf) - 1)
 	    len = sizeof(buf) - 1;
 	vim_strncpy(buf, start, len);
     }
diff -Naur vim72.orig/src/term.c vim72/src/term.c
--- vim72.orig/src/term.c	2008-07-27 04:48:06.000000000 -0700
+++ vim72/src/term.c	2009-06-05 14:25:15.000000000 -0700
@@ -2906,7 +2906,7 @@
     int	    i;
     int	    shift;
 
-    for (i = 1; i <= sizeof(long_u); i++)
+    for (i = 1; i <= (int)sizeof(long_u); i++)
     {
 	shift = 8 * (sizeof(long_u) - i);
 	dst[i - 1] = (char_u) ((val >> shift) & 0xff);
@@ -2937,7 +2937,7 @@
     len = get_bytes_from_buf(buf, bytes, (int)sizeof(long_u));
     if (len != -1)
     {
-	for (i = 0; i < sizeof(long_u); i++)
+	for (i = 0; i < (int)sizeof(long_u); i++)
 	{
 	    shift = 8 * (sizeof(long_u) - 1 - i);
 	    *val += (long_u)bytes[i] << shift;
@@ -4920,7 +4920,15 @@
 	key_name[0] = KEY2TERMCAP0(key);
 	key_name[1] = KEY2TERMCAP1(key);
 	if (key_name[0] == KS_KEY)
-	    string[new_slen++] = key_name[1];	/* from ":set <M-b>=xx" */
+	{
+	    /* from ":set <M-b>=xx" */
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+		new_slen += (*mb_char2bytes)(key_name[1], string + new_slen);
+	    else
+#endif
+		string[new_slen++] = key_name[1];
+	}
 	else
 	{
 	    string[new_slen++] = K_SPECIAL;
diff -Naur vim72.orig/src/testdir/Makefile vim72/src/testdir/Makefile
--- vim72.orig/src/testdir/Makefile	2008-06-19 13:29:46.000000000 -0700
+++ vim72/src/testdir/Makefile	2009-06-05 14:22:57.000000000 -0700
@@ -20,21 +20,23 @@
 		test48.out test49.out test51.out test52.out test53.out \
 		test54.out test55.out test56.out test57.out test58.out \
 		test59.out test60.out test61.out test62.out test63.out \
-		test64.out test65.out
+		test64.out test65.out test66.out
 
 SCRIPTS_GUI = test16.out
 
 .SUFFIXES: .in .out
 
-nongui:	nolog $(SCRIPTS)
-	@echo
-	@cat test.log
-	@echo ALL DONE
+nongui:	nolog $(SCRIPTS) report
+
+gui:	nolog $(SCRIPTS) $(SCRIPTS_GUI) report
 
-gui:	nolog $(SCRIPTS) $(SCRIPTS_GUI)
+report:
 	@echo
-	@cat test.log
-	@echo ALL DONE
+	@echo 'Test results:'
+	@/bin/sh -c "if test -f test.log; \
+		then cat test.log; echo TEST FAILURE; exit 1; \
+		else echo ALL DONE; \
+		fi"
 
 $(SCRIPTS) $(SCRIPTS_GUI): $(VIMPROG)
 
@@ -71,4 +73,4 @@
 test60.out: test60.vim
 
 nolog:
-	-echo Test results: >test.log
+	-rm -f test.log
diff -Naur vim72.orig/src/testdir/Make_ming.mak vim72/src/testdir/Make_ming.mak
--- vim72.orig/src/testdir/Make_ming.mak	1969-12-31 16:00:00.000000000 -0800
+++ vim72/src/testdir/Make_ming.mak	2009-06-05 14:15:34.000000000 -0700
@@ -0,0 +1,91 @@
+# Makefile to run tests for Vim, on Dos-like machines
+# with sh.exe or zsh.exe in the path or not.
+#
+# Author: Bill McCarthy
+#
+# Note that test54 has been removed until it is fixed.
+#
+# Requires a set of Unix tools: echo, diff, etc.
+
+ifneq (sh.exe, $(SHELL))
+DEL = rm -f
+MV = mv
+CP = cp
+DIRSLASH = /
+else
+DEL = del
+MV = rename
+CP = copy
+DIRSLASH = \\
+endif
+
+VIMPROG = ..$(DIRSLASH)vim
+
+# Omitted:
+# test2		"\\tmp" doesn't work.
+# test10	'errorformat' is different
+# test12	can't unlink a swap file
+# test25	uses symbolic link
+# test27	can't edit file with "*" in file name
+# test31	16 bit version runs out of memory...
+
+SCRIPTS16 =	test1.out test19.out test20.out test22.out \
+		test23.out test24.out test28.out test29.out \
+		test35.out test36.out test43.out \
+		test44.out test45.out test46.out test47.out \
+		test48.out test51.out test53.out            \
+		test55.out test56.out test57.out test58.out test59.out \
+		test60.out test61.out test62.out test63.out test64.out
+
+# Had to remove test54 which doesn't work yet.
+#		                                 test54.out
+
+SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
+		test8.out test9.out test11.out test13.out test14.out \
+		test15.out test17.out test18.out test21.out test26.out \
+		test30.out test31.out test32.out test33.out test34.out \
+		test37.out test38.out test39.out test40.out test41.out \
+		test42.out test52.out test65.out
+
+SCRIPTS32 =	test50.out
+
+SCRIPTS_GUI = test16.out
+
+.SUFFIXES: .in .out
+
+vimall:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS_GUI) $(SCRIPTS32)
+	echo ALL DONE
+
+nongui:	fixff $(SCRIPTS16) $(SCRIPTS)
+	echo ALL DONE
+
+small:
+	echo ALL DONE
+
+gui:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS_GUI)
+	echo ALL DONE
+
+win32:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS32)
+	echo ALL DONE
+
+fixff:
+	-$(VIMPROG) -u dos.vim --noplugin "+argdo set ff=dos|upd" +q *.in *.ok
+
+clean:
+	-$(DEL) *.out
+	-$(DEL) test.ok
+	-$(DEL) small.vim
+	-$(DEL) tiny.vim
+	-$(DEL) mbyte.vim
+	-$(DEL) X*
+	-$(DEL) viminfo
+
+.in.out:
+	$(CP) $*.ok test.ok
+	$(VIMPROG) -u dos.vim -U NONE --noplugin -s dotest.in $*.in
+	diff test.out $*.ok
+	-$(DEL) $*.out
+	$(MV) test.out $*.out
+	-$(DEL) X*
+	-$(DEL) test.ok
+	-$(DEL) viminfo
diff -Naur vim72.orig/src/testdir/test42.ok vim72/src/testdir/test42.ok
--- vim72.orig/src/testdir/test42.ok	2008-02-20 04:27:37.000000000 -0800
+++ vim72/src/testdir/test42.ok	2009-06-05 14:16:16.000000000 -0700
@@ -20,7 +20,7 @@
 ucs-2
 
 
-  fileencoding=ucs-2le
+  fileencoding=utf-16le
   bomb
 ucs-2le
 
diff -Naur vim72.orig/src/testdir/test66.in vim72/src/testdir/test66.in
--- vim72.orig/src/testdir/test66.in	1969-12-31 16:00:00.000000000 -0800
+++ vim72/src/testdir/test66.in	2009-06-05 14:22:57.000000000 -0700
@@ -0,0 +1,25 @@
+
+Test for visual block shift and tab characters.
+
+STARTTEST
+:so small.vim
+/^abcdefgh
+4jI    j<<11|D
+7|a		
+7|a		   
+7|a	       	4k13|4j<
+:$-4,$w! test.out
+:$-4,$s/\s\+//g
+4kI    j<<
+7|a		
+7|a					
+7|a	       		4k13|4j3<
+:$-4,$w >> test.out
+:qa!
+ENDTEST
+
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
diff -Naur vim72.orig/src/testdir/test66.ok vim72/src/testdir/test66.ok
--- vim72.orig/src/testdir/test66.ok	1969-12-31 16:00:00.000000000 -0800
+++ vim72/src/testdir/test66.ok	2009-06-05 14:22:57.000000000 -0700
@@ -0,0 +1,10 @@
+    abcdefghijklmnopqrstuvwxyz
+abcdefghij
+    abc	    defghijklmnopqrstuvwxyz
+    abc	    defghijklmnopqrstuvwxyz
+    abc	    defghijklmnopqrstuvwxyz
+    abcdefghijklmnopqrstuvwxyz
+abcdefghij
+    abc	    defghijklmnopqrstuvwxyz
+    abc		defghijklmnopqrstuvwxyz
+    abc	    defghijklmnopqrstuvwxyz
diff -Naur vim72.orig/src/ui.c vim72/src/ui.c
--- vim72.orig/src/ui.c	2008-07-14 11:14:56.000000000 -0700
+++ vim72/src/ui.c	2009-06-05 14:25:15.000000000 -0700
@@ -320,10 +320,9 @@
  * The gui_set_shellsize() or mch_set_shellsize() function will try to set the
  * new size.  If this is not possible, it will adjust Rows and Columns.
  */
-/*ARGSUSED*/
     void
 ui_set_shellsize(mustset)
-    int		mustset;	/* set by the user */
+    int		mustset UNUSED;	/* set by the user */
 {
 #ifdef FEAT_GUI
     if (gui.in_use)
@@ -1127,10 +1126,9 @@
  * available for pasting.
  * When "both" is TRUE also copy to the '+' register.
  */
-/*ARGSUSED*/
     void
 clip_copy_modeless_selection(both)
-    int		both;
+    int		both UNUSED;
 {
     char_u	*buffer;
     char_u	*bufp;
@@ -1701,10 +1699,9 @@
     return (int)maxlen;
 }
 
-/*ARGSUSED*/
     void
 fill_input_buf(exit_on_error)
-    int	exit_on_error;
+    int	exit_on_error UNUSED;
 {
 #if defined(UNIX) || defined(OS2) || defined(VMS) || defined(MACOS_X_UNIX)
     int		len;
@@ -1820,7 +1817,7 @@
 #ifdef HAVE_DUP
 	    /* Use stderr for stdin, also works for shell commands. */
 	    close(0);
-	    dup(2);
+	    ignored = dup(2);
 #else
 	    read_cmd_fd = 2;	/* read from stderr instead of stdin */
 #endif
@@ -1992,11 +1989,10 @@
 
 static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
 
-/* ARGSUSED */
     static void
 clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,
 			      format)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	success;
     Atom	*sel_atom;
     Atom	*type;
@@ -2020,7 +2016,7 @@
 
     if (value == NULL || *length == 0)
     {
-	clip_free_selection(cbd);	/* ???  [what's the query?] */
+	clip_free_selection(cbd);	/* nothing received, clear register */
 	*(int *)success = FALSE;
 	return;
     }
@@ -2076,7 +2072,7 @@
 	text_prop.value = (unsigned char *)value;
 	text_prop.encoding = *type;
 	text_prop.format = *format;
-	text_prop.nitems = STRLEN(value);
+	text_prop.nitems = len;
 	status = XmbTextPropertyToTextList(X_DISPLAY, &text_prop,
 							 &text_list, &n_text);
 	if (status != Success || n_text < 1)
@@ -2110,6 +2106,8 @@
     int		i;
     int		nbytes = 0;
     char_u	*buffer;
+    time_t	start_time;
+    int		timed_out = FALSE;
 
     for (i =
 #ifdef FEAT_MBYTE
@@ -2129,6 +2127,7 @@
 	    case 3:  type = text_atom;		break;
 	    default: type = XA_STRING;
 	}
+	success = MAYBE;
 	XtGetSelectionValue(myShell, cbd->sel_atom, type,
 	    clip_x11_request_selection_cb, (XtPointer)&success, CurrentTime);
 
@@ -2141,27 +2140,48 @@
 	 * characters, then they will appear before the one that requested the
 	 * paste!  Don't worry, we will catch up with any other events later.
 	 */
-	for (;;)
+	start_time = time(NULL);
+	while (success == MAYBE)
 	{
-	    if (XCheckTypedEvent(dpy, SelectionNotify, &event))
-		break;
-	    if (XCheckTypedEvent(dpy, SelectionRequest, &event))
-		/* We may get a SelectionRequest here and if we don't handle
-		 * it we hang.  KDE klipper does this, for example. */
+	    if (XCheckTypedEvent(dpy, SelectionNotify, &event)
+		    || XCheckTypedEvent(dpy, SelectionRequest, &event)
+		    || XCheckTypedEvent(dpy, PropertyNotify, &event))
+	    {
+		/* This is where clip_x11_request_selection_cb() should be
+		 * called.  It may actually happen a bit later, so we loop
+		 * until "success" changes.
+		 * We may get a SelectionRequest here and if we don't handle
+		 * it we hang.  KDE klipper does this, for example.
+		 * We need to handle a PropertyNotify for large selections. */
 		XtDispatchEvent(&event);
+		continue;
+	    }
+
+	    /* Time out after 2 to 3 seconds to avoid that we hang when the
+	     * other process doesn't respond.  Note that the SelectionNotify
+	     * event may still come later when the selection owner comes back
+	     * to life and the text gets inserted unexpectedly.  Don't know
+	     * why that happens or how to avoid that :-(. */
+	    if (time(NULL) > start_time + 2)
+	    {
+		timed_out = TRUE;
+		break;
+	    }
 
 	    /* Do we need this?  Probably not. */
 	    XSync(dpy, False);
 
-	    /* Bernhard Walle solved a slow paste response in an X terminal by
-	     * adding: usleep(10000); here. */
+	    /* Wait for 1 msec to avoid that we eat up all CPU time. */
+	    ui_delay(1L, TRUE);
 	}
 
-	/* this is where clip_x11_request_selection_cb() is actually called */
-	XtDispatchEvent(&event);
-
-	if (success)
+	if (success == TRUE)
 	    return;
+
+	/* don't do a retry with another type after timing out, otherwise we
+	 * hang for 15 seconds. */
+	if (timed_out)
+	    break;
     }
 
     /* Final fallback position - use the X CUT_BUFFER0 store */
@@ -2178,10 +2198,9 @@
 
 static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
 
-/* ARGSUSED */
     static Boolean
 clip_x11_convert_selection_cb(w, sel_atom, target, type, value, length, format)
-    Widget	w;
+    Widget	w UNUSED;
     Atom	*sel_atom;
     Atom	*target;
     Atom	*type;
@@ -2308,10 +2327,9 @@
 
 static void  clip_x11_lose_ownership_cb __ARGS((Widget, Atom *));
 
-/* ARGSUSED */
     static void
 clip_x11_lose_ownership_cb(w, sel_atom)
-    Widget  w;
+    Widget  w UNUSED;
     Atom    *sel_atom;
 {
     if (*sel_atom == clip_plus.sel_atom)
@@ -2344,10 +2362,9 @@
  * Send the current selection to the clipboard.  Do nothing for X because we
  * will fill in the selection only when requested by another app.
  */
-/*ARGSUSED*/
     void
 clip_x11_set_selection(cbd)
-    VimClipboard *cbd;
+    VimClipboard *cbd UNUSED;
 {
 }
 #endif
@@ -2898,11 +2915,10 @@
  * Find the window at screen position "*rowp" and "*colp".  The positions are
  * updated to become relative to the top-left of the window.
  */
-/*ARGSUSED*/
     win_T *
 mouse_find_win(rowp, colp)
     int		*rowp;
-    int		*colp;
+    int		*colp UNUSED;
 {
     frame_T	*fp;
 
diff -Naur vim72.orig/src/version.c vim72/src/version.c
--- vim72.orig/src/version.c	2008-08-09 07:24:52.000000000 -0700
+++ vim72/src/version.c	2009-06-05 14:26:12.000000000 -0700
@@ -677,9 +677,380 @@
 static int included_patches[] =
 {   /* Add new patch number below this line */
 /**/
+    196,
+/**/
+    195,
+/**/
+    193,
+/**/
+    192,
+/**/
+    190,
+/**/
+    189,
+/**/
+    188,
+/**/
+    187,
+/**/
+    186,
+/**/
+    185,
+/**/
+    184,
+/**/
+    183,
+/**/
+    182,
+/**/
+    181,
+/**/
+    180,
+/**/
+    179,
+/**/
+    178,
+/**/
+    177,
+/**/
+    176,
+/**/
+    175,
+/**/
+    174,
+/**/
+    171,
+/**/
+    170,
+/**/
+    169,
+/**/
+    168,
+/**/
+    167,
+/**/
+    166,
+/**/
+    165,
+/**/
+    164,
+/**/
+    163,
+/**/
+    162,
+/**/
+    161,
+/**/
+    160,
+/**/
+    159,
+/**/
+    158,
+/**/
+    157,
+/**/
+    156,
+/**/
+    155,
+/**/
+    154,
+/**/
+    153,
+/**/
+    152,
+/**/
+    151,
+/**/
+    149,
+/**/
+    148,
+/**/
+    147,
+/**/
+    146,
+/**/
+    145,
+/**/
+    144,
+/**/
+    143,
+/**/
+    142,
+/**/
+    141,
+/**/
+    140,
+/**/
+    139,
+/**/
+    137,
+/**/
+    136,
+/**/
+    135,
+/**/
+    134,
+/**/
+    133,
+/**/
+    132,
+/**/
+    131,
+/**/
+    130,
+/**/
+    129,
+/**/
+    128,
+/**/
+    127,
+/**/
+    126,
+/**/
+    125,
+/**/
+    124,
+/**/
+    123,
+/**/
+    122,
+/**/
+    121,
+/**/
+    120,
+/**/
+    119,
+/**/
+    118,
+/**/
+    117,
+/**/
+    116,
+/**/
+    115,
+/**/
+    114,
+/**/
+    113,
+/**/
+    112,
+/**/
+    111,
+/**/
+    110,
+/**/
+    109,
+/**/
+    108,
+/**/
+    107,
+/**/
+    106,
+/**/
+    105,
+/**/
+    104,
+/**/
+    103,
+/**/
+    102,
+/**/
+    100,
+/**/
+    99,
+/**/
+    98,
+/**/
+    97,
+/**/
+    96,
+/**/
+    95,
+/**/
+    94,
+/**/
+    92,
+/**/
+    91,
+/**/
+    90,
+/**/
+    87,
+/**/
+    86,
+/**/
+    85,
+/**/
+    84,
+/**/
+    83,
+/**/
+    82,
+/**/
+    81,
+/**/
+    80,
+/**/
+    79,
+/**/
+    78,
+/**/
+    77,
+/**/
+    76,
+/**/
+    75,
+/**/
+    73,
+/**/
+    70,
+/**/
+    69,
+/**/
+    68,
+/**/
+    67,
+/**/
+    66,
+/**/
+    65,
+/**/
+    64,
+/**/
+    63,
+/**/
+    62,
+/**/
+    61,
+/**/
+    60,
+/**/
+    59,
+/**/
+    58,
+/**/
+    57,
+/**/
+    56,
+/**/
+    55,
+/**/
+    54,
+/**/
+    53,
+/**/
+    52,
+/**/
+    51,
+/**/
+    50,
+/**/
+    48,
+/**/
+    47,
+/**/
+    46,
+/**/
+    45,
+/**/
+    44,
+/**/
+    43,
+/**/
+    42,
+/**/
+    40,
+/**/
+    39,
+/**/
+    38,
+/**/
+    37,
+/**/
+    35,
+/**/
+    34,
+/**/
+    33,
+/**/
+    32,
+/**/
+    31,
+/**/
+    30,
+/**/
+    29,
+/**/
+    28,
+/**/
+    27,
+/**/
+    26,
+/**/
+    25,
+/**/
+    24,
+/**/
+    23,
+/**/
+    22,
+/**/
+    21,
+/**/
+    20,
+/**/
+    19,
+/**/
+    18,
+/**/
+    17,
+/**/
+    16,
+/**/
+    15,
+/**/
+    14,
+/**/
+    13,
+/**/
+    12,
+/**/
+    11,
+/**/
+    10,
+/**/
+    9,
+/**/
+    8,
+/**/
+    6,
+/**/
+    5,
+/**/
+    4,
+/**/
+    3,
+/**/
+    2,
+/**/
+    1,
+/**/
     0
 };
 
+/*
+ * Place to put a short description when adding a feature with a patch.
+ * Keep it short, e.g.,: "relative numbers", "persistent undo".
+ * Also add a comment marker to separate the lines.
+ * See the official Vim patches for the diff format: It must use a context of
+ * one line only.  Create it by hand or use "diff -C2" and edit the patch.
+ */
+static char *(extra_patches[]) =
+{   /* Add your patch description below this line */
+/**/
+    NULL
+};
+
     int
 highest_patch()
 {
@@ -786,7 +1157,7 @@
     MSG_PUTS(_("\nRISC OS version"));
 #endif
 #ifdef VMS
-    MSG_PUTS("\nOpenVMS version");
+    MSG_PUTS(_("\nOpenVMS version"));
 # ifdef HAVE_PATHDEF
     if (*compiled_arch != NUL)
     {
@@ -825,6 +1196,19 @@
 	}
     }
 
+    /* Print the list of extra patch descriptions if there is at least one. */
+    if (extra_patches[0] != NULL)
+    {
+	MSG_PUTS(_("\nExtra patches: "));
+	s = "";
+	for (i = 0; extra_patches[i] != NULL; ++i)
+	{
+	    MSG_PUTS(s);
+	    s = ", ";
+	    MSG_PUTS(extra_patches[i]);
+	}
+    }
+
 #ifdef MODIFIED_BY
     MSG_PUTS("\n");
     MSG_PUTS(_("Modified by "));
diff -Naur vim72.orig/src/vim.h vim72/src/vim.h
--- vim72.orig/src/vim.h	2008-08-09 09:03:38.000000000 -0700
+++ vim72/src/vim.h	2009-06-05 14:24:34.000000000 -0700
@@ -341,8 +341,14 @@
 #ifdef BACKSLASH_IN_FILENAME
 # define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`%#'\"|!<")
 #else
-# define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
-# define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
+# ifdef VMS
+    /* VMS allows a lot of characters in the file name */
+#  define PATH_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'\"|!")
+#  define SHELL_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'|!()&")
+# else
+#  define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
+#  define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
+# endif
 #endif
 
 #define NUMBUFLEN 30	    /* length of a buffer to store a number in ASCII */
@@ -370,7 +376,7 @@
    * Define __w64 as an empty token for everything but MSVC 7.x or later.
    */
 # if !defined(_MSC_VER)	|| (_MSC_VER < 1300)
-#  define __w64 
+#  define __w64
 # endif
 typedef unsigned long __w64	long_u;
 typedef		 long __w64     long_i;
@@ -702,6 +708,8 @@
 #define EXPAND_USER_DEFINED	30
 #define EXPAND_USER_LIST	31
 #define EXPAND_SHELLCMD		32
+#define EXPAND_CSCOPE		33
+#define EXPAND_SIGN		34
 
 /* Values for exmode_active (0 is no exmode) */
 #define EXMODE_NORMAL		1
@@ -1051,6 +1059,7 @@
 #define WSP_HELP	16	/* creating the help window */
 #define WSP_BELOW	32	/* put new window below/right */
 #define WSP_ABOVE	64	/* put new window above/left */
+#define WSP_NEWLOC	128	/* don't copy location list */
 
 /*
  * arguments for gui_set_shellsize()
@@ -1451,8 +1460,8 @@
 # define PERROR(msg)		    perror(msg)
 #endif
 
-typedef long	    linenr_T;		/* line number type */
-typedef unsigned    colnr_T;		/* column number type */
+typedef long	linenr_T;		/* line number type */
+typedef int	colnr_T;		/* column number type */
 typedef unsigned short disptick_T;	/* display tick type */
 
 #define MAXLNUM (0x7fffffffL)		/* maximum (invalid) line number */
@@ -1728,7 +1737,8 @@
 #define VV_MOUSE_COL	51
 #define VV_OP		52
 #define VV_SEARCHFORWARD 53
-#define VV_LEN		54	/* number of v: vars */
+#define VV_OLDFILES	54
+#define VV_LEN		55	/* number of v: vars */
 
 #ifdef FEAT_CLIPBOARD
 
@@ -1979,6 +1989,9 @@
 # endif
 #endif
 
+#ifndef FEAT_NETBEANS_INTG
+# undef NBDEBUG
+#endif
 #ifdef NBDEBUG /* Netbeans debugging. */
 # include "nbdebug.h"
 #else
@@ -2054,4 +2067,10 @@
 #define DOSO_VIMRC	1	/* loading vimrc file */
 #define DOSO_GVIMRC	2	/* loading gvimrc file */
 
+/* flags for read_viminfo() and children */
+#define VIF_WANT_INFO		1	/* load non-mark info */
+#define VIF_WANT_MARKS		2	/* load file marks */
+#define VIF_FORCEIT		4	/* overwrite info already read */
+#define VIF_GET_OLDFILES	8	/* load v:oldfiles */
+
 #endif /* VIM__H */
diff -Naur vim72.orig/src/window.c vim72/src/window.c
--- vim72.orig/src/window.c	2008-08-06 04:00:30.000000000 -0700
+++ vim72/src/window.c	2009-06-05 14:25:31.000000000 -0700
@@ -12,7 +12,7 @@
 static int path_is_url __ARGS((char_u *p));
 #if defined(FEAT_WINDOWS) || defined(PROTO)
 static int win_split_ins __ARGS((int size, int flags, win_T *newwin, int dir));
-static void win_init __ARGS((win_T *newp, win_T *oldp));
+static void win_init __ARGS((win_T *newp, win_T *oldp, int flags));
 static void frame_comp_pos __ARGS((frame_T *topfrp, int *row, int *col));
 static void frame_setheight __ARGS((frame_T *curfrp, int height));
 #ifdef FEAT_VERTSPLIT
@@ -593,9 +593,7 @@
 		++allow_keys;   /* no mapping for xchar, but allow key codes */
 		if (xchar == NUL)
 		    xchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 		LANGMAP_ADJUST(xchar, TRUE);
-#endif
 		--no_mapping;
 		--allow_keys;
 #ifdef FEAT_CMDL_INFO
@@ -912,7 +910,7 @@
 	    return FAIL;
 
 	/* make the contents of the new window the same as the current one */
-	win_init(wp, curwin);
+	win_init(wp, curwin, flags);
     }
 
     /*
@@ -1161,11 +1159,14 @@
  * Initialize window "newp" from window "oldp".
  * Used when splitting a window and when creating a new tab page.
  * The windows will both edit the same buffer.
+ * WSP_NEWLOC may be specified in flags to prevent the location list from
+ * being copied.
  */
     static void
-win_init(newp, oldp)
+win_init(newp, oldp, flags)
     win_T	*newp;
     win_T	*oldp;
+    int		 flags UNUSED;
 {
     int		i;
 
@@ -1190,7 +1191,14 @@
     copy_jumplist(oldp, newp);
 #endif
 #ifdef FEAT_QUICKFIX
-    copy_loclist(oldp, newp);
+    if (flags & WSP_NEWLOC)
+    {
+	/* Don't copy the location list.  */
+	newp->w_llist = NULL;
+	newp->w_llist_ref = NULL;
+    }
+    else
+	copy_loclist(oldp, newp);
 #endif
     if (oldp->w_localdir != NULL)
 	newp->w_localdir = vim_strsave(oldp->w_localdir);
@@ -1258,11 +1266,10 @@
  * Must be called when there is just one window, filling the whole screen
  * (excluding the command line).
  */
-/*ARGSUSED*/
     int
 make_windows(count, vertical)
     int		count;
-    int		vertical;	/* split windows vertically if TRUE */
+    int		vertical UNUSED;  /* split windows vertically if TRUE */
 {
     int		maxcount;
     int		todo;
@@ -2343,11 +2350,10 @@
  * Remove a window and its frame from the tree of frames.
  * Returns a pointer to the window that got the freed up space.
  */
-/*ARGSUSED*/
     static win_T *
 winframe_remove(win, dirp, tp)
     win_T	*win;
-    int		*dirp;		/* set to 'v' or 'h' for direction if 'ea' */
+    int		*dirp UNUSED;	/* set to 'v' or 'h' for direction if 'ea' */
     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
 {
     frame_T	*frp, *frp2, *frp3;
@@ -3220,7 +3226,7 @@
     else
     {
 	/* First window in new tab page, initialize it from "oldwin". */
-	win_init(curwin, oldwin);
+	win_init(curwin, oldwin, 0);
 
 # ifdef FEAT_SCROLLBIND
 	/* We don't want scroll-binding in the first window. */
@@ -3490,10 +3496,9 @@
  * FAIL.
  * Careful: When OK is returned need to get a new tab page very very soon!
  */
-/*ARGSUSED*/
     static int
 leave_tabpage(new_curbuf)
-    buf_T	*new_curbuf;	    /* what is going to be the new curbuf,
+    buf_T	*new_curbuf UNUSED;    /* what is going to be the new curbuf,
 				       NULL if unknown */
 {
     tabpage_T	*tp = curtab;
@@ -3535,11 +3540,10 @@
  * Start using tab page "tp".
  * Only to be used after leave_tabpage() or freeing the current tab page.
  */
-/*ARGSUSED*/
     static void
 enter_tabpage(tp, old_curbuf)
     tabpage_T	*tp;
-    buf_T	*old_curbuf;
+    buf_T	*old_curbuf UNUSED;
 {
     int		old_off = tp->tp_firstwin->w_winrow;
     win_T	*next_prevwin = tp->tp_prevwin;
@@ -4028,14 +4032,14 @@
 	    if (mch_dirname(cwd, MAXPATHL) == OK)
 		globaldir = vim_strsave(cwd);
 	}
-	mch_chdir((char *)curwin->w_localdir);
-	shorten_fnames(TRUE);
+	if (mch_chdir((char *)curwin->w_localdir) == 0)
+	    shorten_fnames(TRUE);
     }
     else if (globaldir != NULL)
     {
 	/* Window doesn't have a local directory and we are not in the global
 	 * directory: Change to the global directory. */
-	mch_chdir((char *)globaldir);
+	ignored = mch_chdir((char *)globaldir);
 	vim_free(globaldir);
 	globaldir = NULL;
 	shorten_fnames(TRUE);
@@ -4147,10 +4151,9 @@
 /*
  * allocate a window structure and link it in the window list
  */
-/*ARGSUSED*/
     static win_T *
 win_alloc(after)
-    win_T	*after;
+    win_T	*after UNUSED;
 {
     win_T	*newwin;
 
diff -Naur vim72.orig/src/workshop.c vim72/src/workshop.c
--- vim72.orig/src/workshop.c	2008-06-21 11:53:26.000000000 -0700
+++ vim72/src/workshop.c	2009-06-05 14:25:31.000000000 -0700
@@ -204,12 +204,11 @@
  * Function:
  *	Load a given file into the WorkShop buffer.
  */
-/*ARGSUSED*/
     void
 workshop_load_file(
 	char	*filename,		/* the file to load */
 	int	 line,			/* an optional line number (or 0) */
-	char	*frameid)		/* used for multi-frame support */
+	char	*frameid UNUSED)	/* used for multi-frame support */
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
@@ -263,10 +262,9 @@
     load_window(filename, lineno);
 }
 
-/*ARGSUSED*/
     void
 workshop_front_file(
-	char	*filename)
+	char	*filename UNUSED)
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
@@ -538,9 +536,8 @@
  * breakpoints have moved when a program has been recompiled and
  * reloaded into dbx.
  */
-/*ARGSUSED*/
     void
-workshop_moved_marks(char *filename)
+workshop_moved_marks(char *filename UNUSED)
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
@@ -575,11 +572,10 @@
     return (int)h;
 }
 
-/*ARGSUSED*/
     void
 workshop_footer_message(
-	char		*message,
-	int		 severity)	/* severity is currently unused */
+	char	*message,
+	int	severity UNUSED)	/* severity is currently unused */
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
@@ -687,15 +683,14 @@
  * command. The globals curMenuName and curMenuPriority contain the name and
  * priority of the parent menu tree.
  */
-/*ARGSUSED*/
     void
 workshop_menu_item(
 	char		*label,
 	char		*verb,
-	char		*accelerator,
+	char		*accelerator UNUSED,
 	char		*acceleratorText,
-	char		*name,
-	char		*filepos,
+	char		*name UNUSED,
+	char		*filepos UNUSED,
 	char		*sensitive)
 {
     char		 cbuf[BUFSIZ];
@@ -810,13 +805,12 @@
     workshopInitDone = True;
 }
 
-/*ARGSUSED*/
     void
 workshop_toolbar_button(
 	char	*label,
 	char	*verb,
-	char	*senseVerb,
-	char	*filepos,
+	char	*senseVerb UNUSED,
+	char	*filepos UNUSED,
 	char	*help,
 	char	*sense,
 	char	*file,
@@ -968,7 +962,9 @@
 	    if (strcmp(option, "syntax") == 0)
 		vim_snprintf(cbuf, sizeof(cbuf), "syntax %s", value);
 	    else if (strcmp(option, "savefiles") == 0)
-		; /* XXX - Not yet implemented */
+	    {
+		/* XXX - Not yet implemented */
+	    }
 	    break;
 
 	case 'l':
@@ -1098,10 +1094,9 @@
 /*
  * A button in the toolbar has been pushed.
  */
-/*ARGSUSED*/
     int
 workshop_get_positions(
-	void		*clientData,	/* unused */
+	void		*clientData UNUSED,
 	char	       **filename,	/* output data */
 	int		*curLine,	/* output data */
 	int		*curCol,	/* output data */
@@ -1121,8 +1116,12 @@
 				      ? (char *)curbuf->b_sfname : "<None>");
 #endif
 
-    strcpy(ffname, (char *) curbuf->b_ffname);
-    *filename = ffname;		/* copy so nobody can change b_ffname */
+    if (curbuf->b_ffname == NULL)
+	ffname[0] = NUL;
+    else
+	/* copy so nobody can change b_ffname */
+	strcpy(ffname, (char *) curbuf->b_ffname);
+    *filename = ffname;
     *curLine = curwin->w_cursor.lnum;
     *curCol = curwin->w_cursor.col;
 
@@ -1522,9 +1521,8 @@
 	return NULL;
 }
 
-/*ARGSUSED*/
     void
-workshop_save_sensitivity(char *filename)
+workshop_save_sensitivity(char *filename UNUSED)
 {
 }
 
